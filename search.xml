<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Screen 命令</title>
      <link href="/2023/05/06/linux/screen/"/>
      <url>/2023/05/06/linux/screen/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://handerfly.github.io/linux/2019/03/31/Screan%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">screen 命令使用 - 笨鸟教程的博客 | BY BenderFly</a></p></blockquote><p>screen 是一个非常有用的命令，提供从单个 SSH 会话中使用多个 shell 窗口（会话）的能力。当会话被分离或网络中断时，screen 会话中启动的进程仍将运行，你可以随时重新连接到 screen 会话</p><h2 id="查看是否安装"><a href="#查看是否安装" class="headerlink" title="查看是否安装"></a>查看是否安装</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">screen -v</span><br><span class="line">Screen version 4.00.03 (FAU)</span><br></pre></td></tr></table></figure><h2 id="安装-Screen"><a href="#安装-Screen" class="headerlink" title="安装 Screen"></a>安装 Screen</h2><p><strong>CentOS/RedHat/Fedora</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y <span class="keyword">install</span> screen</span><br></pre></td></tr></table></figure><p><strong>Ubuntu/Debian</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> -y install screen</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><strong>参数说明</strong></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-A 　将所有的视窗都调整为目前终端机的大小。</span></span><br><span class="line"><span class="deletion">-d     &lt;作业名称&gt; 　将指定的screen作业离线。</span></span><br><span class="line"><span class="deletion">-h     &lt;行数&gt; 　指定视窗的缓冲区行数。</span></span><br><span class="line"><span class="deletion">-m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。</span></span><br><span class="line"><span class="deletion">-r      &lt;作业名称&gt; 　恢复离线的screen作业。</span></span><br><span class="line"><span class="deletion">-R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。</span></span><br><span class="line"><span class="deletion">-s 　指定建立新视窗时，所要执行的shell。</span></span><br><span class="line"><span class="deletion">-S    &lt;作业名称&gt; 　指定screen作业的名称。</span></span><br><span class="line"><span class="deletion">-v 　显示版本信息。</span></span><br><span class="line"><span class="deletion">-x 　恢复之前离线的screen作业。</span></span><br><span class="line"><span class="deletion">-ls或--list 　显示目前所有的screen作业。</span></span><br><span class="line"><span class="deletion">-wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业。</span></span><br></pre></td></tr></table></figure><p><strong>常用 screen 参数</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">screen -S session_name           # 新建一个叫session_name的session</span><br><span class="line">screen -ls（或者screen -list）   # 列出当前所有的session</span><br><span class="line">screen -r session_name            # 回到session_name这个session</span><br><span class="line">screen -d session_name           # 远程detach某个session</span><br><span class="line">screen -d -r session_name        # 结束当前session并回到session_name这个session</span><br></pre></td></tr></table></figure><p><strong>在每个 screen session 下，命令都以 ctrl+a、ctrl-a，常用的几个操作如下：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctrl-a x   # 锁住当前的shell window，需用用户密码解锁</span><br><span class="line">ctrl-a d   # detach，暂时离开当前session，将当前<span class="built_in"> screen </span>session 转到后台执行，并会返回没进<span class="built_in"> screen </span>时的状态，此时在<span class="built_in"> screen </span>session 里，每个shell client内运行的 process (无论是前台/后台)都在继续执行，即使 logout 也不影响</span><br><span class="line">ctrl-a z   # 把当前session放到后台执行，用 shell 的 fg 命令则可回去。</span><br></pre></td></tr></table></figure><p><strong>其他说明</strong></p><p>如果在执行 screen -r pts-0.localhost 提示下面信息，无法跳到 pts-0.localhost 这个会话<img src="https://raw.githubusercontent.com/handerfly/handerfly.github.io/master/img/screen-error.png" alt="screen"><br>此时请先执行 screen -d pts-0.localhost,再执行 screen -r pts-0.localhost，即可跳到 pts-0.localhost 这个会话（即先 detach，再连接）</p><h2 id="启动一个-screen-会话"><a href="#启动一个-screen-会话" class="headerlink" title="启动一个 screen 会话"></a>启动一个 screen 会话</h2><p>命令行中输入 screen 来启动它</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">screen</span><br><span class="line"><span class="comment">#要使用会话名称创建新会话，请运行以下命令：</span></span><br><span class="line">screen -S name</span><br></pre></td></tr></table></figure><h2 id="从-screen-会话中分离"><a href="#从-screen-会话中分离" class="headerlink" title="从 screen 会话中分离"></a>从 screen 会话中分离</h2><p>要从当前的 screen 会话中分离，你可以按下 Ctrl-A 和 d。所有的 screen 会话仍将是活跃的，你之后可以随时重新连接。</p><h2 id="重新连接到-screen-会话"><a href="#重新连接到-screen-会话" class="headerlink" title="重新连接到 screen 会话"></a>重新连接到 screen 会话</h2><p>如果你从一个会话分离，或者由于某些原因你的连接被中断了，你可以使用下面的命令重新连接：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">screen -r</span></span><br></pre></td></tr></table></figure><p>如果你有多个 screen 会话，你可以用 ls 参数列出它们。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">screen</span> <span class="string">-ls</span></span><br><span class="line"></span><br><span class="line"><span class="attr">There are screens on:</span></span><br><span class="line"><span class="number">7880.</span><span class="string">session</span>    <span class="string">(Detached)</span></span><br><span class="line"><span class="number">7934.</span><span class="string">session2</span>   <span class="string">(Detached)</span></span><br><span class="line"><span class="number">7907.</span><span class="string">session1</span>   <span class="string">(Detached)</span></span><br><span class="line"><span class="number">3</span> <span class="string">Sockets</span> <span class="string">in</span> <span class="string">/var/run/screen/S-root.</span></span><br></pre></td></tr></table></figure><p>在我们的例子中，我们有三个活跃的 screen 会话。因此，如果你想要还原 “session2” 会话，你可以执行：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r <span class="number">7934</span></span><br></pre></td></tr></table></figure><p>或者使用 screen 名称。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">screen</span> -r -S session2</span><br></pre></td></tr></table></figure><h2 id="中止-screen-会话"><a href="#中止-screen-会话" class="headerlink" title="中止 screen 会话"></a>中止 screen 会话</h2><p>有几种方法来中止 screen 会话。你可以按下 Ctrl+d ，或者在命令行中使用 exit 命令。</p><p>要查看 screen 命令所有有用的功能，你可以查看 screen 的 man 手册。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">man screen</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">screen -<span class="built_in"> screen </span>manager with VT100/ANSI terminal emulation</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">screen [ -options ] [ cmd [ args ] ]</span><br><span class="line">screen -r [[pid.]tty[.host]]</span><br><span class="line">screen -r sessionowner/[[pid.]tty[.host]]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker 安装与配置</title>
      <link href="/2023/04/22/linux/docker-installation/"/>
      <url>/2023/04/22/linux/docker-installation/</url>
      
        <content type="html"><![CDATA[<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><blockquote><p><a href="https://docs.docker.com/engine/install/ubuntu/" target="_blank" rel="noopener">Install Docker Engine on Ubuntu | Docker Documentation</a></p><p><a href="https://yeasy.gitbook.io/docker_practice/install/ubuntu" target="_blank" rel="noopener">Ubuntu - Docker — 从入门到实践 (gitbook.io)</a></p><p><a href="https://yeasy.gitbook.io/docker_practice/compose/install" target="_blank" rel="noopener">安装与卸载 - Docker — 从入门到实践 (gitbook.io)</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker \</span><br><span class="line">             docker-engine \</span><br><span class="line">             docker.io</span><br><span class="line">             </span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install \</span><br><span class="line">  apt-transport-https \</span><br><span class="line">  ca-certificates \</span><br><span class="line">  curl \</span><br><span class="line">  gnupg \</span><br><span class="line">  lsb-release</span><br><span class="line">  </span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line">echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Install Docker Compose</span></span><br><span class="line">sudo apt-get install docker-compose-plugin</span><br></pre></td></tr></table></figure><h3 id="apt-换源-可选"><a href="#apt-换源-可选" class="headerlink" title="apt 换源 (可选)"></a>apt 换源 (可选)</h3><blockquote><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">ubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 预发布软件源，不建议启用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure><p>修改<code>/etc/apt/sources.list</code>为以上源</p><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><blockquote><p><a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">Overview of Docker Compose | Docker Documentation</a></p></blockquote><p>Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. To learn more about all the features of Compose, see <a href="https://docs.docker.com/compose/#features" target="_blank" rel="noopener">the list of features</a>.</p><p>Compose works in all environments: production, staging, development, testing, as well as CI workflows. You can learn more about each case in <a href="https://docs.docker.com/compose/#common-use-cases" target="_blank" rel="noopener">Common Use Cases</a>.</p><p>Using Compose is basically a three-step process:</p><ol><li>Define your app’s environment with a <code>Dockerfile</code> so it can be reproduced anywhere.</li><li>Define the services that make up your app in <code>docker-compose.yml</code> so they can be run together in an isolated environment.</li><li>Run <code>docker compose up</code> and the <a href="https://docs.docker.com/compose/#compose-v2-and-the-new-docker-compose-command" target="_blank" rel="noopener">Docker compose command</a> starts and runs your entire app. You can alternatively run <code>docker-compose up</code> using the docker-compose binary.</li></ol><p>用Compose运行多个容器，服务的运行通过<code>YAML</code>文件配置，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">"5000:5000"</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">"redis:alpine"</span></span><br></pre></td></tr></table></figure><p>不同的服务就是不同的镜像的容器，运行compose，会根据services创建相关的镜像，运行后，每个镜像的实例开启，构成一个project的运行环境。</p><ul><li>每个容器间如何访问呢？project开始执行后，每个容器都产生一个containerID，这个ID会在每个容器的/etc/hosts中记录下该ID号对应的docker虚拟网络中IP地址</li></ul><h3 id="commands"><a href="#commands" class="headerlink" title="commands"></a>commands</h3><ol><li>docker compose down/up/stop/start 等命令执行时会通过本地路径查找docker-compose.yml配置文件</li><li>compose 创建容器的命令规则：<ul><li>如果service的image来自远程的镜像源，名称为<code>image:label</code></li><li>如果通过本地Dockerfile构建，则名称来格式<code>project_name:service_name</code></li></ul></li></ol><h2 id="Uninstall-Docker-Engine"><a href="#Uninstall-Docker-Engine" class="headerlink" title="Uninstall Docker Engine"></a>Uninstall Docker Engine</h2><blockquote><p><a href="https://docs.docker.com/engine/install/ubuntu/#uninstall-docker-engine" target="_blank" rel="noopener">Install Docker Engine on Ubuntu | Docker Documentation</a></p></blockquote><ol><li><p>Uninstall the Docker Engine, CLI, Containerd, and Docker Compose packages:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> purge docker-<span class="keyword">ce</span> docker-<span class="keyword">ce</span>-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure></li><li><p>Images, containers, volumes, or customized configuration files on your host are not automatically removed. To delete all images, containers, and volumes:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf /var/<span class="class"><span class="keyword">lib</span>/<span class="title">docker</span></span></span><br><span class="line">$ sudo rm -rf /var/<span class="class"><span class="keyword">lib</span>/<span class="title">containerd</span></span></span><br></pre></td></tr></table></figure></li></ol><p>You must delete any edited configuration files manually.</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For more information, please refer to https://aka.ms/vscode-docker-python</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span>-slim</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># During debugging, this entry point will be overridden. For more information, please refer to https://aka.ms/vscode-docker-python-debug</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span></span><br></pre></td></tr></table></figure><p>From: 基于某一镜像创建镜像</p><p>WORKDIR：project在微系统中的工作目录，不指定则为“/”目录</p><p>EXPOSE：表示允许暴露微系统中的指定端口号</p><p>COPY：因为服务是微系统中运行，因此要将工作目录的文件复制到微服务</p><p>RUN：构建镜像时，执行的命令，命令能否执行取决于基于的系统是否支持该命令</p><p>CMD：镜像构建完后，需要在容器中执行的命令。</p><p>RUN和CMD的区别在于后者是在镜像构建后执行的命令，此时镜像已经运行了，前者相当于在构建镜像。</p><h1 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h1><h3 id="1-docker容器中执行命令不能联网，通过重启docker服务解决"><a href="#1-docker容器中执行命令不能联网，通过重启docker服务解决" class="headerlink" title="1. docker容器中执行命令不能联网，通过重启docker服务解决"></a>1. docker容器中执行命令不能联网，通过重启docker服务解决</h3><p>通过重启docker服务解决</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker.service</span><br></pre></td></tr></table></figure><p><code>RUN pip install -r requirements.txt</code> 不成功可能由于镜像源</p><h3 id="2-Docker-安装错误"><a href="#2-Docker-安装错误" class="headerlink" title="2. Docker 安装错误"></a>2. Docker 安装错误</h3><p>可能原因是apt错误</p><h3 id="3-Docker-error-HTTP-408-response-body-invalid-character-‘-lt-’-looking-for-beginning-of-value"><a href="#3-Docker-error-HTTP-408-response-body-invalid-character-‘-lt-’-looking-for-beginning-of-value" class="headerlink" title="3. Docker error: HTTP 408 response body: invalid character ‘&lt;’ looking for beginning of value"></a>3. Docker error: HTTP 408 response body: invalid character ‘&lt;’ looking for beginning of value</h3><blockquote><p><a href="http://www.itclubx.com/post/158" target="_blank" rel="noopener">Docker error: HTTP 408 response body: invalid character ‘&lt;’ looking for beginning of value - IT开发屋 (itclubx.com)</a></p></blockquote><ol><li>Docker源的问题</li><li>镜像或标签错误</li></ol><h3 id="4-OCI-runtime-exec-failed-exec-failed-container-linux-go-380-starting-container-process-caused-exec-“bash”-executable-file-not-found-in-PATH-unknown"><a href="#4-OCI-runtime-exec-failed-exec-failed-container-linux-go-380-starting-container-process-caused-exec-“bash”-executable-file-not-found-in-PATH-unknown" class="headerlink" title="4. OCI runtime exec failed: exec failed: container_linux.go:380: starting container process caused: exec: “bash”: executable file not found in $PATH: unknown"></a>4. OCI runtime exec failed: exec failed: container_linux.go:380: starting container process caused: exec: “bash”: executable file not found in $PATH: unknown</h3><p>在不同的发行版中支持的shell不同，如果<code>bash</code>不能执行，可能可以切换成<code>sh</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 终端开启代理</title>
      <link href="/2023/04/18/linux/terminal-proxy/"/>
      <url>/2023/04/18/linux/terminal-proxy/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/longtails/notes/blob/master/Linux/Linux终端v2ray代理.md" target="_blank" rel="noopener">notes/Linux终端v2ray代理.md at master · longtails/notes (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 中的 apt 错误</title>
      <link href="/2023/03/31/linux/apt-errors/"/>
      <url>/2023/03/31/linux/apt-errors/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://askubuntu.com/questions/1164103/broken-packages-update-notifier-update-managticer-that-disrupts-all-kind-of-i" target="_blank" rel="noopener">broken packages (update-notifier, update managticer) that disrupts all kind of installation using apt or apt-get or dpkg or even synap - Ask Ubuntu</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Errors were encountered while processing:</span><br><span class="line">update-notifier-common</span><br><span class="line">update-notifier</span><br><span class="line">ubuntu-desktop</span><br><span class="line">update-manager</span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure><h2 id="ubuntu-drivers"><a href="#ubuntu-drivers" class="headerlink" title="ubuntu-drivers"></a>ubuntu-drivers</h2><blockquote><p><a href="https://forums.developer.nvidia.com/t/warning-pkg-get-support-nvidia-driver-510-package-has-invalid-support-pbheader-cannot-determine-support-level/205168/5" target="_blank" rel="noopener">WARNING:root:_pkg_get_support nvidia-driver-510: package has invalid Support PBheader, cannot determine support level - Graphics / Linux / Linux - NVIDIA Developer Forums</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>How To Switch Between Intel and Nvidia Graphics Card on Ubuntu</title>
      <link href="/2023/03/28/linux/switch-intel-nvidia-graphics-card/"/>
      <url>/2023/03/28/linux/switch-intel-nvidia-graphics-card/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.linuxbabe.com/desktop-linux/switch-intel-nvidia-graphics-card-ubuntu" target="_blank" rel="noopener">How To Switch Between Intel and Nvidia Graphics Card on Ubuntu (linuxbabe.com)</a></p><p><a href="https://forums.developer.nvidia.com/t/prime-select-nvidia-selected-but-not-used/121108" target="_blank" rel="noopener">Prime-select - Nvidia selected but not used - Graphics / Linux / Linux - NVIDIA Developer Forums</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> core commands</span></span><br><span class="line">sudo prime-select intel</span><br><span class="line">sudo prime-select nvidia</span><br><span class="line">prime-select query</span><br></pre></td></tr></table></figure><hr><p>These days, it is common to see two graphics cards on laptops: Intel graphics card and <a href="https://www.linuxbabe.com/nvidia-graphics-card" target="_blank" rel="noopener">Nvidia graphics card</a>. This tutorial will show you how to seamlessly switch between Intel and Nvidia graphics card on <a href="https://www.linuxbabe.com/tag/ubuntu" target="_blank" rel="noopener">Ubuntu</a>.</p><h2 id="Which-Graphics-Card-Should-You-Use"><a href="#Which-Graphics-Card-Should-You-Use" class="headerlink" title="Which Graphics Card Should You Use?"></a>Which Graphics Card Should You Use?</h2><p>For gaming and 3D charting that requires a lot of graphics power, use the discrete Nvidia card. If you are not interested in gaming or 3D charting, the integrated Intel graphics card, which is embedded in the CPU, is good enough and it consumes less energy than Nvidia card does, resulting in less energy consumption and longer battery hours.</p><h2 id="Step-1-Check-What-Graphics-Card-You’ve-Got"><a href="#Step-1-Check-What-Graphics-Card-You’ve-Got" class="headerlink" title="Step 1: Check What Graphics Card You’ve Got"></a>Step 1: Check What Graphics Card You’ve Got</h2><p>The first thing you need to do is to check what graphics card your laptop has. This is a very easy task on Ubuntu. Just paste the following command in the terminal window.</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -k <span class="string">| grep -A 2 -i "</span>VGA<span class="string">"</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/05/12/Unimsw3TSu1MoRk.png" alt="How To Switch Between Intel and Nvidia Graphics Card on Ubuntu"></p><p>As you can see, my laptop has Intel and Nvidia Graphics card. If this is also the case for you, then continue to read this article.</p><h2 id="Step-2-Check-What-Graphics-Card-You-Laptop-is-Using"><a href="#Step-2-Check-What-Graphics-Card-You-Laptop-is-Using" class="headerlink" title="Step 2: Check What Graphics Card You Laptop is Using"></a>Step 2: Check What Graphics Card You Laptop is Using</h2><p>Ubuntu uses Intel graphics by default. If you think you made some changes to this before and you don’t remember what graphics card is being used, then go to <code>system settings</code> &gt; <code>details</code>, and you will see the graphics card being used right now.</p><h2 id="Step-3-Install-Nvidia-Graphics-Card-Driver"><a href="#Step-3-Install-Nvidia-Graphics-Card-Driver" class="headerlink" title="Step 3: Install Nvidia Graphics Card Driver"></a>Step 3: Install Nvidia Graphics Card Driver</h2><p>Ubuntu comes with the open source nouveau driver which is included in the Linux kernel for Nvidia cards. However, this driver lacks 3D acceleration support. For best graphics performance, we can use the <code>software-properties-gtk</code> program to install the proprietary driver. Enter the below command in the terminal window.</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">software-properties-gtk</span></span><br></pre></td></tr></table></figure><p>This will open up the <code>software &amp; updates</code> window. Click the <code>Additional Drivers</code> tab. You can see what driver is being used for Nvidia card (Nouveau by default) and a list of proprietary drivers.</p><p><img src="https://s2.loli.net/2022/05/12/1pUuPqFDleZoAd2.png" alt="Software &amp; Updates_ additional drivers"></p><p>You can choose the highest version. You can also open up a new terminal window and enter the following command to see which binary driver is recommended for your specific card.</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo ubuntu-drivers devices</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/05/12/1JZqbiEmt5ApMnU.png" alt="How To Switch Between Intel and Nvidia Graphics Card on Ubuntu"></p><p>As you can see, <code>nvidia-352</code> is recommended for my Nvidia card, so I enter this command to install it.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install nvidia-352</span><br></pre></td></tr></table></figure><p>After the proprietary driver is installed, re-open <code>software &amp; updates</code> window, you should see that the newly installed driver is being used for Nvidia card. If it’s not being used, select it and click the <code>Apply Changes</code> button at the bottom-right corner.</p><p><img src="https://s2.loli.net/2022/05/12/Bp72jWeCPvTiysu.png" alt="How To Switch Between Intel and Nvidia Graphics Card on Ubuntu"></p><p>Now we have installed the proprietary driver for Nvidia graphics but we still are using the Intel Graphics card.</p><h2 id="Step-4-Switch-to-Nvidia-Graphics-Card"><a href="#Step-4-Switch-to-Nvidia-Graphics-Card" class="headerlink" title="Step 4: Switch to Nvidia Graphics Card"></a>Step 4: Switch to Nvidia Graphics Card</h2><p>After you selected the proprietary driver for Nvidia, You may have to reboot your computer to enable PRIME support. If PRIME supported is not enabled, you might encounter the below message.</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message: PRIME: <span class="keyword">is</span> <span class="literal">it</span> supported? <span class="literal">no</span></span><br></pre></td></tr></table></figure><p>Once rebooted, open <code>Nvidia X Server Settings</code> from Unity Dash. Alternatively, you can issue this command to open it.</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nvidia-settings</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/05/12/3oGYdEhuIglAxey.png" alt="NVIDIA X Server Settings_ prime profiles"></p><p>Click <code>PRIME Profiles</code> tab on the left pane, and then select Nvidia card on the right pane. If you don’t have PRIME Profiles, reboot your computer so PRIME can be enabled.</p><p>Now go to <code>System Settings</code> &gt; <code>Details</code>, you will see the Nvidia Graphics card.</p><p><img src="https://s2.loli.net/2022/05/12/oRAEhya65YdOt8c.png" alt="How To Switch Between Intel and Nvidia Graphics Card on Ubuntu"></p><p>To switch back to Intel graphics, simply select Intel in <code>PRIME Profiles</code>. You can also use terminal commands to switch graphics card. For example, this command will switch to Intel graphics card.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> prime-<span class="literal">select</span> intel</span><br></pre></td></tr></table></figure><p>To switch to Nvidia card:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> prime-<span class="literal">select</span> nvidia</span><br></pre></td></tr></table></figure><p>To check which card is being used right now, run this command:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prime-<span class="keyword">select</span> <span class="keyword">query</span></span><br></pre></td></tr></table></figure><h2 id="How-to-Uninstall-Nvidia-Drivers"><a href="#How-to-Uninstall-Nvidia-Drivers" class="headerlink" title="How to Uninstall Nvidia Drivers"></a>How to Uninstall Nvidia Drivers</h2><p>Sometimes Nvidia drivers can fail and you get a blank desktop with no panel or launcher. Sometimes you may encounter the following error:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver ebridge <span class="keyword">is</span> already registered aborting</span><br></pre></td></tr></table></figure><p>In these cases, you would want to uninstall Nvidia drivers completely which is quite simple to do. Just run the following command to remove all packages that start with nvidia in the package name.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> apt purge nvidia-*</span><br></pre></td></tr></table></figure><p>As always, if you found this post useful,  <a href="https://newsletter.linuxbabe.com/subscription/wkeY5d6pg" target="_blank" rel="noopener">subscribe to our free newsletter</a> or follow us on <a href="https://plus.google.com/+Linuxbabeofficial/posts" target="_blank" rel="noopener">Google+</a>, <a href="https://twitter.com/linuxbabe" target="_blank" rel="noopener">Twitter</a> or <a href="https://www.facebook.com/linuxbabe" target="_blank" rel="noopener">like our Facebook page</a>.</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSH 自动断连问题</title>
      <link href="/2023/03/05/linux/ssh-disconnect-solution/"/>
      <url>/2023/03/05/linux/ssh-disconnect-solution/</url>
      
        <content type="html"><![CDATA[<blockquote><ol><li><a href="https://man.openbsd.org/sshd_config" target="_blank" rel="noopener">sshd_config(5) - OpenBSD manual pages</a></li><li><a href="https://unix.stackexchange.com/questions/3026/what-do-options-serveraliveinterval-and-clientaliveinterval-in-sshd-config-d" target="_blank" rel="noopener">ssh - What do options <code>ServerAliveInterval</code> and <code>ClientAliveInterval</code> in sshd_config do exactly? - Unix &amp; Linux Stack Exchange</a></li></ol></blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>使用<code>ssh</code>连接服务器时，一段时间后出现自动断连，可通过修改<code>sshd</code>服务的相关配置修改。</p><p>配置文件的存放路径：<code>/etc/ssh/sshd_config</code></p><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><h3 id="ClientAliveCountMax"><a href="#ClientAliveCountMax" class="headerlink" title="ClientAliveCountMax"></a>ClientAliveCountMax</h3><p>Sets the number of client alive messages which may be sent without <a href="https://man.openbsd.org/sshd.8" target="_blank" rel="noopener">sshd(8)</a> receiving any messages back from the client. If this threshold is reached while client alive messages are being sent, sshd will disconnect the client, terminating the session. It is important to note that the use of client alive messages is very different from <code>TCPKeepAlive</code>. The client alive messages are sent through the encrypted channel and therefore will not be spoofable. The TCP keepalive option enabled by <code>TCPKeepAlive</code> is spoofable. The client alive mechanism is valuable when the client or server depend on knowing when a connection has become unresponsive.</p><p>The default value is 3. If <code>ClientAliveInterval</code> is set to 15, and <code>ClientAliveCountMax</code> is left at the default, unresponsive SSH clients will be disconnected after approximately 45 seconds. Setting a zero <code>ClientAliveCountMax</code> disables connection termination.</p><h3 id="ClientAliveInterval"><a href="#ClientAliveInterval" class="headerlink" title="ClientAliveInterval"></a>ClientAliveInterval</h3><p>Sets a timeout interval in seconds after which if no data has been received from the client, <a href="https://man.openbsd.org/sshd.8" target="_blank" rel="noopener">sshd(8)</a> will send a message through the encrypted channel to request a response from the client. The default is 0, indicating that these messages will not be sent to the client.</p><p><code>ServerAliveInterval</code>与<code>ServerAliveCountMax</code>含义与上相同</p><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p><code>sshd</code>服务中，通过<code>xxxxAliveCountMax</code>和<code>xxxxAliveInterval</code>参数设置客户端与服务器之间的<strong>连接超时时间</strong></p><ol><li><code>xxxxAliveInterval</code>表示<strong>客户端</strong>或<strong>服务器</strong>发对方发送消息的时间间隔</li><li><code>xxxxAliveCountMax</code>表示允许的最大请求数量，如客服端向服务器发送了若干次后仍未收到响应则自动断开连接</li></ol><p>本地使用<code>ssh</code>连接某主机时，本机承担<strong>客户端（Client）</strong>角色，所连接的主机为<strong>服务器（Server）</strong>角色</p><p>因此对<strong>客户端</strong>，需要设置对<strong>服务器</strong>的超时连接时间：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerAliveInterval <span class="number">30</span></span><br><span class="line">ServerAliveCountMax <span class="number">120</span></span><br></pre></td></tr></table></figure><p>对<strong>服务器端</strong>，需设置对<strong>客户端</strong>的超时连接时间：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClientAliveInterval <span class="number">30</span></span><br><span class="line">ClientAliveCountMax <span class="number">120</span></span><br></pre></td></tr></table></figure><p>使用<code>ssh</code>连接时也可以在<code>$USER/.ssh/config</code>中针对某个连接修改相关配置，而不需要做全局修改，如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host myhostshortcut</span><br><span class="line">     HostName myhost.com</span><br><span class="line">    <span class="built_in"> User </span>barthelemy</span><br><span class="line">     ServerAliveInterval 60</span><br><span class="line">     ServerAliveCountMax 10</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 中创建系统服务</title>
      <link href="/2023/02/27/linux/create-systemd-service/"/>
      <url>/2023/02/27/linux/create-systemd-service/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.shubhamdipt.com/blog/how-to-create-a-systemd-service-in-linux/" target="_blank" rel="noopener">How to create a Systemd service in Linux (shubhamdipt.com)</a></p></blockquote><p>At times you create a script and then you want to have the scripts controlled by systemd or in some cases you wish to have the scripts getting restarted by itself when it is killed due to some reason. In such cases systemd in Linux helps to configure services which can be managed. To do so follow the following steps.</p><ol><li><p><code>cd /etc/systemd/system</code></p></li><li><p>Create a file named your-service.service and include the following:</p></li></ol>   <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=&lt;description about this service&gt;</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">User</span>=&lt;user e.g. root&gt;</span><br><span class="line"><span class="attr">WorkingDirectory</span>=&lt;directory_of_script e.g. /root&gt;</span><br><span class="line"><span class="attr">ExecStart</span>=&lt;script which needs to be executed&gt;</span><br><span class="line"><span class="attr">Restart</span>=always</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><p>   For Python specific projects which include virtual environment:</p>   <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=&lt;project description&gt;</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">User</span>=&lt;user e.g. root&gt;</span><br><span class="line"><span class="attr">WorkingDirectory</span>=&lt;path to your project directory containing your python script&gt;</span><br><span class="line"><span class="attr">ExecStart</span>=/home/user/.virtualenv/bin/python main.py</span><br><span class="line"><span class="attr">Restart</span>=always</span><br><span class="line"><span class="comment"># replace /home/user/.virtualenv/bin/python with your virtualenv and main.py with your script</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><p>   OR</p>   <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=&lt;project description&gt;</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">User</span>=&lt;user e.g. root&gt;</span><br><span class="line"><span class="attr">WorkingDirectory</span>=&lt;path to your project directory&gt;</span><br><span class="line"><span class="attr">ExecStart</span>=/bin/bash -c <span class="string">'cd /home/ubuntu/project/ &amp;&amp; source venv/bin/activate &amp;&amp; python test.py'</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><ol start="3"><li>Reload the service files to include the new service.<br><code>sudo systemctl daemon-reload</code></li></ol><ol start="4"><li>Start your service<br><code>sudo systemctl start your-service.service</code></li></ol><ol start="5"><li>To check the status of your service<br><code>sudo systemctl status example.service</code></li></ol><ol start="6"><li>To enable your service on every reboot<br><code>sudo systemctl enable example.service</code></li></ol><ol start="7"><li>To disable your service on every reboot<br><code>sudo systemctl disable example.service</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 设置防火墙</title>
      <link href="/2023/01/28/linux/linux-firewall/"/>
      <url>/2023/01/28/linux/linux-firewall/</url>
      
        <content type="html"><![CDATA[<blockquote><p>其实，iptables 与 firewalld 都不是真正的防火墙，它们都只是用来定义防火墙策略的防火墙管理工具而已，或者说，它们只是一种服务。iptables服务会把配置好的防火墙策略交由内核层面的 netfilter 网络过滤器来处理，而 firewalld 服务则是把配置好的防火墙策略交由内核层面的 nftables 包过滤框架来处理。</p><p>from <a href="https://www.linuxprobe.com/" target="_blank" rel="noopener">《Linux就该这么学》</a></p></blockquote><p><strong>目前 iptables 已经在新版的Linux操作系统中逐渐被 firewalld 取代</strong></p><h2 id="iptables-命令"><a href="#iptables-命令" class="headerlink" title="iptables 命令"></a>iptables 命令</h2><p>由于Linux版本的不同，使用该服务，可能需要提前使用 <strong>yum | apt</strong> 安装该服务</p><h3 id="添加规则"><a href="#添加规则" class="headerlink" title="添加规则"></a>添加规则</h3><p>将 INPUT 规则链设置为只允许指定网段的主机访问本机的 22 端口，拒绝来自其他所有主机的流量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# iptables -I INPUT -s 192.168.10.0/24 -p tcp --dport 22 -j ACCEPT </span><br><span class="line">[root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 22 -j REJECT </span><br><span class="line">[root@linuxprobe ~]# iptables -L </span><br><span class="line">Chain INPUT (policy ACCEPT) </span><br><span class="line">target prot opt source destination </span><br><span class="line">ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh </span><br><span class="line">REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable </span><br><span class="line">………………省略部分输出信息………………</span><br></pre></td></tr></table></figure><p><code>-I</code>表示 <strong>insert</strong> 一条规则（默认从head插入，也可指定在第几条规则前插入）</p><p><code>-D</code>为删除一条规则（添加规则序号）</p><p><code>-A</code>为附加规则</p><blockquote><p>防火墙策略规则是<strong>按照从上到下的顺序匹配</strong>的，因此一定要把允许动作放到拒绝动作前面，否则所有的流量就将被拒绝掉，从而导致任何主机都无法访问我们的服务。</p></blockquote><h3 id="Iptables-的临时性"><a href="#Iptables-的临时性" class="headerlink" title="Iptables 的临时性"></a>Iptables 的临时性</h3><p>使用 iptables 命令配置的防火墙规则默认会在系统下一次重启时失效，如果想让配置的防火墙策略永久生效，还要执行保存命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# service iptables save </span><br><span class="line">iptables: Saving firewall rules to /etc/sysconfig/iptables: [ OK ]</span><br></pre></td></tr></table></figure><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul><li>iptables 和 firewalld 配置是否会冲突？<ul><li>不会冲突。从本质上讲二者只是配置防火墙的<strong>服务</strong>，并不是真的防火墙。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSH 跳板服务器连接</title>
      <link href="/2023/01/17/linux/ssh-jump/"/>
      <url>/2023/01/17/linux/ssh-jump/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://zhuanlan.zhihu.com/p/74193910" target="_blank" rel="noopener">SSH 通过跳板机直接访问内网机器 - 知乎 (zhihu.com)</a></p></blockquote><h2 id="单层跳转"><a href="#单层跳转" class="headerlink" title="单层跳转"></a>单层跳转</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh &#123;username&#125;@&#123;destination_host_ip&#125; -p &#123;port&#125; -J jump_username@jump_server:port</span><br></pre></td></tr></table></figure><h2 id="多层跳转"><a href="#多层跳转" class="headerlink" title="多层跳转"></a>多层跳转</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh huhaigen@192.168.9.5 -p 22 -J jinzcdev@172.16.35.100:32402,huhaigen@10.12.49.20:6222</span><br></pre></td></tr></table></figure><h2 id="config-配置文件跳转"><a href="#config-配置文件跳转" class="headerlink" title="config 配置文件跳转"></a>config 配置文件跳转</h2><p>通过 <code>ProxyJump</code> 配置指定跳板机</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Host MyProxyJump</span><br><span class="line">HostName ip</span><br><span class="line"><span class="built_in">Port</span>port</span><br><span class="line"><span class="built_in">User </span>user_name</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line">Host ObjectHost</span><br><span class="line">HostName internal_ip</span><br><span class="line"><span class="built_in">User </span>user_name</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">ProxyJump MyProxyJump</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux终端配置 - ohmyzsh</title>
      <link href="/2022/12/01/linux/oh-my-zsh/"/>
      <url>/2022/12/01/linux/oh-my-zsh/</url>
      
        <content type="html"><![CDATA[<h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>将当前目录切换到ohmyzsh的<code>plugins</code>文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.oh-my-zsh/custom/plugins</span><br></pre></td></tr></table></figure><ol><li>语法高亮 <strong>zsh-syntax-highlighting</strong><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git</span><br></pre></td></tr></table></figure></li><li>自动提示 <strong>zsh-autosuggestions</strong><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions</span><br></pre></td></tr></table></figure></li></ol><p>插件安装成功后需要在zsh的配置文件中将其激活，在终端执行以下命令以编辑<code>zsh-shell</code>的资源文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><p>在里面找到并修改<code>ZSH_THEME=&quot;ys&quot;</code>和<code>plugins=(git zsh-syntax-highlighting zsh-autosuggestions)</code></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>如果具有管理员权限，则可以使用<code>apt</code>安装插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh-syntax-highlighting</span><br><span class="line">sudo apt install zsh-autosuggestions</span><br></pre></td></tr></table></figure><p>在<code>~/.zshrc</code>文件末尾添加插件激活命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">. /usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh</span><br><span class="line">. /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br></pre></td></tr></table></figure><h2 id="安装-autojump"><a href="#安装-autojump" class="headerlink" title="安装 autojump"></a>安装 autojump</h2><p><code>autojump</code>用来快读跳转到某个文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install autojump       # yum in CentOS</span><br><span class="line">or</span><br><span class="line">sudo apt install autojump# apt in Ubuntu</span><br></pre></td></tr></table></figure><p>在<code>~/.zshrc</code>文件末尾加上<code>. /usr/share/autojump/autojump.zsh</code>以激活 <strong>autojump</strong></p><h2 id="终端异常"><a href="#终端异常" class="headerlink" title="终端异常"></a>终端异常</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compinit:503: no such file or directory: /usr/local/share/zsh/site-functions/_brew_services</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://stackoverflow.com/questions/65747286/zsh-problem-compinit503-no-such-file-or-directory-usr-local-share-zsh-site" target="_blank" rel="noopener">macos - zsh problem: compinit:503: no such file or directory: /usr/local/share/zsh/site-functions/_brew - Stack Overflow</a></p></blockquote><p>Type <code>brew cleanup</code> in terminal to solve it.</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 的目录结构</title>
      <link href="/2022/11/29/linux/linux-directory-structure/"/>
      <url>/2022/11/29/linux/linux-directory-structure/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-系统中的文件存储结构"><a href="#Linux-系统中的文件存储结构" class="headerlink" title="Linux 系统中的文件存储结构"></a>Linux 系统中的文件存储结构</h2><p><img src="https://s2.loli.net/2022/05/12/5blo8uHQ9YKPrdU.png" alt="Linux 系统中的文件存储结构"></p><hr><h2 id="Linux-系统中常见的目录名称以及相应内容"><a href="#Linux-系统中常见的目录名称以及相应内容" class="headerlink" title="Linux 系统中常见的目录名称以及相应内容"></a>Linux 系统中常见的目录名称以及相应内容</h2><table><thead><tr><th align="left">Linux</th><th align="left">系统中常见的目录名称以及相应内容</th></tr></thead><tbody><tr><td align="left">目录名称</td><td align="left">应放置文件的内容</td></tr><tr><td align="left">/boot</td><td align="left">开机所需文件—内核、开机菜单以及所需配置文件等</td></tr><tr><td align="left">/dev</td><td align="left">以文件形式存放任何设备与接口</td></tr><tr><td align="left">/etc</td><td align="left">配置文件</td></tr><tr><td align="left">/home</td><td align="left">用户家目录</td></tr><tr><td align="left">/bin</td><td align="left">存放单用户模式下还可以操作的命令</td></tr><tr><td align="left">/lib</td><td align="left">开机时用到的函数库，以及/bin 与/sbin 下面的命令要调用的函数</td></tr><tr><td align="left">/sbin</td><td align="left">开机过程中需要的命令</td></tr><tr><td align="left">/media</td><td align="left">用于挂载设备文件的目录</td></tr><tr><td align="left">/opt</td><td align="left">放置第三方的软件</td></tr><tr><td align="left">/root</td><td align="left">系统管理员的家目录</td></tr><tr><td align="left">/srv</td><td align="left">一些网络服务的数据文件目录</td></tr><tr><td align="left">/tmp</td><td align="left">任何人均可使用的“共享”临时目录</td></tr><tr><td align="left">/proc</td><td align="left">虚拟文件系统，例如系统内核、进程、外部设备及网络状态等</td></tr><tr><td align="left">/usr/local</td><td align="left">用户自行安装的软件</td></tr><tr><td align="left">/usr/sbin</td><td align="left">Linux 系统开机时不会使用到的软件/命令/脚本</td></tr><tr><td align="left">/usr/share</td><td align="left">帮助与说明文件，也可放置共享文件</td></tr><tr><td align="left">/var</td><td align="left">主要存放经常变化的文件，如日志</td></tr><tr><td align="left">/lost+found</td><td align="left">当文件系统发生错误时，将一些丢失的文件片段存放在这里</td></tr></tbody></table><p>Linux 系统中的一切文件都是从“根（/）”目录开始的，并按照文件系统层次化标准（FHS）。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>修改 Linux 用户名</title>
      <link href="/2022/11/18/linux/linux-change-username/"/>
      <url>/2022/11/18/linux/linux-change-username/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.cyberciti.biz/faq/howto-change-rename-user-name-id/" target="_blank" rel="noopener">Linux Change or Rename User Name and UID - nixCraft (cyberciti.biz)</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -d $&#123;new_home_dir&#125; -m -l $&#123;new_username&#125; $&#123;old_name&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -d /home/test20 -m -l test20 test10</span><br></pre></td></tr></table></figure><p>具体的使用说明在 <code>usermod</code> 的手册中有详细的描述。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静态ARP</title>
      <link href="/2022/11/13/linux/static-arp/"/>
      <url>/2022/11/13/linux/static-arp/</url>
      
        <content type="html"><![CDATA[<p>MacOS 设置静态ARP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo arp -S &#123;IP_ADDRESS&#125; &#123;MAC_ADDRESS&#125;</span><br></pre></td></tr></table></figure><p>其中MAC地址用 <code>:</code> 分隔。<code>-S</code> 表示如果表内存在记录则删除之前的记录，<code>-s</code> 则不会删除</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 配置</title>
      <link href="/2022/10/28/linux/nginx-config-linux/"/>
      <url>/2022/10/28/linux/nginx-config-linux/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.nginx.com/resources/wiki/start/topics/examples/full/" target="_blank" rel="noopener">Full Example Configuration | NGINX</a></p><p><a href="http://nginx.org/en/docs/beginners_guide.html" target="_blank" rel="noopener">Beginner’s Guide (nginx.org)</a></p><p><a href="https://www.digitalocean.com/community/tutorials/understanding-the-nginx-configuration-file-structure-and-configuration-contexts#the-if-context" target="_blank" rel="noopener">Understanding the Nginx Configuration File Structure and Configuration Contexts | DigitalOcean</a></p></blockquote><h2 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span>       www www;  <span class="comment">## Default: nobody</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">5</span>;  <span class="comment">## Default: 1</span></span><br><span class="line"><span class="attribute">error_log</span>  logs/error.log;</span><br><span class="line"><span class="attribute">pid</span>        logs/nginx.pid;</span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">8192</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">  <span class="attribute">worker_connections</span>  <span class="number">4096</span>;  <span class="comment">## Default: 1024</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  <span class="attribute">include</span>    conf/mime.types;</span><br><span class="line">  <span class="attribute">include</span>    /etc/nginx/proxy.conf;</span><br><span class="line">  <span class="attribute">include</span>    /etc/nginx/fastcgi.conf;</span><br><span class="line">  <span class="attribute">index</span>    index.html index.htm index.php;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line">  <span class="attribute">log_format</span>   main <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>]  <span class="variable">$status</span> '</span></span><br><span class="line">    <span class="string">'"<span class="variable">$request</span>" <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">    <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line">  <span class="attribute">access_log</span>   logs/access.log  main;</span><br><span class="line">  <span class="attribute">sendfile</span>     <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">tcp_nopush</span>   <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">server_names_hash_bucket_size</span> <span class="number">128</span>; <span class="comment"># this seems to be required for some vhosts</span></span><br><span class="line"></span><br><span class="line">  <span class="section">server</span> &#123; <span class="comment"># php/fastcgi</span></span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  domain1.com www.domain1.com;</span><br><span class="line">    <span class="attribute">access_log</span>   logs/domain1.access.log  main;</span><br><span class="line">    <span class="attribute">root</span>         html;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">      <span class="attribute">fastcgi_pass</span>   <span class="number">127.0.0.1:1025</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="section">server</span> &#123; <span class="comment"># simple reverse-proxy</span></span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  domain2.com www.domain2.com;</span><br><span class="line">    <span class="attribute">access_log</span>   logs/domain2.access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># serve static files</span></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ ^/(images|javascript|js|css|flash|media|static)/</span>  &#123;</span><br><span class="line">      <span class="attribute">root</span>    /var/www/virtual/big.server.com/htdocs;</span><br><span class="line">      <span class="attribute">expires</span> <span class="number">30d</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass requests for dynamic content to rails/turbogears/zope, et al</span></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">      <span class="attribute">proxy_pass</span>      http://127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">upstream</span> big_server_com &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.3:8000</span> weight=<span class="number">5</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.3:8001</span> weight=<span class="number">5</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.1:8000</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.1:8001</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="section">server</span> &#123; <span class="comment"># simple load balancing</span></span><br><span class="line">    <span class="attribute">listen</span>          <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>     big.server.com;</span><br><span class="line">    <span class="attribute">access_log</span>      logs/big.server.access.log main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">      <span class="attribute">proxy_pass</span>      http://big_server_com;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="proxy-conf"><a href="#proxy-conf" class="headerlink" title="proxy.conf"></a>proxy.conf</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_redirect</span>          <span class="literal">off</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span>        Host            <span class="variable">$host</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span>        X-Real-IP       <span class="variable">$remote_addr</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span>        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"><span class="attribute">client_max_body_size</span>    <span class="number">10m</span>;</span><br><span class="line"><span class="attribute">client_body_buffer_size</span> <span class="number">128k</span>;</span><br><span class="line"><span class="attribute">proxy_connect_timeout</span>   <span class="number">90</span>;</span><br><span class="line"><span class="attribute">proxy_send_timeout</span>      <span class="number">90</span>;</span><br><span class="line"><span class="attribute">proxy_read_timeout</span>      <span class="number">90</span>;</span><br><span class="line"><span class="attribute">proxy_buffers</span>           <span class="number">32</span> <span class="number">4k</span>;</span><br></pre></td></tr></table></figure><h2 id="fastcgi-conf"><a href="#fastcgi-conf" class="headerlink" title="fastcgi.conf"></a>fastcgi.conf</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME    <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line"><span class="attribute">fastcgi_param</span>  QUERY_STRING       <span class="variable">$query_string</span>;</span><br><span class="line"><span class="attribute">fastcgi_param</span>  REQUEST_METHOD     <span class="variable">$request_method</span>;</span><br><span class="line"><span class="attribute">fastcgi_param</span>  CONTENT_TYPE       <span class="variable">$content_type</span>;</span><br><span class="line"><span class="attribute">fastcgi_param</span>  CONTENT_LENGTH     <span class="variable">$content_length</span>;</span><br><span class="line"><span class="attribute">fastcgi_param</span>  SCRIPT_NAME        <span class="variable">$fastcgi_script_name</span>;</span><br><span class="line"><span class="attribute">fastcgi_param</span>  REQUEST_URI        <span class="variable">$request_uri</span>;</span><br><span class="line"><span class="attribute">fastcgi_param</span>  DOCUMENT_URI       <span class="variable">$document_uri</span>;</span><br><span class="line"><span class="attribute">fastcgi_param</span>  DOCUMENT_ROOT      <span class="variable">$document_root</span>;</span><br><span class="line"><span class="attribute">fastcgi_param</span>  SERVER_PROTOCOL    <span class="variable">$server_protocol</span>;</span><br><span class="line"><span class="attribute">fastcgi_param</span>  GATEWAY_INTERFACE  CGI/<span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line"><span class="attribute">fastcgi_param</span>  SERVER_SOFTWARE    nginx/<span class="variable">$nginx_version</span>;</span><br><span class="line"><span class="attribute">fastcgi_param</span>  REMOTE_ADDR        <span class="variable">$remote_addr</span>;</span><br><span class="line"><span class="attribute">fastcgi_param</span>  REMOTE_PORT        <span class="variable">$remote_port</span>;</span><br><span class="line"><span class="attribute">fastcgi_param</span>  SERVER_ADDR        <span class="variable">$server_addr</span>;</span><br><span class="line"><span class="attribute">fastcgi_param</span>  SERVER_PORT        <span class="variable">$server_port</span>;</span><br><span class="line"><span class="attribute">fastcgi_param</span>  SERVER_NAME        <span class="variable">$server_name</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">fastcgi_index</span>  index.php;</span><br><span class="line"></span><br><span class="line"><span class="attribute">fastcgi_param</span>  REDIRECT_STATUS    <span class="number">200</span>;</span><br></pre></td></tr></table></figure><h2 id="mime-types"><a href="#mime-types" class="headerlink" title="mime.types"></a>mime.types</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">types &#123;</span><br><span class="line">  text/html                             html htm shtml<span class="comment">;</span></span><br><span class="line">  text/css                              css<span class="comment">;</span></span><br><span class="line">  text/xml                              xml rss<span class="comment">;</span></span><br><span class="line">  image/gif                             gif<span class="comment">;</span></span><br><span class="line">  image/jpeg                            jpeg jpg<span class="comment">;</span></span><br><span class="line">  application/x-javascript              js<span class="comment">;</span></span><br><span class="line">  text/plain                            txt<span class="comment">;</span></span><br><span class="line">  text/x-component                      htc<span class="comment">;</span></span><br><span class="line">  text/mathml                           mml<span class="comment">;</span></span><br><span class="line">  image/png                             png<span class="comment">;</span></span><br><span class="line">  image/x-icon                          ico<span class="comment">;</span></span><br><span class="line">  image/x-jng                           jng<span class="comment">;</span></span><br><span class="line">  image/vnd.wap.wbmp                    wbmp<span class="comment">;</span></span><br><span class="line">  application/java-archive              jar war ear<span class="comment">;</span></span><br><span class="line">  application/mac-binhex40              hqx<span class="comment">;</span></span><br><span class="line">  application/pdf                       pdf<span class="comment">;</span></span><br><span class="line">  application/x-cocoa                   cco<span class="comment">;</span></span><br><span class="line">  application/x-java-archive-diff       jardiff<span class="comment">;</span></span><br><span class="line">  application/x-java-jnlp-file          jnlp<span class="comment">;</span></span><br><span class="line">  application/x-makeself                run<span class="comment">;</span></span><br><span class="line">  application/x-perl                    pl pm<span class="comment">;</span></span><br><span class="line">  application/x-pilot                   prc pdb<span class="comment">;</span></span><br><span class="line">  application/x-rar-compressed          rar<span class="comment">;</span></span><br><span class="line">  application/x-redhat-package-manager  rpm<span class="comment">;</span></span><br><span class="line">  application/x-sea                     sea<span class="comment">;</span></span><br><span class="line">  application/x-shockwave-flash         swf<span class="comment">;</span></span><br><span class="line">  application/x-stuffit                 sit<span class="comment">;</span></span><br><span class="line">  application/x-tcl                     tcl tk<span class="comment">;</span></span><br><span class="line">  application/x-x509-ca-cert            der pem crt<span class="comment">;</span></span><br><span class="line">  application/x-xpinstall               xpi<span class="comment">;</span></span><br><span class="line">  application/zip                       zip<span class="comment">;</span></span><br><span class="line">  application/octet-stream              deb<span class="comment">;</span></span><br><span class="line">  application/octet-stream              bin exe dll<span class="comment">;</span></span><br><span class="line">  application/octet-stream              dmg<span class="comment">;</span></span><br><span class="line">  application/octet-stream              eot<span class="comment">;</span></span><br><span class="line">  application/octet-stream              iso img<span class="comment">;</span></span><br><span class="line">  application/octet-stream              msi msp msm<span class="comment">;</span></span><br><span class="line">  audio/mpeg                            mp3<span class="comment">;</span></span><br><span class="line">  audio/x-realaudio                     ra<span class="comment">;</span></span><br><span class="line">  video/mpeg                            mpeg mpg<span class="comment">;</span></span><br><span class="line">  video/quicktime                       mov<span class="comment">;</span></span><br><span class="line">  video/x-flv                           flv<span class="comment">;</span></span><br><span class="line">  video/x-msvideo                       avi<span class="comment">;</span></span><br><span class="line">  video/x-ms-wmv                        wmv<span class="comment">;</span></span><br><span class="line">  video/x-ms-asf                        asx asf<span class="comment">;</span></span><br><span class="line">  video/x-mng                           mng<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在终端预览Markdown</title>
      <link href="/2022/10/27/linux/preview-markdown-in-terminal/"/>
      <url>/2022/10/27/linux/preview-markdown-in-terminal/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/joeyespo/grip" target="_blank" rel="noopener">joeyespo/grip: Preview GitHub README.md files locally before committing them.</a></p><p><a href="https://unix.stackexchange.com/questions/4140/markdown-viewer" target="_blank" rel="noopener">command line - Markdown Viewer - Unix &amp; Linux Stack Exchange</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sudo apt install pandoc lynx -y</span></span><br><span class="line">pandoc &#123;markdown-file&#125; | lynx -stdin</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 启动中的 grub 错误</title>
      <link href="/2022/10/27/linux/ubuntu-boot/"/>
      <url>/2022/10/27/linux/ubuntu-boot/</url>
      
        <content type="html"><![CDATA[<h2 id="error-ubuntu-error-symbol-‘grub-calloc’-not-found"><a href="#error-ubuntu-error-symbol-‘grub-calloc’-not-found" class="headerlink" title="error: ubuntu error symbol ‘grub_calloc’ not found"></a>error: ubuntu error symbol ‘grub_calloc’ not found</h2><p>原因：系统引导文件出错 -&gt; grub无法找到引导文件 -&gt; 无法进入系统</p><h2 id="What-is-GRUB"><a href="#What-is-GRUB" class="headerlink" title="What is GRUB?"></a>What is GRUB?</h2><ul><li>GRUB is acronym for <strong>GR</strong>and <strong>U</strong>nified <strong>B</strong>ootloader.</li></ul><p><a href="https://www.gnu.org/software/grub/" target="_blank" rel="noopener">GRUB</a> is a complete program <strong>for loading and managing the boot process</strong>. It is the most common <strong>bootloader</strong> for Linux distributions. A bootloader is the first software that runs when a computer starts. It loads the <a href="https://itsfoss.com/what-is-linux/" target="_blank" rel="noopener">kernel of the operating system</a> and then the kernel initializes the rest of the operating system: shell, <a href="https://itsfoss.com/display-manager/" target="_blank" rel="noopener">display manager</a>, <a href="https://itsfoss.com/what-is-desktop-environment/" target="_blank" rel="noopener">desktop environment</a>, etc.</p><p>总结：BootLoader负责加载内核。BootManager在于找到了多个引导，如果选择进入的系统。</p><blockquote><p><a href="https://itsfoss.com/what-is-grub/" target="_blank" rel="noopener">What is Grub in Linux? What is it Used for? (itsfoss.com)</a></p></blockquote><h2 id="ubuntu-error-symbol-‘grub-calloc’-not-found"><a href="#ubuntu-error-symbol-‘grub-calloc’-not-found" class="headerlink" title="ubuntu error symbol ‘grub_calloc’ not found"></a>ubuntu error symbol ‘grub_calloc’ not found</h2><ol><li>插入安装linux系统的启动盘，然后不要安装系统，进入ubuntu微系统。</li><li>进入终端；</li><li>在终端输入：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Change the password of `root`.</span></span><br><span class="line">sudo passwd</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Install `boot-repair`</span></span><br><span class="line">sudo add-apt-repository ppa:yannubuntu/boot-repair &amp;&amp; sudo apt-get update</span><br><span class="line">sudo apt-get install -y boot-repair &amp;&amp; boot-repair</span><br></pre></td></tr></table></figure><blockquote><p>[1]: <a href="https://help.ubuntu.com/community/Boot-Repair" target="_blank" rel="noopener">Boot-Repair - Community Help Wiki (ubuntu.com)</a></p><p>[2]: <a href="https://blog.csdn.net/moriarty_jack/article/details/109000762" target="_blank" rel="noopener">linux系统安装 ubuntu error symbol‘grub_calloc’not found_moriarty_jack的博客-CSDN博客</a></p><p>[3]: <a href="https://bugs.launchpad.net/ubuntu/+source/grub2/+bug/1889509" target="_blank" rel="noopener">Bug #1889509 “grub boot error : “symbol ‘grub_calloc’ not found” : Bugs : grub2 package : Ubuntu (launchpad.net)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 网络配置</title>
      <link href="/2022/10/20/linux/ubuntu-network/"/>
      <url>/2022/10/20/linux/ubuntu-network/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[1] <a href="https://netplan.io/" target="_blank" rel="noopener">Netplan</a></p><p>[2] <a href="https://ubuntu.com/core/docs/networkmanager/networkmanager-and-netplan" target="_blank" rel="noopener">NetworkManager and netplan | Ubuntu</a></p><p>[3] <a href="https://linux.cn/article-6629-1.html" target="_blank" rel="noopener">技术|如何在 Linux 上从 NetworkManager 切换为 systemd-network</a></p></blockquote><h2 id="1-Ubuntu-的网络配置策略"><a href="#1-Ubuntu-的网络配置策略" class="headerlink" title="1. Ubuntu 的网络配置策略"></a>1. Ubuntu 的网络配置策略</h2><p>在 Ubuntu 18.0.4 及之后的系统版本中，使用 <a href="https://netplan.io" target="_blank" rel="noopener">https://netplan.io</a> 进行网络配置，系统启动时，会获取到 <code>/etc/netplan/*.yaml</code> 的配置信息决定使用哪个 <code>renderer</code> 作为系统的网络配置服务。</p><img style="width: 40%" src="https://assets.ubuntu.com/v1/a1a80854-netplan_design_overview.svg"><p>可选的 <code>renderer</code> 为：</p><ol><li>systemd-networkd</li><li>NetworkManager</li></ol><p>如流程图所示，系统启动时，<code>/etc/netplan/*.yaml</code> 中的配置文件会被 <code>netplan</code> 读取（即执行 <code>netplan generate</code> 命令），并根据配置文件中指定的 <code>renderer</code> 将 <code>*.yaml</code>中的网络配置信息转译成 <code>systemd-networkd</code> 或者 <code>NetworkManager</code> 对应的配置文件。新装的 Ubuntu 18.04 及以上版本的系统，可发现默认的 netplan 配置信息 <code>/etc/netplan/01-network-manager-all.yaml</code>，其内容为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Let NetworkManager manage all devices on this system</span></span><br><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">renderer:</span> <span class="string">NetworkManager</span></span><br></pre></td></tr></table></figure><p>表示系统默认使用 <code>NetworkManager</code> 作为系统的网络配置服务。</p><blockquote><p>注意：需要在 <code>/{run, etc, lib}/netplan</code> 中配置默认使用的 <code>renderer</code>，否则系统重启后，将没有任一服务托管网络</p></blockquote><h2 id="2-NetworkManager"><a href="#2-NetworkManager" class="headerlink" title="2. NetworkManager"></a>2. NetworkManager</h2><blockquote><p><a href="https://help.ubuntu.com/community/NetworkManager" target="_blank" rel="noopener">NetworkManager - Community Help Wiki (ubuntu.com)</a></p></blockquote><p>若使用 <code>NetworkManager</code> 为默认的网络服务，则系统启动时，netplan 会将配置信息转译成其对应的配置文件存放在 <code>/run/NetworkManager/system-connections</code>中，但由于上述的默认的 <code>/etc/netplan/01-network-manager-all.yaml</code> 中仅仅指定了默认使用的网络服务，因此并不会在 <code>/run/NetworkManager/system-connections</code> 中生成相关配置。</p><p>此时，NetworkManager会在其配置文件目录 <code>/etc/NetworkManager/system-connections</code> 中找到其配置文件。如果该目录下的配置文件为空，则当前主机将处于未配置网络的状态。</p><p>如果在netplan中指定NetworkManager作为网络托管服务，并配置了IP信息，如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">renderer:</span> <span class="string">networkd</span></span><br><span class="line">  <span class="attr">ethernets:</span></span><br><span class="line">    <span class="attr">enp3s0:</span></span><br><span class="line">      <span class="attr">dhcp4:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line"></span><br><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">renderer:</span> <span class="string">networkd</span></span><br><span class="line">  <span class="attr">ethernets:</span></span><br><span class="line">    <span class="attr">enp3s0:</span></span><br><span class="line">      <span class="attr">addresses:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">10.10</span><span class="number">.10</span><span class="number">.2</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">nameservers:</span></span><br><span class="line">        <span class="attr">search:</span> <span class="string">[mydomain,</span> <span class="string">otherdomain]</span></span><br><span class="line">        <span class="attr">addresses:</span> <span class="string">[10.10.10.1,</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="string">]</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">to:</span> <span class="string">default</span></span><br><span class="line">          <span class="attr">via:</span> <span class="number">10.10</span><span class="number">.10</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p>则netplan会将该配置转译后添加至 <code>/run/NetworkManager/system-connections</code> 中，NetworkManager 会识别两个文件夹中的配置文件。可以使用 <code>nmcli connection show</code> 查看。</p><p>使用netplan创建的NetworkManager配置文件，如果在界面化中被修改，则原本在/run中的配置文件会被持久化添加到/etc中，但是由于网络配置还是由netplan控制，重启计算机或者运行 <code>netplan apply</code> 后会创建刚刚在/run中被修改的配置文件，并且 <code>/run/NetworkManager/system-connections</code> 的优先级大于 <code>/etc/NetworkManager/system-connections</code>。</p><blockquote><p>注：在 <code>/etc/NetworkManager/system-connections</code> 下的配置文件其权限只能是 <code>600</code>，否则该配置文件将无法被Network Manager加载。</p></blockquote><h2 id="3-systemd-networkd"><a href="#3-systemd-networkd" class="headerlink" title="3. systemd-networkd"></a>3. systemd-networkd</h2><blockquote><p><a href="https://manpages.ubuntu.com/manpages/focal/man5/systemd.network.5.html" target="_blank" rel="noopener">Ubuntu Manpage: systemd.network - Network configuration</a></p></blockquote><h2 id="4-样例"><a href="#4-样例" class="headerlink" title="4. 样例"></a>4. 样例</h2><blockquote><p><a href="https://ubuntu.com/server/docs/network-configuration" target="_blank" rel="noopener">Network - Configuration | Ubuntu</a></p><p><a href="https://netplan.io/examples" target="_blank" rel="noopener">Netplan</a></p><p><a href="https://vitux.com/how-to-configure-networking-with-netplan-on-ubuntu/" target="_blank" rel="noopener">How to Configure Networking on Ubuntu with Netplan - VITUX</a></p></blockquote><p>Netplan is the Ubuntu network configuration tool in all recent Ubuntu versions. Netplan is based on a YAML-based configuration system that makes the configuration process very simple. It has replaced the old <strong>/etc/network/interfaces</strong> configuration file that we used to use for configuring network interfaces in Ubuntu and other Linux distributions.</p><p><a href="https://wiki.debian.org/NetworkConfiguration#Setting_up_an_Ethernet_Interface" target="_blank" rel="noopener">NetworkConfiguration - Debian Wiki</a></p><p><a href="https://askubuntu.com/questions/981455/netplan-or-etc-network-interfaces" target="_blank" rel="noopener">networking - netplan or /etc/network/interfaces? - Ask Ubuntu</a></p><p><a href="https://vitux.com/how-to-configure-networking-with-netplan-on-ubuntu/" target="_blank" rel="noopener">How to Configure Networking on Ubuntu with Netplan - VITUX</a></p><h2 id="Route-Table"><a href="#Route-Table" class="headerlink" title="Route Table"></a>Route Table</h2><blockquote><p><a href="https://unix.stackexchange.com/questions/123084/what-is-the-interface-scope-global-vs-link-used-for" target="_blank" rel="noopener">linux - What is the interface scope (global vs. link) used for? - Unix &amp; Linux Stack Exchange</a></p><p><a href="https://unix.stackexchange.com/a/123096" target="_blank" rel="noopener">https://unix.stackexchange.com/a/123096</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>fdisk 命令</title>
      <link href="/2022/10/08/linux/fdisk/"/>
      <url>/2022/10/08/linux/fdisk/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.myfreax.com/fdisk-command-in-linux/" target="_blank" rel="noopener">如何创建磁盘分区在Linux | myfreax</a></p><p><a href="https://linuxopsys.com/topics/linux-nfs-mount-entry-in-fstab-with-example" target="_blank" rel="noopener">Linux NFS Mount Entry in fstab (/etc/fstab) with Example (linuxopsys.com)</a></p><p><a href="https://manpages.ubuntu.com/manpages/focal/man5/nfs.5.html" target="_blank" rel="noopener">Ubuntu Manpage: nfs - fstab format and options for the nfs file systems</a></p></blockquote><p>NFS 相关 fstab options配置信息</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;ipadress&#125;:/export /export nfs <span class="built_in">int</span>r,bg <span class="number">0</span> <span class="number">0</span></span><br><span class="line">&#123;ipadress&#125;:/data /data nfs <span class="built_in">int</span>r,bg <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HP Laser P1106 in Ubuntu</title>
      <link href="/2022/10/03/linux/ubuntu-hp-printer-driving/"/>
      <url>/2022/10/03/linux/ubuntu-hp-printer-driving/</url>
      
        <content type="html"><![CDATA[<blockquote><ol><li><a href="https://www.qedev.com/linux/324845.html" target="_blank" rel="noopener">Ubuntu 18.04打印服务器惠普P1106配置_Linux_运维开发网_运维开发技术经验分享 (qedev.com)</a></li><li><a href="https://developers.hp.com/hp-laserjet-professional-p1106-printer" target="_blank" rel="noopener">HP Developers Portal | HP LaserJet Professional p1106 Printer</a></li><li><a href="https://developers.hp.com/hp-linux-imaging-and-printing/install/install/index" target="_blank" rel="noopener">HP Developers Portal | Installer Walkthrough</a></li></ol></blockquote><ol><li>使用<code>apt</code>安装HP（惠普）打印机所需的依赖包（管理工具）：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install hplip</span><br></pre></td></tr></table></figure><ol start="2"><li>再安装HP所需的驱动程序</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hp-setup - Printer/Fax Setup Utility</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Installs  HPLIP  printers  and  faxes  <span class="keyword">in</span> the CUPS spooler. Tries to automatically determine the correct PPD file to use. Allows the</span></span><br><span class="line">hp-setup -i</span><br></pre></td></tr></table></figure><p>PPD (PostScript Printer Description) 打印机的<strong>页面描述</strong>，类似于<strong>表示如何让计算机驱动该打印机</strong></p><blockquote><p><a href="https://en.wikipedia.org/wiki/PostScript_Printer_Description" target="_blank" rel="noopener">PostScript Printer Description - Wikipedia</a></p></blockquote><ol start="3"><li>重启<code>cups</code>服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service cups restart</span><br><span class="line">or</span><br><span class="line">sudo systemctl restart cups</span><br></pre></td></tr></table></figure><ol start="4"><li>进入<code>localhost:631</code>页面，631端口是<code>cups</code>服务的默认端口。选择<code>Administration</code>，勾选“Share printers connected to this system”和“Allow remote administration”。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Conda 配置</title>
      <link href="/2022/09/26/linux/conda-configs/"/>
      <url>/2022/09/26/linux/conda-configs/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://docs.conda.io/projects/conda/en/latest/user-guide/configuration/use-condarc.html" target="_blank" rel="noopener">Using the .condarc conda configuration file — conda dev documentation</a></p></blockquote><h2 id="修改默认-pkgs-dirs"><a href="#修改默认-pkgs-dirs" class="headerlink" title="修改默认 pkgs_dirs"></a>修改默认 pkgs_dirs</h2><p>conda 安装相关的包时，会将包缓存至 pkgs 文件夹中，避免重复的下载。</p><p>在多用户使用时候，由于权限问题，另一个用户创建的缓存文件不允许被修改。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ conda install <span class="comment">--name openmmlab black -y</span></span><br><span class="line">Collecting package metadata (current_repodata.json): failed</span><br><span class="line"></span><br><span class="line">NotWritableError: The <span class="keyword">current</span> <span class="keyword">user</span> does <span class="keyword">not</span> have <span class="keyword">write</span> permissions <span class="keyword">to</span> a required <span class="type">path</span>.</span><br><span class="line">  <span class="type">path</span>: /usr/<span class="keyword">local</span>/anaconda3/pkgs/<span class="keyword">cache</span>/<span class="number">5827</span>f1d9.json</span><br><span class="line">  uid: <span class="number">1001</span></span><br><span class="line">  gid: <span class="number">2001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> you feel that permissions <span class="keyword">on</span> this <span class="type">path</span> are <span class="keyword">set</span> incorrectly, you can manually</span><br><span class="line">change them <span class="keyword">by</span> executing</span><br><span class="line"></span><br><span class="line">  $ sudo chown <span class="number">1001</span>:<span class="number">2001</span> /usr/<span class="keyword">local</span>/anaconda3/pkgs/<span class="keyword">cache</span>/<span class="number">5827</span>f1d9.json</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> general, it<span class="string">'s not advisable to use '</span>sudo conda<span class="string">'.</span></span><br></pre></td></tr></table></figure><p>因此，可以修改 pkgs_dirs 的位置将缓存的 pkgs 保存至当前用户的个人文件夹下。通过 <code>conda config --show</code> 查看默认配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pkgs_dirs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/usr/local/anaconda3/pkgs</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/home/&#123;current_user&#125;/.conda/pkgs</span></span><br></pre></td></tr></table></figure><p>修改全局配置信息 <code>sudo vim /etc/conda/.condarc</code>，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pkgs_dirs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">$HOME/.conda/pkgs</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/usr/local/anaconda3/pkgs</span></span><br></pre></td></tr></table></figure><h2 id="多用户配置-condarc-搜索域"><a href="#多用户配置-condarc-搜索域" class="headerlink" title="多用户配置 .condarc 搜索域"></a>多用户配置 <code>.condarc</code> 搜索域</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> on_win:</span><br><span class="line">    SEARCH_PATH = (</span><br><span class="line">        <span class="string">"C:/ProgramData/conda/.condarc"</span>,</span><br><span class="line">        <span class="string">"C:/ProgramData/conda/condarc"</span>,</span><br><span class="line">        <span class="string">"C:/ProgramData/conda/condarc.d"</span>,</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    SEARCH_PATH = (</span><br><span class="line">        <span class="string">"/etc/conda/.condarc"</span>,</span><br><span class="line">        <span class="string">"/etc/conda/condarc"</span>,</span><br><span class="line">        <span class="string">"/etc/conda/condarc.d/"</span>,</span><br><span class="line">        <span class="string">"/var/lib/conda/.condarc"</span>,</span><br><span class="line">        <span class="string">"/var/lib/conda/condarc"</span>,</span><br><span class="line">        <span class="string">"/var/lib/conda/condarc.d/"</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">SEARCH_PATH += (</span><br><span class="line">    <span class="string">"<span class="variable">$CONDA_ROOT</span>/.condarc"</span>,</span><br><span class="line">    <span class="string">"<span class="variable">$CONDA_ROOT</span>/condarc"</span>,</span><br><span class="line">    <span class="string">"<span class="variable">$CONDA_ROOT</span>/condarc.d/"</span>,</span><br><span class="line">    <span class="string">"<span class="variable">$XDG_CONFIG_HOME</span>/conda/.condarc"</span>,</span><br><span class="line">    <span class="string">"<span class="variable">$XDG_CONFIG_HOME</span>/conda/condarc"</span>,</span><br><span class="line">    <span class="string">"<span class="variable">$XDG_CONFIG_HOME</span>/conda/condarc.d/"</span>,</span><br><span class="line">    <span class="string">"~/.config/conda/.condarc"</span>,</span><br><span class="line">    <span class="string">"~/.config/conda/condarc"</span>,</span><br><span class="line">    <span class="string">"~/.config/conda/condarc.d/"</span>,</span><br><span class="line">    <span class="string">"~/.conda/.condarc"</span>,</span><br><span class="line">    <span class="string">"~/.conda/condarc"</span>,</span><br><span class="line">    <span class="string">"~/.conda/condarc.d/"</span>,</span><br><span class="line">    <span class="string">"~/.condarc"</span>,</span><br><span class="line">    <span class="string">"<span class="variable">$CONDA_PREFIX</span>/.condarc"</span>,</span><br><span class="line">    <span class="string">"<span class="variable">$CONDA_PREFIX</span>/condarc"</span>,</span><br><span class="line">    <span class="string">"<span class="variable">$CONDA_PREFIX</span>/condarc.d/"</span>,</span><br><span class="line">    <span class="string">"<span class="variable">$CONDARC</span>"</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 命令记录</title>
      <link href="/2022/09/17/linux/linux-commands/"/>
      <url>/2022/09/17/linux/linux-commands/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><a id="more"></a><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">groupmod</td><td align="left">修改组名</td></tr><tr><td align="left">adduser, groupadd</td><td align="left">快速添加用户和组，简易于(useradd, addgroup)</td></tr><tr><td align="left">groups</td><td align="left">查看用户所在组</td></tr><tr><td align="left">usermod<br />usermod -a -G 组名 用户</td><td align="left">修改用户组、权限等信息</td></tr><tr><td align="left">/etc/passwd</td><td align="left">存放用户信息，包括用户号、组号、使用的shell</td></tr><tr><td align="left">/etc/group</td><td align="left">存放所有的组，以及组中包含的用户</td></tr><tr><td align="left">chgrp<br />chgrp -R anaconda 目标文件夹</td><td align="left">修改目录或者文件夹的所属组</td></tr><tr><td align="left">find . -type f -print | wc -l</td><td align="left">查看当前文件夹下文件的个数</td></tr><tr><td align="left">pkill -kill -u <code>username</code></td><td align="left">在终端注销用户</td></tr><tr><td align="left">gpasswd -d user4 qa_team</td><td align="left">删除用户的secondgroup</td></tr></tbody></table><h2 id="etc-passwd-Format"><a href="#etc-passwd-Format" class="headerlink" title="/etc/passwd Format"></a><code>/etc/passwd</code> Format</h2><p>如果/etc/passwd文件存放的是用户的信息，由6个分号组成的7个信息，解释如下<br>（1）：用户名。<br>（2）：密码（已经加密）<br>（3）：UID（用户标识）,操作系统自己用的<br>（4）：GID组标识。<br>（5）：用户全名或本地帐号<br>（6）：开始目录<br>（7）：登录使用的Shell，就是对登录命令进行解析的工具。<br>例如：abc : x : 501 : 501 : /home/abc : /bin/bash</p><blockquote><p> <a href="http://yyg.wiki/2018/04/27/Linux-passwd文件格式解析/index.html" target="_blank" rel="noopener">Linux passwd文件格式解析 | 杨雨庚的博客 (yyg.wiki)</a></p></blockquote><h2 id="修改用户名"><a href="#修改用户名" class="headerlink" title="修改用户名"></a>修改用户名</h2><p><a href="https://linuxhint.com/change-my-username-in-linux/" target="_blank" rel="noopener">How Do I Change My Username in Linux? (linuxhint.com)</a></p><h2 id="User-Privilege"><a href="#User-Privilege" class="headerlink" title="User Privilege"></a>User Privilege</h2><p><a href="https://blog.csdn.net/saga1979/article/details/87929605" target="_blank" rel="noopener">sudo的安全策略：阻止/允许用户执行特定命令_知其可为而不为-CSDN博客_sudo安全</a></p><p><a href="https://www.cnblogs.com/freespider/p/10592982.html" target="_blank" rel="noopener">Linux修改用户所在组方法 - FreeSpider - 博客园 (cnblogs.com)</a></p><h2 id="NVIDIA-Docker"><a href="#NVIDIA-Docker" class="headerlink" title="NVIDIA Docker"></a>NVIDIA Docker</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">distribution=$(. /etc/os-release;echo $ID$VERSION_ID) \</span><br><span class="line">   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add - \</span><br><span class="line">   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list</span><br></pre></td></tr></table></figure><h2 id="Linux-故障修复"><a href="#Linux-故障修复" class="headerlink" title="Linux 故障修复"></a>Linux 故障修复</h2><p><a href="https://www.linuxprobe.com/failure-recovery.html" target="_blank" rel="noopener">Linux系统故障修复和修复技巧 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.cnblogs.com/yxf-/p/11441518.html" target="_blank" rel="noopener">Linux单用户模式 - 不言不弃 - 博客园 (cnblogs.com)</a></p><h3 id="File-system"><a href="#File-system" class="headerlink" title="File system"></a>File system</h3><p><a href="https://blog.csdn.net/hfhhgfv/article/details/83895878" target="_blank" rel="noopener">linux命令–使用fsck修复文件系统_hfhhgfv的博客-CSDN博客_fsck</a></p><h2 id="SSH-privilege"><a href="#SSH-privilege" class="headerlink" title="SSH privilege"></a>SSH privilege</h2><p><a href="https://blog.csdn.net/levy_cui/article/details/59524158" target="_blank" rel="noopener">(1条消息) ssh目录权限说明_DT-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 无法打开终端</title>
      <link href="/2022/09/17/linux/ubuntu-terminal-cannot-opened/"/>
      <url>/2022/09/17/linux/ubuntu-terminal-cannot-opened/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.maketecheasier.com/fix-ubuntu-cannot-open-terminal/" target="_blank" rel="noopener">How to Fix Ubuntu Can’t Open the Terminal Issue - Make Tech Easier</a></p></blockquote><p>ubuntu默认桌面为Gnome，打开终端时，使用 <code>/usr/bin/gnome-terminal</code> 打开终端，该程序依赖于 <code>/usr/bin/python</code> 运行，因此可能是由于python的缺失导致的该问题。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XRDP 远程桌面</title>
      <link href="/2022/09/17/linux/remote-desktop-linux/"/>
      <url>/2022/09/17/linux/remote-desktop-linux/</url>
      
        <content type="html"><![CDATA[<blockquote><p> <a href="https://blog.csdn.net/weixin_34104341/article/details/91885833" target="_blank" rel="noopener">xrdp实现windows远程桌面连接问题_weixin_34104341的博客-CSDN博客</a></p></blockquote><h2 id="Install-xrdp-in-ubuntu"><a href="#Install-xrdp-in-ubuntu" class="headerlink" title="Install xrdp in ubuntu"></a>Install <code>xrdp</code> in ubuntu</h2><blockquote><p> <a href="https://linuxize.com/post/how-to-install-xrdp-on-ubuntu-20-04/" target="_blank" rel="noopener">How to Install Xrdp Server (Remote Desktop) on Ubuntu 20.04 | Linuxize</a></p></blockquote><h2 id="ubuntu-使用-xrdp-黑屏-空屏"><a href="#ubuntu-使用-xrdp-黑屏-空屏" class="headerlink" title="ubuntu 使用 xrdp 黑屏/空屏"></a>ubuntu 使用 xrdp 黑屏/空屏</h2><p>尝试安装ubuntu桌面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install ubuntu-desktop</span><br></pre></td></tr></table></figure><p>或者<code>xfce4</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install xubuntu-desktop</span><br></pre></td></tr></table></figure><h1 id="GNome"><a href="#GNome" class="headerlink" title="GNome"></a>GNome</h1><blockquote><p><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/desktop_migration_and_administration_guide/gnome-shell" target="_blank" rel="noopener">1.2. 什么是 GNOME shell？ Red Hat Enterprise Linux 7 | Red Hat Customer Portal</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu - NIS Server</title>
      <link href="/2022/09/11/linux/ubuntu-nis-server/"/>
      <url>/2022/09/11/linux/ubuntu-nis-server/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.server-world.info/en/note?os=Ubuntu_20.04&p=nis&f=1" target="_blank" rel="noopener">Ubuntu 20.04 LTS : Configure NIS Server : Server World (server-world.info)</a></p></blockquote><p>以下为 Ubuntu 20.04 及以下版本的安装方法，在 Ubuntu 22.04 中，NIS服务被拆分。</p><h2 id="0-安装依赖"><a href="#0-安装依赖" class="headerlink" title="0. 安装依赖"></a>0. 安装依赖</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; apt install rpcbind nis -y</span><br></pre></td></tr></table></figure><p>安装 <code>nis</code> 后会提示输入域名。如果要修改域名，则输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg-reconfigure nis</span><br></pre></td></tr></table></figure><p>:star: Note: 在服务器端与客户端都需要安装相关依赖。</p><h2 id="1-配置服务器端"><a href="#1-配置服务器端" class="headerlink" title="1. 配置服务器端"></a>1. 配置服务器端</h2><p>依赖安装成功后，需要修改三个配置文件：</p><ul><li><code>/etc/default/nis</code> ：配置是否为master还是client</li><li><code>/etc/ypserv.securenets</code> ：配置网络号以指定是否对NIS Server有访问权限（该配置信息只需在Server端配置）</li><li><code>/etc/hosts</code> ：绑定IP地址与域名；将NIS域名与本机iP地址绑定</li><li><code>/etc/yp.conf</code> ：设置NIS域名与服务器IP地址</li></ul><p>配置文件修改后，重启相关服务：<code>sudo systemctl restart rpcbind nis</code></p><p>后使用 <code>/usr/lib/yp/ypinit -m</code> 命令初始化数据库。</p><p>示例命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">root@dlp:~# vi /etc/default/nis</span><br><span class="line"><span class="meta">#</span><span class="bash"> line 6: change (<span class="built_in">set</span> NIS primary server)</span></span><br><span class="line">NISSERVER=master</span><br><span class="line">root@dlp:~# vi /etc/ypserv.securenets</span><br><span class="line"><span class="meta">#</span><span class="bash"> This line gives access to everybody. PLEASE ADJUST!</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> comment out</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 0.0.0.0 0.0.0.0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> add to the end: IP range you allow to access</span></span><br><span class="line">255.255.255.0   10.0.0.0</span><br><span class="line"></span><br><span class="line">root@dlp:~# vi /etc/hosts</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line"><span class="meta">#</span><span class="bash"> add own IP address <span class="keyword">for</span> NIS</span></span><br><span class="line">10.0.0.30 dlp.srv.world dlp</span><br><span class="line"></span><br><span class="line">root@dlp:~# systemctl restart rpcbind nis</span><br><span class="line"><span class="meta">#</span><span class="bash"> update NIS database</span></span><br><span class="line">root@dlp:~# /usr/lib/yp/ypinit -m</span><br><span class="line">At this point, we have to construct a list of the hosts which will run NIS</span><br><span class="line">servers.  dlp.srv.world is in the list of NIS server hosts.  Please continue to add</span><br><span class="line">the names for the other hosts, one per line.  When you are done with the</span><br><span class="line">list, type a &lt;control D&gt;.</span><br><span class="line">        next host to add:  dlp.srv.world</span><br><span class="line">        next host to add:  # Ctrl + D key</span><br><span class="line">The current list of NIS servers looks like this:</span><br><span class="line"></span><br><span class="line">dlp.srv.world</span><br><span class="line"></span><br><span class="line">Is this correct?  [y/n: y]  y</span><br><span class="line">We need a few minutes to build the databases...</span><br><span class="line">Building /var/yp/srv.world/ypservers...</span><br><span class="line">Running /var/yp/Makefile...</span><br><span class="line">make[1]: Entering directory '/var/yp/srv.world'</span><br><span class="line">Updating passwd.byname...</span><br><span class="line">Updating passwd.byuid...</span><br><span class="line">Updating group.byname...</span><br><span class="line">Updating group.bygid...</span><br><span class="line">Updating hosts.byname...</span><br><span class="line">Updating hosts.byaddr...</span><br><span class="line">Updating rpc.byname...</span><br><span class="line">Updating rpc.bynumber...</span><br><span class="line">Updating services.byname...</span><br><span class="line">Updating services.byservicename...</span><br><span class="line">Updating netid.byname...</span><br><span class="line">Updating protocols.bynumber...</span><br><span class="line">Updating protocols.byname...</span><br><span class="line">Updating netgroup...</span><br><span class="line">Updating netgroup.byhost...</span><br><span class="line">Updating netgroup.byuser...</span><br><span class="line">Updating shadow.byname... Ignored -&gt; merged with passwd</span><br><span class="line">make[1]: Leaving directory '/var/yp/srv.world'</span><br><span class="line"></span><br><span class="line">dlp.srv.world has been set up as a NIS master server.</span><br><span class="line"></span><br><span class="line">Now you can run ypinit -s dlp.srv.world on all slave server.</span><br></pre></td></tr></table></figure><p>此时的数据库已经初始化成功，如果后续在服务器端创建了新用户，则需要更新数据库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make -C /var/yp/</span><br></pre></td></tr></table></figure><p>该命令也等同于</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /var/yp &amp;&amp; sudo make</span><br></pre></td></tr></table></figure><h2 id="2-配置客户端"><a href="#2-配置客户端" class="headerlink" title="2. 配置客户端"></a>2. 配置客户端</h2><p>安装依赖与服务器端相同，客户端需修改的配置文件如下：</p><ul><li><code>/etc/yp.conf</code> ：ypbind 的配置文件，理解为 Client 要连接的 NIS Server，只有客户端需要配置该文件</li><li><code>/etc/nsswitch.conf</code> ：指明NIS要共享的配置文件，如 <code>passwd, group, hosts, etc.</code></li><li><code>/etc/pam.d/common-session</code> ：Linux-PAM 用来配置系统的认证任务，如 su；该配置文件用以配置pam-session开始和结束时的执行任务</li></ul><p>在common-session中添加如下配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session optional        pam_mkhomedir.so <span class="attribute">skel</span>=/etc/skel <span class="attribute">umask</span>=077</span><br></pre></td></tr></table></figure><p>表示在登录时，若用户home目录为空则自动创建，<code>umask</code> 表示所创建的文件的访问权限（用反码表示），<code>077</code> 实际的读写权限为 <code>700</code>，即仅所属用户可 <code>rwx</code>。</p><p>示例命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">root@node01:~# vi /etc/yp.conf</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yp.conf       Configuration file <span class="keyword">for</span> the ypbind process. You can define</span></span><br><span class="line"><span class="meta">#</span><span class="bash">               NIS servers manually here <span class="keyword">if</span> they can<span class="string">'t be found by</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">               broadcasting on the <span class="built_in">local</span> net (<span class="built_in">which</span> is the default).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">               See the manual page of ypbind <span class="keyword">for</span> the syntax of this file.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> IMPORTANT:    For the <span class="string">"ypserver"</span>, use IP addresses, or make sure that</span></span><br><span class="line"><span class="meta">#</span><span class="bash">               the host is <span class="keyword">in</span> /etc/hosts. This file is only interpreted</span></span><br><span class="line"><span class="meta">#</span><span class="bash">               once, and <span class="keyword">if</span> DNS isn<span class="string">'t reachable yet the ypserver cannot</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">               be resolved and ypbind won<span class="string">'t ever bind to the server.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ypserver ypserver.network.com</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> add to the end: [domain name] [server] [NIS server<span class="string">'s hostname]</span></span></span><br><span class="line">domain srv.world server dlp.srv.world</span><br><span class="line">root@node01:~# vi /etc/nsswitch.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> line 7: add like follows</span></span><br><span class="line">passwd:         files systemd nis</span><br><span class="line">group:          files systemd nis</span><br><span class="line">shadow:         files nis</span><br><span class="line">gshadow:        files</span><br><span class="line"></span><br><span class="line">hosts:          files dns nis</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> follows <span class="keyword">if</span> needed (create home directory automatically <span class="keyword">if</span> none)</span></span><br><span class="line">root@node01:~# vi /etc/pam.d/common-session</span><br><span class="line"><span class="meta">#</span><span class="bash"> add to the end</span></span><br><span class="line">session optional        pam_mkhomedir.so skel=/etc/skel umask=077</span><br><span class="line"></span><br><span class="line">root@node01:~# systemctl restart rpcbind nis</span><br><span class="line">root@node01:~# exit</span><br><span class="line">node01 login: focal     # NIS user</span><br><span class="line">Password:</span><br><span class="line">Welcome to Ubuntu 20.04.1 LTS (GNU/Linux 5.4.0-42-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">  System information as of Wed 16 Sep 2020 04:22:09 PM JST</span><br><span class="line"></span><br><span class="line">  System load:  0.28               Processes:               134</span><br><span class="line">  Usage of /:   12.4% of 24.54GB   Users logged in:         0</span><br><span class="line">  Memory usage: 5%                 IPv4 address for enp1s0: 10.0.0.51</span><br><span class="line">  Swap usage:   0%</span><br><span class="line"></span><br><span class="line"> * "If you've been waiting for the perfect Kubernetes dev solution for</span><br><span class="line">   macOS, the wait is over. Learn how to install Microk8s on macOS."</span><br><span class="line"></span><br><span class="line">   https://www.techrepublic.com/article/how-to-install-microk8s-on-macos/</span><br><span class="line"></span><br><span class="line">11 updates can be installed immediately.</span><br><span class="line">8 of these updates are security updates.</span><br><span class="line">To see these additional updates run: apt list --upgradable</span><br><span class="line"></span><br><span class="line">The programs included with the Ubuntu system are free software;</span><br><span class="line">the exact distribution terms for each program are described in the</span><br><span class="line">individual files in /usr/share/doc/*/copyright.</span><br><span class="line"></span><br><span class="line">Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by</span><br><span class="line">applicable law.</span><br><span class="line"></span><br><span class="line">The programs included with the Ubuntu system are free software;</span><br><span class="line">the exact distribution terms for each program are described in the</span><br><span class="line">individual files in /usr/share/doc/*/copyright.</span><br><span class="line"></span><br><span class="line">Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by</span><br><span class="line">applicable law.</span><br><span class="line"></span><br><span class="line">Creating directory '/home/focal'.</span><br><span class="line">focal@node01:~$     # just logined</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> changing NIS password is like follows</span></span><br><span class="line">focal@node01:~$ yppasswd</span><br><span class="line">hanging NIS account information for focal on dlp.srv.world.</span><br><span class="line">Please enter old password:</span><br><span class="line">Changing NIS password for focal on dlp.srv.world.</span><br><span class="line">Please enter new password:</span><br><span class="line">Please retype new password:</span><br><span class="line"></span><br><span class="line">The NIS password has been changed on dlp.srv.world.</span><br><span class="line"></span><br><span class="line">focal@node01:~$</span><br></pre></td></tr></table></figure><h2 id="3-更新数据库数据"><a href="#3-更新数据库数据" class="headerlink" title="3. 更新数据库数据"></a>3. 更新数据库数据</h2><p>可以使用 <code>yppasswd</code> 命令快速修改当前账户的密码（会在所有NIS Client上立即生效，否则需要重新make），密码至少要6位。如果要设置小于6位长度的密码，则需要使用 <code>root</code> 权限来修改密码。</p><hr><h1 id="Ubuntu-22-04-中的安装方法"><a href="#Ubuntu-22-04-中的安装方法" class="headerlink" title="Ubuntu 22.04 中的安装方法"></a>Ubuntu 22.04 中的安装方法</h1><p>Ubuntu 22.04 中安装 NIS 服务器后，并不自动创建服务，NIS服务由 <code>ypbind</code> 管理。其他配置项与上相同。</p><h1 id="可能的异常"><a href="#可能的异常" class="headerlink" title="可能的异常"></a>可能的异常</h1><p>若 <code>nis</code> 或 <code>ypbind</code> 服务启动，可能是由于客户端无法找到主节点，原因是 <code>/etc/yp.conf</code> 中使用域名表示master，但在hosts中未添加。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MacBook 重启 Touchbar</title>
      <link href="/2022/09/02/linux/macos-touchbar-restart/"/>
      <url>/2022/09/02/linux/macos-touchbar-restart/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://medium.com/zenchef-tech-and-product/how-to-kill-and-restart-the-touch-bar-control-strip-on-the-new-macbook-pro-b77e97c11d03" target="_blank" rel="noopener">How to kill and restart the Touch Bar / Control Strip on the new MacBook Pro ? | by Julien Balmont | Zenchef’s Tech and Product Blog | Medium</a></p></blockquote><p>MacBook 的 TouchBar 有时存在无法完全显示的情况，可以根据其进程名重启相关服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pkill "Touch Bar agent";</span><br><span class="line">sudo killall "ControlStrip";</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu系统安装 - 通知Kernel分区修改时出现错误</title>
      <link href="/2022/08/22/linux/ubuntu-system-installation/"/>
      <url>/2022/08/22/linux/ubuntu-system-installation/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://bugs.launchpad.net/ubuntu/+source/ubiquity/+bug/525033" target="_blank" rel="noopener">Bug #525033 “During installation “Error informing the kernel abo…” : Bugs : ubiquity package : Ubuntu (launchpad.net)</a></p></blockquote><p>安装 Ubuntu 22.04 操作系统，自定义划分分区后出现的上述问题。</p><p>使用 UEFI 方式启动系统，BIOS设置的系统启动方式为 Windows UEFI，应把启动方式更改为其他操作系统。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Proxy 代理服务</title>
      <link href="/2022/08/21/linux/linux-proxy/"/>
      <url>/2022/08/21/linux/linux-proxy/</url>
      
        <content type="html"><![CDATA[<h2 id="开启代理"><a href="#开启代理" class="headerlink" title="开启代理"></a>开启代理</h2><h3 id="ssh-开启-socks-代理"><a href="#ssh-开启-socks-代理" class="headerlink" title="ssh 开启 socks 代理"></a>ssh 开启 socks 代理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ssh -N -D 127.0.0.1:65500 node1 &amp;&gt;&gt; /dev/null &amp;</span><br></pre></td></tr></table></figure><h3 id="GoProxy-代理工具"><a href="#GoProxy-代理工具" class="headerlink" title="GoProxy 代理工具"></a>GoProxy 代理工具</h3><blockquote><p><a href="https://github.com/snail007/goproxy" target="_blank" rel="noopener">GitHub - snail007/goproxy</a><br><a href="https://snail007.host900.com/goproxy/manual/zh/#/" target="_blank" rel="noopener">GOPROXY anual</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://mirrors.host900.com/https://raw.githubusercontent.com/snail007/goproxy/master/install_auto.sh | bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> start proxy <span class="keyword">in</span> background</span></span><br><span class="line">proxy http -t tcp -p "0.0.0.0:65500" --forever --log proxy.log --daemon</span><br></pre></td></tr></table></figure><h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://your_ip_proxy:port/</span><br><span class="line">export https_proxy=$http_proxy</span><br><span class="line">export ftp_proxy=$http_proxy</span><br><span class="line">export dns_proxy=$http_proxy</span><br><span class="line">export rsync_proxy=$http_proxy</span><br><span class="line">export no_proxy="localhost,127.0.0.1,localaddress,.localdomain.com"</span><br><span class="line">export ALL_PROXY="socks5h://localhost:port"</span><br></pre></td></tr></table></figure><h3 id="wget-代理"><a href="#wget-代理" class="headerlink" title="wget 代理"></a>wget 代理</h3><blockquote><p><a href="https://stackoverflow.com/questions/11211705/how-to-set-proxy-for-wget" target="_blank" rel="noopener">How to set proxy for wget?</a></p></blockquote><p>设置 <code>wget</code> 的配置文件</p><blockquote><p>For all users of the system via the /etc/wgetrc or for the user only with the ~/.wgetrc file:</p><p>use_proxy=on<br>http_proxy=127.0.0.1:8080<br>https_proxy=127.0.0.1:8080<br>or via -e options placed after the URL:</p><p>wget … -e use_proxy=on -e http_proxy=127.0.0.1:8080 …</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配置 Network File System (NFS)</title>
      <link href="/2022/07/29/linux/ubuntu-nfs/"/>
      <url>/2022/07/29/linux/ubuntu-nfs/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://ubuntu.com/server/docs/service-nfs" target="_blank" rel="noopener">Service - NFS | Ubuntu</a></p></blockquote><h2 id="Server-服务器端"><a href="#Server-服务器端" class="headerlink" title="Server 服务器端"></a>Server 服务器端</h2><p>At a terminal prompt enter the following command to install the NFS Server:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nfs-kernel-server</span><br></pre></td></tr></table></figure><p>To start the NFS server, you can run the following command at a terminal prompt:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start nfs-kernel-server.service</span><br></pre></td></tr></table></figure><p>编辑 <code>/etc/exports</code>，使用 <code>sudo exportfs -a</code> 命令使立即生效</p><h2 id="Client-客户端"><a href="#Client-客户端" class="headerlink" title="Client 客户端"></a>Client 客户端</h2><p>使用以下命令启用，安装 <code>nfs-common</code> 启用客户端NFS</p><p>To enable NFS support on a client system, enter the following command at the terminal prompt:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nfs-common</span><br></pre></td></tr></table></figure><p>Use the mount command to mount a shared NFS directory from another machine, by typing a command line similar to the following at a terminal prompt:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /opt/example</span><br><span class="line">sudo mount example.hostname.com:/srv /opt/example</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Systemd vs Init</title>
      <link href="/2022/07/27/linux/systemd-vs-init/"/>
      <url>/2022/07/27/linux/systemd-vs-init/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://askubuntu.com/questions/911525/difference-between-systemctl-init-d-and-service" target="_blank" rel="noopener">16.04 - Difference between systemctl init.d and service - Ask Ubuntu</a></p><p><a href="https://www.tecmint.com/systemd-replaces-init-in-linux/" target="_blank" rel="noopener">The Story Behind ‘init’ and ‘systemd’: Why ‘init’ Needed to be Replaced with ‘systemd’ in Linux (tecmint.com)</a></p><p><a href="https://www.geeksforgeeks.org/systemd-vs-init-cheatsheet-for-linux/" target="_blank" rel="noopener">Systemd vs Init Cheatsheet for Linux - GeeksforGeeks</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 错误码</title>
      <link href="/2022/07/22/linux/http-errors/"/>
      <url>/2022/07/22/linux/http-errors/</url>
      
        <content type="html"><![CDATA[<h2 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h2><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/403" target="_blank" rel="noopener">403 Forbidden - HTTP | MDN (mozilla.org)</a></p></blockquote><p>The HTTP <strong><code>403 Forbidden</code></strong> response status code indicates that <strong>the server understands the request but refuses to authorize it.</strong></p><p>This status is similar to <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401" target="_blank" rel="noopener"><code>401</code></a>, but for the <strong><code>403 Forbidden</code></strong> status code reauthenticating makes no difference. The access is permanently forbidden and tied to the application logic, such as insufficient rights to a resource.</p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><h3 id="因为用户权限问题导致的403状态码"><a href="#因为用户权限问题导致的403状态码" class="headerlink" title="因为用户权限问题导致的403状态码"></a>因为用户权限问题导致的403状态码</h3><blockquote><p> <a href="https://blog.csdn.net/qq_35843543/article/details/81561240/" target="_blank" rel="noopener">Nginx出现403 forbidden_枫小秋 的博客-CSDN博客_403 forbidden nginx</a></p></blockquote><p><strong>通过user属性设定，Nginx是为哪个用户启动的</strong></p><p>如果设定启动的用户对Nginx服务对应的页面文件夹<strong>没有访问权限</strong>就会出现403的拒绝服务。</p><p>比如为Nginx服务新建www账户，但是user设定为foo则会出现上面这种错误</p><ol><li>应该将启动用户改成www，或者让foo具有www用户文件夹的访问权限，或者</li><li>将用户改成root，那么对任何文件夹都有读取权限。但是这种操作不便于专门维护www服务的人员管理。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Issue in Docker</title>
      <link href="/2022/07/18/linux/docker-issues/"/>
      <url>/2022/07/18/linux/docker-issues/</url>
      
        <content type="html"><![CDATA[<p><code>OCI runtime exec failed: exec failed: container_linux.go:380: starting container process caused: exec: &quot;bash&quot;: executable file not found in $PATH: unknown</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop</title>
      <link href="/2022/07/03/linux/hadoop-spark-tutorial/"/>
      <url>/2022/07/03/linux/hadoop-spark-tutorial/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[1] <a href="https://github.com/heibaiying/BigData-Notes/blob/master/notes/installation/Hadoop集群环境搭建.md" target="_blank" rel="noopener">BigData-Notes/Hadoop集群环境搭建.md at master · heibaiying/BigData-Notes (github.com)</a></p><p>[2] <a href="https://www.jianshu.com/p/f83229af1898" target="_blank" rel="noopener">Hadoop集群配置 - 简书 (jianshu.com)</a></p></blockquote><p>安装方法参考官网 <a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html#Required_Software" target="_blank" rel="noopener">Apache Hadoop 3.3.3 – Hadoop: Setting up a Single Node Cluster.</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote><p><a href="http://c.biancheng.net/view/6502.html" target="_blank" rel="noopener">HDFS简明入门教程 (biancheng.net)</a></p></blockquote><p>操作步骤如下：</p><ol><li>客户端发起文件读取的请求。</li><li>NameNode 将文件对应的数据块信息及每个块的位置信息，包括每个块的所有副本的位置信息（即每个副本所在的 DataNode 的地址信息）都传送给客户端。</li><li>客户端收到数据块信息后，直接和数据块所在的 DataNode 通信，并行地读取数据块。</li></ol><p>在客户端获得 NameNode 关于每个数据块的信息后，客户端会根据网络拓扑选择与它最近的 DataNode 来读取每个数据块。当与 DataNode 通信失败时，它会选取另一个较近的 DataNode，同时会对出故障的 DataNode 做标记，避免与它重复通信，并发送 NameNode 故障节点的信息。</p><h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><p>设置环境变量：</p><ol><li><code>JAVA_HOME={path_to_jdk_dir}</code></li><li><code>HADOOP_HOME={path_to_hadoop_home}</code></li></ol><p>多台设备间能免密<code>ssh</code>：</p><ol><li>修改每台服务器的<strong>hostname</strong></li><li>:star:在<code>\etc\hosts</code>中绑定集群中每个设备的IP地址与域名（使用真实IP表示本机而不用localhost）</li><li>在<code>~/.ssh</code>生成公密钥，用<code>ssh-copy-id</code>命令将公钥添加到其他设备</li><li>使用<code>ssh {hostname}</code>命令验证是否能免密登录其他主机</li></ol><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>修改<code>hadoop\etc</code>中的配置文件，如下。</p><h3 id="1-core-site-xml"><a href="#1-core-site-xml" class="headerlink" title="1. core-site.xml"></a>1. core-site.xml</h3><blockquote><p>The <code>fs.defaultFS</code> makes HDFS a file abstraction over a cluster, so that its root is not the same as the local system’s.</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过该参数配置集群的文件抽象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop-master:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>io.file.buffer.size<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>131072<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-hdfs-site-xml"><a href="#2-hdfs-site-xml" class="headerlink" title="2. hdfs-site.xml"></a>2. hdfs-site.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 节点数据（即元数据）的存放位置，可以指定多个目录实现容错，多个目录用逗号分隔 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/namenode/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 节点数据（即数据块）的存放位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/datanode/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-hadoop-env-sh"><a href="#3-hadoop-env-sh" class="headerlink" title="3. hadoop-env.sh"></a>3. hadoop-env.sh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/jdk</span><br><span class="line">export HADOOP_HOME=/opt/hadoop</span><br><span class="line">export PDSH_RCMD_TYPE=ssh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> HDFS_NAMENODE_USER=hadoop</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> HDFS_DATANODE_USER=hadoop</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> HDFS_SECONDARYNAMENODE_USER=hadoop</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> YARN_RESOURCEMANAGER_USER=hadoop</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> YARN_NODEMANAGER_USER=hadoop</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-yarn-site-xml-可选，如果不使用分布式计算"><a href="#4-yarn-site-xml-可选，如果不使用分布式计算" class="headerlink" title="4. yarn-site.xml (可选，如果不使用分布式计算)"></a>4. yarn-site.xml (可选，如果不使用分布式计算)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop-master<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-mapred-site-xml-可选，如果不使用MapReduce"><a href="#5-mapred-site-xml-可选，如果不使用MapReduce" class="headerlink" title="5. mapred-site.xml (可选，如果不使用MapReduce)"></a>5. mapred-site.xml (可选，如果不使用MapReduce)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定 mapreduce 作业运行在 yarn 上--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.app.mapreduce.am.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.map.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.reduce.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-wokers"><a href="#6-wokers" class="headerlink" title="6. wokers"></a>6. wokers</h3><p>在目录的<code>wokers</code>中添加所有的datanode节点的主机名</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hadoop-<span class="literal">master</span></span><br><span class="line">hadoop-slave1</span><br><span class="line">hadoop-slave2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>修改配置文件后，在namenode节点（即master）使用<code>hdfs namenode -format</code>格式化namenode的文件系统（不需要在slave节点上执行该命令）</p><p>执行<code>sbin/start-all.sh</code>命令开启服务。</p><p>由于是集群，因此任务的执行会在所有的设备上触发。</p><blockquote><p>Typically one machine in the cluster is designated as the <strong>NameNode</strong> and another machine as the <strong>ResourceManager</strong>, <strong>exclusively</strong>. <strong>These are the masters.</strong> Other services (such as Web App Proxy Server and MapReduce Job History server) are usually run either on dedicated hardware or on shared infrastructure, depending upon the load.</p><p>The rest of the machines in the cluster act as both <strong>DataNode</strong> and <strong>NodeManager</strong>. <strong>These are the workers.</strong></p></blockquote><blockquote><p>[hadoop slaves_猎人在吃肉的博客-CSDN博客](<a href="https://blog.csdn.net/xiaojin21cen/article/details/42421781" target="_blank" rel="noopener">https://blog.csdn.net/xiaojin21cen/article/details/42421781</a></p></blockquote><p><strong>slaves 文件 (在新版中是worker文件)</strong></p><p>一般在集群中你唯一地选择一台机器作为 NameNode ，一台机器作为 ResourceManager，这是master  (主)。</p><p>那么，集群中剩下的机器作为DataNode 和 NodeManager。这些是slaves(从)。</p><p>在你的<a href="https://so.csdn.net/so/search?q=hadoop&spm=1001.2101.3001.7020" target="_blank" rel="noopener">hadoop</a>目录/etc/hadoop/slaves文件上列出全部slave机器名或IP地址，一个一行。</p><h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><blockquote><p><a href="https://spark.apache.org/docs/latest/rdd-programming-guide.html#linking-with-spark" target="_blank" rel="noopener">RDD Programming Guide - Spark 3.2.1 Documentation (apache.org)</a></p></blockquote><p>To run Spark applications in Python without pip installing PySpark, use the <code>bin/spark-submit</code> script located in the Spark directory. This script will load Spark’s Java/Scala libraries and allow you to submit applications to a <code>cluster</code>. You can also use <code>bin/pyspark</code> to launch an interactive Python shell.</p><p>使用spark-submit提交应用到集群，连接集群需要初始化</p><h3 id="集群连接方法"><a href="#集群连接方法" class="headerlink" title="集群连接方法"></a>集群连接方法</h3><blockquote><ol><li><a href="https://spark.apache.org/docs/latest/rdd-programming-guide.html#initializing-spark" target="_blank" rel="noopener">initializing-spark</a></li><li><a href="https://spark.apache.org/docs/latest/submitting-applications.html#launching-applications-with-spark-submit" target="_blank" rel="noopener">spark-submit</a></li></ol></blockquote><p>The first thing a Spark program must do is to create a <a href="https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.SparkContext.html#pyspark.SparkContext" target="_blank" rel="noopener">SparkContext</a> object, which tells Spark how to access a cluster. To create a <code>SparkContext</code> you first need to build a <a href="https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.SparkConf.html#pyspark.SparkConf" target="_blank" rel="noopener">SparkConf</a> object that contains information about your application.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conf = <span class="constructor">SparkConf()</span>.set<span class="constructor">AppName(<span class="params">appName</span>)</span>.set<span class="constructor">Master(<span class="params">master</span>)</span></span><br><span class="line">sc = <span class="constructor">SparkContext(<span class="params">conf</span>=<span class="params">conf</span>)</span></span><br></pre></td></tr></table></figure><p>The <code>appName</code> parameter is a name for your application to show on the cluster UI. <code>master</code> is a <a href="https://spark.apache.org/docs/latest/submitting-applications.html#master-urls" target="_blank" rel="noopener">Spark, Mesos or YARN cluster URL</a>, or a special “local” string to run in local mode. In practice, when running on a cluster, you will not want to hardcode <code>master</code> in the program, but rather <a href="https://spark.apache.org/docs/latest/submitting-applications.html" target="_blank" rel="noopener">launch the application with <code>spark-submit</code></a> and receive it there. However, for local testing and unit tests, you can pass “local” to run Spark in-process.</p><p>连接集群需要创建SparkContext对象，描述集群的连接方法，使用配置文件传入应用名与master（可理解集群的类型）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-submit \</span><br><span class="line">  --class &lt;main-class&gt; \</span><br><span class="line">  --master &lt;master-url&gt; \</span><br><span class="line">  --deploy-mode &lt;deploy-mode&gt; \</span><br><span class="line">  --conf &lt;key&gt;=&lt;value&gt; \</span><br><span class="line">  ... # other options</span><br><span class="line">  &lt;application-jar&gt; \</span><br><span class="line">  [application-arguments]</span><br></pre></td></tr></table></figure><blockquote><p>Unlike other cluster managers supported by Spark in which the master’s address is specified in the <code>--master</code> parameter, in YARN mode the ResourceManager’s address is picked up from the Hadoop configuration. Thus, the <code>--master</code> parameter is <code>yarn</code>.</p></blockquote><p>此处的master如果使用Hadoop Yarn可以传入<code>yarn</code>，而不是<code>spark://...</code>，具体的脚本参数可查看官网。</p><p>PySpark applications start with initializing <code>SparkSession</code> which is the entry point of PySpark as below. In case of running it in PySpark shell via pyspark executable, the shell automatically creates the session in the variable spark for users.</p><p>通过SparkSession开启Spark应用，交互式的<code>bin/pyspark</code>中已经创建了session。</p><h3 id="在集群上运行（Cluster-Manager-Types）"><a href="#在集群上运行（Cluster-Manager-Types）" class="headerlink" title="在集群上运行（Cluster Manager Types）"></a>在集群上运行（Cluster Manager Types）</h3><blockquote><p><a href="https://spark.apache.org/docs/latest/running-on-yarn.html" target="_blank" rel="noopener">Running Spark on YARN - Spark 3.2.1 Documentation (apache.org)</a></p></blockquote><p>The system currently supports several cluster managers:</p><ul><li><a href="https://spark.apache.org/docs/latest/spark-standalone.html" target="_blank" rel="noopener">Standalone</a> – a simple cluster manager included with Spark that makes it easy to set up a cluster.</li><li><a href="https://spark.apache.org/docs/latest/running-on-mesos.html" target="_blank" rel="noopener">Apache Mesos</a> – a general cluster manager that can also run Hadoop MapReduce and service applications. (Deprecated)</li><li><a href="https://spark.apache.org/docs/latest/running-on-yarn.html" target="_blank" rel="noopener">Hadoop YARN</a> – the resource manager in Hadoop 2.</li><li><a href="https://spark.apache.org/docs/latest/running-on-kubernetes.html" target="_blank" rel="noopener">Kubernetes</a> – an open-source system for automating deployment, scaling, and management of containerized applications.</li></ul><p>Spark支持四种集群模式。除了本地测试，此处选择在Hadoop Yarn上运行Spark</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %%</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_noisy</span><span class="params">(cx, cy, N=<span class="number">50</span>, std=<span class="number">1</span>)</span>:</span></span><br><span class="line">    noise_x = std * np.random.randn(N)</span><br><span class="line">    noise_y = std * np.random.randn(N)</span><br><span class="line"></span><br><span class="line">    X = np.array([cx + noise <span class="keyword">for</span> noise <span class="keyword">in</span> noise_x])</span><br><span class="line">    Y = np.array([cy + noise <span class="keyword">for</span> noise <span class="keyword">in</span> noise_y])</span><br><span class="line">    <span class="keyword">return</span> X, Y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_dataset</span><span class="params">(centers)</span>:</span></span><br><span class="line">    X = np.zeros([<span class="number">0</span>])</span><br><span class="line">    Y = np.zeros([<span class="number">0</span>])</span><br><span class="line">    labels = np.zeros([<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, center <span class="keyword">in</span> enumerate(centers):</span><br><span class="line">        X_i, Y_i = generate_noisy(*center)</span><br><span class="line">        labels_i = i * np.ones_like(X_i)</span><br><span class="line"></span><br><span class="line">        X = np.concatenate([X, X_i])</span><br><span class="line">        Y = np.concatenate([Y, Y_i])</span><br><span class="line">        labels = np.concatenate([labels, labels_i])</span><br><span class="line">    <span class="keyword">return</span> X.tolist(), Y.tolist(), labels.astype(np.int16).tolist()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eu_distance</span><span class="params">(p1, p2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sqrt(np.sum(np.square(p1 - p2)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">KMeans</span><span class="params">(data, k=<span class="number">2</span>, seed=<span class="number">1</span>, num_iter=<span class="number">3</span>)</span>:</span></span><br><span class="line">    <span class="string">r"""</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        `data`: 2D points in format (x, y)</span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">        `centers`: [(cx1, cy1), (cx2, cy2), ... ]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    random.seed(seed)</span><br><span class="line">    centers = random.sample(data, k)</span><br><span class="line">    data = np.array(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_iter):</span><br><span class="line">        clusters = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(k)]</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">            dist = [eu_distance(item, np.array(c)) <span class="keyword">for</span> c <span class="keyword">in</span> centers]</span><br><span class="line">            clusters[dist.index(min(dist))].append(item)</span><br><span class="line">        centers = [np.array(c).mean(axis=<span class="number">0</span>).tolist() <span class="keyword">for</span> c <span class="keyword">in</span> clusters]</span><br><span class="line">    points = []</span><br><span class="line">    <span class="keyword">for</span> label, cluster <span class="keyword">in</span> enumerate(clusters):</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> cluster:</span><br><span class="line">            points.append((x, y, label))</span><br><span class="line">    <span class="keyword">return</span> centers, points</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_clustering</span><span class="params">(x, y, labels, centers)</span>:</span></span><br><span class="line"></span><br><span class="line">    colors = [[<span class="string">'#FF0000'</span>, <span class="string">'#00FF00'</span>, <span class="string">'#0000FF'</span>][i] <span class="keyword">for</span> i <span class="keyword">in</span> labels]</span><br><span class="line">    colors_center = [<span class="string">'#000000'</span>, <span class="string">'#66ffff'</span>]</span><br><span class="line"></span><br><span class="line">    f, ax = plt.subplots()</span><br><span class="line">    ax.scatter(x, y, color=colors)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, center <span class="keyword">in</span> enumerate(centers):</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> center:</span><br><span class="line">            ax.scatter(x, y, color=colors_center[i])</span><br><span class="line"></span><br><span class="line">    ax.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line">    f.suptitle(<span class="string">'K-Means'</span>)</span><br><span class="line"></span><br><span class="line">    plt.savefig(<span class="string">'./result.jpg'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># %%</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    spark = SparkSession.builder.appName(<span class="string">"k-means"</span>).getOrCreate()</span><br><span class="line"></span><br><span class="line">    file_path = <span class="string">"hdfs://hadoop-master:8020/user/hadoop/data.csv"</span></span><br><span class="line"></span><br><span class="line">    centers = [(random.randint(<span class="number">1</span>, <span class="number">8</span>), random.randint(<span class="number">1</span>, <span class="number">8</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">    data = generate_dataset(centers)</span><br><span class="line">    spark.createDataFrame(</span><br><span class="line">        list(zip(*data))).write.mode(<span class="string">'overwrite'</span>).csv(file_path)</span><br><span class="line"></span><br><span class="line">    df = spark.read.csv(file_path, inferSchema=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    points = [(row[<span class="number">0</span>], row[<span class="number">1</span>]) <span class="keyword">for</span> row <span class="keyword">in</span> df.collect()]</span><br><span class="line">    centers_hat, points = KMeans(points, k=<span class="number">3</span>, seed=<span class="number">2</span>, num_iter=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"GroundTruth: <span class="subst">&#123;centers&#125;</span>\nPredict: <span class="subst">&#123;centers_hat&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    x, y, labels = zip(*points)</span><br><span class="line">    plot_clustering(x, y, labels, (centers, centers_hat))</span><br><span class="line"></span><br><span class="line">    spark.stop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># %%</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Wake on LAN 使用网络唤醒主机</title>
      <link href="/2022/06/25/linux/wake-on-lan/"/>
      <url>/2022/06/25/linux/wake-on-lan/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.howtogeek.com/70374/how-to-geek-explains-what-is-wake-on-lan-and-how-do-i-enable-it/" target="_blank" rel="noopener">What Is Wake-on-LAN, and How Do I Enable It? (howtogeek.com)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>motd 设置登录提示</title>
      <link href="/2022/06/21/linux/motd/"/>
      <url>/2022/06/21/linux/motd/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://manpages.ubuntu.com/manpages/focal/man5/update-motd.5.html" target="_blank" rel="noopener">Ubuntu Manpage: update-motd - dynamic MOTD generation</a></p></blockquote><p>motd: message of the day</p><p>登录Linux之后的提示信息</p><p>传统方式存放在 <code>/etc/motd</code> 中，Ubuntu 中将其放置在 <code>/etc/update-motd.d</code> 下</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu - apt proxy</title>
      <link href="/2022/06/15/linux/apt-proxy/"/>
      <url>/2022/06/15/linux/apt-proxy/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://askubuntu.com/questions/257290/configure-proxy-for-apt" target="_blank" rel="noopener">Configure proxy for APT? - Ask Ubuntu</a></p></blockquote><p>在 <code>/etc/apt/apt.conf.d</code> 中创建一个单独的配置文件用于记录代理</p><p>如：<code>/etc/apt/apt.conf.d/proxy.conf</code>，按照一下格式添加代理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Acquire::http::Proxy <span class="string">"http://yourproxyaddress:proxyport"</span>;</span><br></pre></td></tr></table></figure><p><code>Acquire::http::Proxy &quot;socks5h://localhost:65500&quot;;</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何判断环境变量定义在哪里</title>
      <link href="/2022/06/10/linux/how-to-determine-where-an-environment-variable-came-from/"/>
      <url>/2022/06/10/linux/how-to-determine-where-an-environment-variable-came-from/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://unix.stackexchange.com/questions/813/how-to-determine-where-an-environment-variable-came-from" target="_blank" rel="noopener">bash - How to determine where an environment variable came from? - Unix &amp; Linux Stack Exchange</a></p><p><a href="https://unix.stackexchange.com/a/249922" target="_blank" rel="noopener">https://unix.stackexchange.com/a/249922</a></p></blockquote><p>Some places to look first:</p><p><strong>System wide</strong></p><ul><li><code>/etc/environment</code>: specifically meant for environment variables</li><li><code>/etc/env.d/*</code>: environment variables, split in multiple files</li><li><code>/etc/profile</code>: all types of initialization scripts</li><li><code>/etc/profile.d/*</code>: initialization scripts</li><li><code>/etc/bashrc</code>, <code>/etc/bash.bashrc</code>: meant for functions and aliases</li></ul><p><strong>User specific</strong></p><ul><li><code>~/.bash_profile</code>: initialization for login (bash-)shells</li><li><code>~/.bashrc</code>: initialization for all interactive (bash-)shells</li><li><code>~/.profile</code>: used for all shells</li><li><code>~/.cshrc</code>, <code>~/.zshrc</code>, <code>~/.tcshrc</code>: similar for non-bash shells</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>终端工具</title>
      <link href="/2022/06/02/linux/terminal-kits/"/>
      <url>/2022/06/02/linux/terminal-kits/</url>
      
        <content type="html"><![CDATA[<h2 id="autojump"><a href="#autojump" class="headerlink" title="autojump"></a>autojump</h2><ul><li>使用brew安装autojump后的安装路径</li></ul><p>[ -f /usr/local/etc/profile.d/autojump.sh ] &amp;&amp; . /usr/local/etc/profile.d/autojump.sh</p><p>[ -f /opt/homebrew/etc/profile.d/autojump.sh ] &amp;&amp; . /opt/homebrew/etc/profile.d/autojump.sh</p><ul><li>Ubuntu中使用apt安装autojump</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install autojump</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>/etc/apt/source.list.d 目录的作用</title>
      <link href="/2022/06/02/linux/what-is-source-list-d/"/>
      <url>/2022/06/02/linux/what-is-source-list-d/</url>
      
        <content type="html"><![CDATA[<p>后缀d表示这是一个目录</p><p>其中存放第三方的apt源头，格式以<code>.list</code>结尾</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 分辨率问题</title>
      <link href="/2022/05/16/linux/ubuntu-resolution-setting/"/>
      <url>/2022/05/16/linux/ubuntu-resolution-setting/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://blog.csdn.net/happyeveryday62/article/details/103000527" target="_blank" rel="noopener">ubuntu18.04分辨率最高只有1024<em>768_Onwaier的博客-CSDN博客_ubuntu分辨率只有1024</em>768</a></p></blockquote><ol><li>编辑<code>/etc/default/grub</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/default/grub</span></span><br></pre></td></tr></table></figure><p>定位到 <code>#GRUB_GFXMODE=640x480</code>删除“＃”，然后将分辨率修成你想要的 <code>GRUB_GFXMODE=1920x1080</code></p><ol start="2"><li>更新</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo update-grub</span></span><br></pre></td></tr></table></figure><ol start="3"><li>重启</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1026 Table Tennis (30分) (模拟问题)</title>
      <link href="/2020/04/27/pat-A1026/"/>
      <url>/2020/04/27/pat-A1026/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805472333250560" target="_blank" rel="noopener">A1026 Table Tennis (30分)</a></p><p>A table tennis club has N tables available to the public. The tables are numbered from 1 to N. For any pair of players, if there are some tables open when they arrive, they will be assigned to the available table with the smallest number. If all the tables are occupied, they will have to wait in a queue. It is assumed that every pair of players can play for at most 2 hours.</p><p>Your job is to count for everyone in queue their waiting time, and for each table the number of players it has served for the day.</p><p>One thing that makes this procedure a bit complicated is that the club reserves some tables for their VIP members. When a VIP table is open, the first VIP pair in the queue will have the priviledge to take it. However, if there is no VIP in the queue, the next pair of players can take it. On the other hand, if when it is the turn of a VIP pair, yet no VIP table is available, they can be assigned as any ordinary players.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains an integer <code>N</code> (≤10000) - the total number of pairs of players. Then <code>N</code> lines follow, each contains 2 times and a VIP tag: <code>HH:MM:SS</code> - the arriving time, <code>P</code> - the playing time in minutes of a pair of players, and <code>tag</code> - which is 1 if they hold a VIP card, or 0 if not. It is guaranteed that the arriving time is between 08:00:00 and 21:00:00 while the club is open. It is assumed that no two customers arrives at the same time. Following the players’ info, there are 2 positive integers: <code>K</code> (≤100) - the number of tables, and <code>M</code> (&lt; K) - the number of VIP tables. The last line contains <code>M</code> table numbers.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, first print the arriving time, serving time and the waiting time for each pair of players in the format shown by the sample. Then print in a line the number of players served by each table. Notice that the output must be listed in chronological order of the serving time. The waiting time must be rounded up to an integer minute(s). If one cannot get a table before the closing time, their information must NOT be printed.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">20:52:00 10 0</span><br><span class="line">08:00:00 20 0</span><br><span class="line">08:02:00 30 0</span><br><span class="line">20:51:00 10 0</span><br><span class="line">08:10:00 5 0</span><br><span class="line">08:12:00 10 1</span><br><span class="line">20:50:00 10 0</span><br><span class="line">08:01:30 15 1</span><br><span class="line">20:53:00 10 1</span><br><span class="line">3 1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">08:00:00 08:00:00 0</span><br><span class="line">08:01:30 08:01:30 0</span><br><span class="line">08:02:00 08:02:00 0</span><br><span class="line">08:12:00 08:16:30 5</span><br><span class="line">08:10:00 08:20:00 10</span><br><span class="line">20:50:00 20:50:00 0</span><br><span class="line">20:51:00 20:51:00 0</span><br><span class="line">20:52:00 20:52:00 0</span><br><span class="line">3 3 2</span><br></pre></td></tr></table></figure><ul><li>题意：</li><li>思路：<ol start="0"><li>按照时间将运动员升序排序</li><li>从编号最低开始遍历所有桌子，找到最先空闲出来的桌子<ul><li>如果是普通桌子，直接分配给队列中的第一对运动员</li><li>如果是VIP桌子，则查找队列中的第一对VIP运动员，若不存在则分配给第一对运动员</li></ul></li><li>以上分配桌子时记录开始时间，开始时间减到达时间则为运动员的等待时间</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-46 新浪微博热门话题 (30分) (字符串解析)</title>
      <link href="/2020/03/30/pta-ds-7-46/"/>
      <url>/2020/03/30/pta-ds-7-46/</url>
      
        <content type="html"><![CDATA[<p>PTA数据结构与算法题目集(中文)： <a href="https://pintia.cn/problem-sets/15/problems/893" target="_blank" rel="noopener">7-46 新浪微博热门话题 (30分)</a></p><p>新浪微博可以在发言中嵌入“话题”，即将发言中的话题文字写在一对“#”之间，就可以生成话题链接，点击链接可以看到有多少人在跟自己讨论相同或者相似的话题。新浪微博还会随时更新热门话题列表，并将最热门的话题放在醒目的位置推荐大家关注。</p><p>本题目要求实现一个简化的热门话题推荐功能，从大量英文（因为中文分词处理比较麻烦）微博中解析出话题，找出被最多条微博提到的话题。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入说明：输入首先给出一个正整数<em>N</em>（≤10<sup>5</sup>），随后<em>N</em>行，每行给出一条英文微博，其长度不超过140个字符。任何包含在一对最近的<code>#</code>中的内容均被认为是一个话题，输入保证<code>#</code>成对出现。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>第一行输出被最多条微博提到的话题，第二行输出其被提到的微博条数。如果这样的话题不唯一，则输出按字母序最小的话题，并在第三行输出<code>And k more ...</code>，其中<code>k</code>是另外几条热门话题的条数。输入保证至少存在一条话题。</p><p>注意：两条话题被认为是相同的，如果在去掉所有非英文字母和数字的符号、并忽略大小写区别后，它们是相同的字符串；同时它们有完全相同的分词。输出时除首字母大写外，只保留小写英文字母和数字，并用一个空格分隔原文中的单词。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">This is a #test of topic#.</span><br><span class="line">Another #Test of topic.#</span><br><span class="line">This is a #Hot# #Hot# topic</span><br><span class="line">Another #hot!# #Hot# topic</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hot</span><br><span class="line">2</span><br><span class="line">And 1 more ...</span><br></pre></td></tr></table></figure><ul><li><p>题意：输入的每一行代表一条微博，其中一对#包裹的部分表示这条微博参与的“话题”（一条微博可以参与多个话题）。要求找出参与数最多的话题。话题由英文数字和其他非中文字符组成，两条话题去除非英文和数字的部分若相等则表示这两则话题相等。</p></li><li><p>分析：这题是 <a href="https://pintia.cn/problem-sets/15/problems/type/7" target="_blank" rel="noopener">数据结构与算法题目集（中文）</a>上通过率最低的题，通常字符串处理的题目是有些麻烦的，把思路理清也不会太难。主要分为以下几步骤：</p><ol start="0"><li>将一条微博中 <strong>#</strong> 包裹的topic解析出来</li><li>将取出的topic解析成两个字符串，一个是只包含的字母和数字并全转为小写，另一个则将所有单词用一个空格拼接且让首字母大写（即题目要求的输出格式）</li><li>设置名为 <strong>cnt</strong> 的无序map用于记录每个话题出现的次数，在一条微博中重复出现的话题也只当出现一次，因此需要用 <strong>exist</strong> 来记录是否出现过，若未出现过 <strong>cnt</strong> 才加1</li><li>为了方便排序，声明结构体用于保存答案</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="built_in">string</span> topic;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node &amp;a, node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.cnt != b.cnt ? a.cnt &gt; b.cnt : a.topic &lt; b.topic;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">parse</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> &amp;outputTopic)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ans, it;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalnum</span>(s[i])) it += s[i];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[i]) || i == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it != <span class="string">""</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; it.length(); j++) &#123;</span><br><span class="line">                    ans += <span class="built_in">tolower</span>(it[j]);</span><br><span class="line">                    outputTopic += <span class="built_in">tolower</span>(it[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                outputTopic += <span class="string">' '</span>;</span><br><span class="line">                it = <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    outputTopic[<span class="number">0</span>] = <span class="built_in">toupper</span>(outputTopic[<span class="number">0</span>]);</span><br><span class="line">    outputTopic.erase(outputTopic.end() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>, s);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; exist;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'#'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="built_in">string</span> originalTopic = s.substr(start, i - start), outputTopic;</span><br><span class="line">                    <span class="built_in">string</span> lowerTopic = parse(originalTopic, outputTopic);</span><br><span class="line">                    <span class="keyword">if</span> (!exist[lowerTopic]) &#123;</span><br><span class="line">                        exist[lowerTopic] = <span class="literal">true</span>;</span><br><span class="line">                        cnt[outputTopic]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;node&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : cnt) ans.push_back(&#123;it.second, it.first&#125;);</span><br><span class="line">    sort(ans.begin(), ans.end(), cmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n%d\n"</span>, ans[<span class="number">0</span>].topic.c_str(), ans[<span class="number">0</span>].cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i].cnt != ans[<span class="number">0</span>].cnt) <span class="keyword">break</span>;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"And %d more ..."</span>, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1106 Lowest Price in Supply Chain (25分) (DFS+剪枝)</title>
      <link href="/2020/03/29/pat-A1106/"/>
      <url>/2020/03/29/pat-A1106/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805362341822464" target="_blank" rel="noopener">A1106 Lowest Price in Supply Chain (25分)</a></p><p>A supply chain is a network of retailers（零售商）, distributors（经销商）, and suppliers（供应商）– everyone involved in moving a product from supplier to customer.</p><p>Starting from one root supplier, everyone on the chain buys products from one’s supplier in a price <em>P</em> and sell or distribute them in a price that is <em>r</em>% higher than <em>P</em>. Only the retailers will face the customers. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle.</p><p>Now given a supply chain, you are supposed to tell the lowest price a customer can expect from some retailers.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, The first line contains three positive numbers: <em>N</em> (≤10<sup>5</sup>), the total number of the members in the supply chain (and hence their ID’s are numbered from 0 to <em>N</em>−1, and the root supplier’s ID is 0); <em>P</em>, the price given by the root supplier; and <em>r</em>, the percentage rate of price increment for each distributor or retailer. Then <em>N</em> lines follow, each describes a distributor or retailer in the following format:</p><p><em>K</em><sub><em>i</em></sub> ID[1] ID[2] … ID[<em>K</em><sub><em>i</em></sub>]</p><p>where in the <em>i</em>-th line, <em>K</em><sub><em>i</em></sub> is the total number of distributors or retailers who receive products from supplier <em>i</em>, and is then followed by the ID’s of these distributors or retailers. <em>K</em><sub><em>j</em></sub> being 0 means that the <em>j</em>-th member is a retailer. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the lowest price we can expect from some retailers, accurate up to 4 decimal places, and the number of retailers that sell at the lowest price. There must be one space between the two numbers. It is guaranteed that the all the prices will not exceed 1010.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10 1.80 1.00</span><br><span class="line">3 2 3 5</span><br><span class="line">1 9</span><br><span class="line">1 4</span><br><span class="line">1 7</span><br><span class="line">0</span><br><span class="line">2 6 1</span><br><span class="line">1 8</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.8362 2</span><br></pre></td></tr></table></figure><ul><li>题意：转述题意，一棵树中根结点是 <strong>供应商</strong>、叶子结点是 <strong>零售商</strong>、中间结点均为 <strong>经销商</strong>，零售商将供应商提供的商品销售出去需要经过一个或多个经销商，每经一个经销商价格都会增加 <strong>r%</strong>，问客户从零售商处购买商品可以得到的最低价格是多少，共有多少个零售商可以提供这样的最低价。</li><li>分析：这是树的深度优先搜索问题，在 <strong>dfs</strong> 函数中需要维护 <strong>当前结点编号</strong> 和 <strong>当前价格</strong> 两个参数，当到达叶子结点的时候判断当前价格是否小于最小价格即可。这里可以适当剪枝，即当price小于或等于最低价格时才继续向下搜索，但实际上提交代码后发现耗时没什么区别。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N], ans;</span><br><span class="line"><span class="keyword">int</span> n, k, cntMin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> r, p, minPrice = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e[u].size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (price &lt; minPrice) &#123;</span><br><span class="line">            minPrice = price;</span><br><span class="line">            cntMin = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (price == minPrice) &#123;</span><br><span class="line">            cntMin++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : e[u]) &#123;</span><br><span class="line">        <span class="keyword">double</span> tempP = price * (<span class="number">1</span> + r / <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (tempP &lt;= minPrice) dfs(it, tempP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lf%lf"</span>, &amp;n, &amp;p, &amp;r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">            e[i].push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.4f %d"</span>, minPrice, cntMin);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【程序设计】信息工程学院学生信息变动Excel标注程序</title>
      <link href="/2020/03/23/python-info-comparison/"/>
      <url>/2020/03/23/python-info-comparison/</url>
      
        <content type="html"><![CDATA[<p>点击右侧下载此程序：<a href="/信息工程学院变动标注程序32位.exe">信息工程学院变动标注程序32位.exe</a> | <a href="/信息工程学院变动标注程序64位.exe">信息工程学院变动标注程序64位.exe</a></p><p><strong>注意事项：</strong>此程序使用Python编写，所使用的Excel类库仅支持.xlsx新版表格格式，<u>使用前先转至Office或WPS中 <strong>将.xls另存为.xlsx格式</strong> </u>。另，Python程序执行速度较慢，数据量较多时执行时间将有所延长（约1分钟），出现的无响应情况并非程序崩溃，需耐心等待。</p><p><strong>使用方式：</strong>如图所示，点击 <strong>路径选择</strong> 分别选定昨日文件、今日文件与数据导出的位置（导出文件的名称由当前日期自动生成，也可修改），文本框的文件路径可手动输入，但亦出错（不推荐）。</p><p><img src="/img/python_info.png" alt="程序执行界面"></p><hr><ul><li>程序需求：因疫情问题，学院需每日统计学生的健康、出行以及学生所在社区的疫情情况等，并将当日的Excel统计数据比较于前一日的学生数据，将数据变动行填充为红色，变动处单元格填充为黄色。</li><li>程序设计：<ol><li>从便捷性与开发时间考虑，选用Python作为开发语言，使用 <strong>openpyxl</strong> 库处理Excel数据</li><li>算法思路：每日数据表格 <strong>格式完全一致</strong>，故逐行逐单元格比较，若出现单元格数值不相等则将其所在行标记为 <strong>有变动</strong>，并将当前单元格的列号存至列表 <strong>list_diff</strong> 中，其后将 <strong>变动行</strong> 所有单元格填充为红色（#FF0000），再通过 <strong>list_diff</strong> 将变动的单元格填充为黄色（#FFFF00）</li><li>考虑使非开发者可运行该脚本程序，为该程序添加图形界面，并将其打包成 <strong>.exe</strong> 可执行文件</li></ol></li><li>核心类库：<strong>time</strong>、<strong>tkinter</strong> 与 <strong>openpyxl</strong></li></ul><p>程序实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> strftime, localtime</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> filedialog, Tk, Label, Entry, Button, StringVar</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> messagebox</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl.styles <span class="keyword">import</span> PatternFill</span><br><span class="line"><span class="keyword">from</span> openpyxl.styles.fonts <span class="keyword">import</span> Font</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义文件类型</span></span><br><span class="line">file_type = [(<span class="string">'Excel文件类型'</span>, <span class="string">'.xlsx'</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要检查的列号</span></span><br><span class="line">check_col_numbers = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>,</span><br><span class="line">                     <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件选择框, 选择对比文件路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_opened_file_path</span><span class="params">(sv)</span>:</span></span><br><span class="line">    sv.set(filedialog.askopenfilename(</span><br><span class="line">        title=<span class="string">'选择文件路径'</span>,</span><br><span class="line">        filetypes=file_type,</span><br><span class="line">        defaultextension=<span class="string">'.xlsx'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件保存框, 选择导出文件路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_saved_file_path</span><span class="params">(sv)</span>:</span></span><br><span class="line">    current_date = strftime(<span class="string">"%Y_%m_%d"</span>, localtime())</span><br><span class="line">    sv.set(filedialog.asksaveasfilename(</span><br><span class="line">        title=<span class="string">'选择导出文件路径'</span>,</span><br><span class="line">        filetypes=file_type,</span><br><span class="line">        defaultextension=<span class="string">'.xlsx'</span>,</span><br><span class="line">        initialfile=<span class="string">'信息工程学院'</span> + current_date + <span class="string">'学生信息填报.xlsx'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对比处理函数, 导出结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">()</span>:</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 存在空路径退出函数</span></span><br><span class="line">        <span class="keyword">if</span> file_today.get() == <span class="string">''</span> <span class="keyword">or</span> file_yesterday.get() == <span class="string">''</span> <span class="keyword">or</span> file_output.get() == <span class="string">''</span>:</span><br><span class="line">            messagebox.showinfo(<span class="string">"错误信息"</span>, <span class="string">"文件路径有误, 请重新选择!"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 今日与昨日工作簿</span></span><br><span class="line">        wb_today = load_workbook(filename=file_today.get())</span><br><span class="line">        wb_yesterday = load_workbook(filename=file_yesterday.get())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 今日与昨日表</span></span><br><span class="line">        sheet_today = wb_today.worksheets[<span class="number">0</span>]</span><br><span class="line">        sheet_yesterday = wb_yesterday.worksheets[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 行号起始与结束编号</span></span><br><span class="line">        index_start, index_end = <span class="number">5</span>, sheet_today.max_row</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> row_num <span class="keyword">in</span> range(index_start, index_end + <span class="number">1</span>):</span><br><span class="line">            is_changed = <span class="literal">False</span></span><br><span class="line">            list_diff = []</span><br><span class="line">            <span class="keyword">for</span> col_num <span class="keyword">in</span> check_col_numbers:</span><br><span class="line">                <span class="keyword">if</span> sheet_today.cell(row=row_num, column=col_num).value != sheet_yesterday.cell(row=row_num, column=col_num).value:</span><br><span class="line">                    <span class="comment"># 列表记录不同单元格列号</span></span><br><span class="line">                    list_diff.append(col_num)</span><br><span class="line">                    is_changed = <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 不是完全相同的, 将该行填充为红色, 再将不同单元格填充为黄色</span></span><br><span class="line">            <span class="keyword">if</span> is_changed:</span><br><span class="line">                cnt = cnt + <span class="number">1</span></span><br><span class="line">                font = sheet_today.cell(row=row_num, column=col_num).font.copy(color=<span class="string">'00000000'</span>)</span><br><span class="line">                <span class="keyword">for</span> col_num <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">37</span> + <span class="number">1</span>):</span><br><span class="line">                    sheet_today.cell(row=row_num, column=col_num).fill = PatternFill(<span class="string">'solid'</span>, fgColor=<span class="string">'FF0000'</span>)</span><br><span class="line">                    sheet_today.cell(row=row_num, column=col_num).font = font</span><br><span class="line">                <span class="keyword">for</span> col_num <span class="keyword">in</span> list_diff:</span><br><span class="line">                    sheet_today.cell(row=row_num, column=col_num).fill = PatternFill(<span class="string">'solid'</span>, fgColor=<span class="string">'FFFF00'</span>)</span><br><span class="line">        wb_today.save(file_output.get())</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        messagebox.showinfo(<span class="string">"错误信息"</span>, <span class="string">"文件路径有误, 请重新选择!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        wb_today.close()</span><br><span class="line">        wb_yesterday.close()</span><br><span class="line">        messagebox.showinfo(<span class="string">"提示信息"</span>, <span class="string">'已导出至储存路径, 共 %d 人信息变动'</span> % cnt)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># tkinter库创建简单图形界面</span></span><br><span class="line">root = Tk()</span><br><span class="line">root.title(<span class="string">'信息工程学院-学生信息改动标注 powered by 金'</span>)</span><br><span class="line">root.resizable(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">file_today, file_yesterday, file_output = StringVar(), StringVar(), StringVar()</span><br><span class="line">Label(root, text=<span class="string">'注: 仅支持.xlsx格式的Excel表格, .xls另存为至.xlsx做格式转换'</span>).grid(row=<span class="number">0</span>, column=<span class="number">1</span>)</span><br><span class="line">Label(root, text=<span class="string">'昨日文件路径:'</span>).grid(row=<span class="number">1</span>, column=<span class="number">0</span>)</span><br><span class="line">Entry(root, textvariable=file_yesterday).grid(row=<span class="number">1</span>, column=<span class="number">1</span>, sticky=<span class="string">'we'</span>)</span><br><span class="line">Button(root, text=<span class="string">'路径选择'</span>, command=<span class="keyword">lambda</span>: select_opened_file_path(file_yesterday)).grid(row=<span class="number">1</span>, column=<span class="number">2</span>)</span><br><span class="line">Label(root, text=<span class="string">'今日文件路径:'</span>).grid(row=<span class="number">2</span>, column=<span class="number">0</span>)</span><br><span class="line">Entry(root, textvariable=file_today).grid(row=<span class="number">2</span>, column=<span class="number">1</span>, sticky=<span class="string">'we'</span>)</span><br><span class="line">Button(root, text=<span class="string">'路径选择'</span>, command=<span class="keyword">lambda</span>: select_opened_file_path(file_today)).grid(row=<span class="number">2</span>, column=<span class="number">2</span>)</span><br><span class="line">Label(root, text=<span class="string">'保存路径:'</span>).grid(row=<span class="number">3</span>, column=<span class="number">0</span>)</span><br><span class="line">Entry(root, textvariable=file_output).grid(row=<span class="number">3</span>, column=<span class="number">1</span>, sticky=<span class="string">'we'</span>)</span><br><span class="line">Button(root, text=<span class="string">'路径选择'</span>, command=<span class="keyword">lambda</span>: select_saved_file_path(file_output)).grid(row=<span class="number">3</span>, column=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Button(root, text=<span class="string">'点我导出 (非程序崩溃, Python程序需要1分钟处理数据)'</span>, command=solve).grid(row=<span class="number">4</span>, column=<span class="number">1</span>)</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><ul><li>问题修复：由于原表内包含字体为红色的单元格，因此，若该行被填充为红色将导致其不可见地显示数值，添加功能——若某行为 <strong>变动行</strong>，则先将该行所有单元格字体颜色置为黑色，再行填充。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> openpyxl </tag>
            
            <tag> tkinter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】nohup 命令使用</title>
      <link href="/2020/03/07/linux-cmd-nohup/"/>
      <url>/2020/03/07/linux-cmd-nohup/</url>
      
        <content type="html"><![CDATA[<p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup 命令 &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>用man查看一下说明，<strong>nohup - run a command immune to hangups, with output to a non-tty</strong></p><p>nohup 用来以非挂起的状态运行命令。</p><p>使用场景：比如使用java -jar 开启服务，exit 退出终端时避免杀死程序。</p><p>最后的 <strong>&amp;</strong> 表示后台运行</p><p><code>&gt; /dev/null</code> 和 <code>1 &gt; /dev/null</code> 含义一致，1 表示stdout标准输出，意为把标准输出重定向到/dev/null中，<strong>/dev/null</strong>是一个只写文件，里面的内容总会被丢弃，重定向到这个文件中相当于丢弃标准输出的内容。</p><p><code>2 &gt; &amp;1</code>中，2表示stderr标准错误，意为把标准输出重定向到 &amp;1 中，&amp;1 的含义就是引用标准输出的重定向位置</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1091 Acute Stroke (30分) (BFS广度优先搜索)</title>
      <link href="/2020/03/03/pat-A1091/"/>
      <url>/2020/03/03/pat-A1091/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805375457411072" target="_blank" rel="noopener">A1091 Acute Stroke (30分)</a></p><p>One important factor to identify acute stroke (急性脑卒中) is the volume of the stroke core. Given the results of image analysis in which the core regions are identified in each MRI slice, your job is to calculate the volume of the stroke core.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 4 positive integers: <em>M</em>, <em>N</em>, <em>L</em> and <em>T</em>, where <em>M</em> and <em>N</em> are the sizes of each slice (i.e. pixels of a slice are in an <em>M</em>×<em>N</em> matrix, and the maximum resolution is 1286 by 128); <em>L</em> (≤60) is the number of slices of a brain; and <em>T</em> is the integer threshold (i.e. if the volume of a connected core is less than <em>T</em>, then that core must not be counted).</p><p>Then <em>L</em> slices are given. Each slice is represented by an <em>M</em>×<em>N</em> matrix of 0’s and 1’s, where 1 represents a pixel of stroke, and 0 means normal. Since the thickness of a slice is a constant, we only have to count the number of 1’s to obtain the volume. However, there might be several separated core regions in a brain, and only those with their volumes no less than <em>T</em> are counted. Two pixels are <strong>connected</strong> and hence belong to the same region if they share a common side, as shown by Figure 1 where all the 6 red pixels are connected to the blue one.</p><p><img src="https://images.ptausercontent.com/f85c00cc-62ce-41ff-8dd0-d1c288d87409.jpg" alt="Figure 1"></p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, output in a line the total volume of the stroke core.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">3 4 5 2</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">0 0 1 1</span><br><span class="line">0 0 1 1</span><br><span class="line">0 0 1 1</span><br><span class="line">1 0 1 1</span><br><span class="line">0 1 0 0</span><br><span class="line">0 0 0 0</span><br><span class="line">1 0 1 1</span><br><span class="line">0 0 0 0</span><br><span class="line">0 0 0 0</span><br><span class="line">0 0 0 1</span><br><span class="line">0 0 0 1</span><br><span class="line">1 0 0 0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">26</span><br></pre></td></tr></table></figure><ul><li>题意：计算中风核心块的体积是判断急性脑卒中的关键方法之一。题目给了一张三维的分析图，图中为1的点为中风块的可疑点，0则是正常的。现在给定阈值，如果某一区域的中风块数量大于给定阈值则视这块为病变区，现在要求计算总的病变区体积。</li><li>分析：这里显然是考察的BFS广度优先搜索，题目给定的是三维图，实际上二维的图没什么区别，二维中邻接点为相连的点（无向图中），这里的三维则是二维上的上下左右和第三维（即垂直方向）的上和下，一共是6个方向来表示邻接点。因此，首先用三维数组存储图，之后用X、Y、Z数组依次存放坐标改变的增量，这样用一个for循环遍历坐标的增量数组很轻松就能找到邻接点，之后和BFS同样的做法，用队列完成BFS。要注意的是，这里给定的三维的坐标，对于边界上的点，计算邻接点时会出现越界的情况的，那么相较于传统判断某点是否可访问的条件，这里还需要判断是否越界，越界了也是不能访问的。之后因为图可能是不连通的，所以需要将各个连通子图所得出的大于阈值的体积相加。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, l, t, e[<span class="number">65</span>][<span class="number">1300</span>][<span class="number">130</span>];</span><br><span class="line"><span class="keyword">int</span> X[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, Y[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">    Z[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> inq[<span class="number">65</span>][<span class="number">1300</span>][<span class="number">130</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isVisitable</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || z &lt; <span class="number">0</span> || z &gt;= l) &amp;&amp;</span><br><span class="line">           e[z][x][y] != <span class="number">0</span> &amp;&amp; !inq[z][x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(node a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">    q.push(a);</span><br><span class="line">    inq[a.z][a.x][a.y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        node now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> x = now.x, y = now.y, z = now.z;</span><br><span class="line">        sum += e[z][x][y];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            x = now.x + X[i];</span><br><span class="line">            y = now.y + Y[i];</span><br><span class="line">            z = now.z + Z[i];</span><br><span class="line">            <span class="keyword">if</span> (isVisitable(x, y, z)) &#123;</span><br><span class="line">                inq[z][x][y] = <span class="literal">true</span>;</span><br><span class="line">                q.push(&#123;x, y, z&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &gt;= t ? sum : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;m, &amp;n, &amp;l, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; l; k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;e[k][i][j]);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; l; k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (isVisitable(i, j, k)) ans += bfs(&#123;i, j, k&#125;);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> BFS </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1095 Cars on Campus (30分) (模拟问题)</title>
      <link href="/2020/03/01/pat-A1095/"/>
      <url>/2020/03/01/pat-A1095/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805371602845696" target="_blank" rel="noopener">A1095 Cars on Campus (30分)</a></p><p>Zhejiang University has 8 campuses and a lot of gates. From each gate we can collect the in/out times and the plate numbers of the cars crossing the gate. Now with all the information available, you are supposed to tell, at any specific time point, the number of cars parking on campus, and at the end of the day find the cars that have parked for the longest time period.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with two positive integers <em>N</em> (≤10<sup>4</sup>), the number of records, and <em>K</em> (≤8×10<sup>4</sup>) the number of queries. Then <em>N</em> lines follow, each gives a record in the format:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plate_number hh:mm:ss status</span><br></pre></td></tr></table></figure><p>where <code>plate_number</code> is a string of 7 English capital letters or 1-digit numbers; <code>hh:mm:ss</code> represents the time point in a day by hour:minute:second, with the earliest time being <code>00:00:00</code> and the latest <code>23:59:59</code>; and <code>status</code> is either <code>in</code> or <code>out</code>.</p><p>Note that all times will be within a single day. Each <code>in</code> record is paired with the chronologically next record for the same car provided it is an <code>out</code> record. Any <code>in</code> records that are not paired with an <code>out</code> record are ignored, as are <code>out</code> records not paired with an <code>in</code> record. It is guaranteed that at least one car is well paired in the input, and no car is both <code>in</code> and <code>out</code> at the same moment. Times are recorded using a 24-hour clock.</p><p>Then <em>K</em> lines of queries follow, each gives a time point in the format <code>hh:mm:ss</code>. Note: the queries are given in <strong>ascending</strong> order of the times.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each query, output in a line the total number of cars parking on campus. The last line of output is supposed to give the plate number of the car that has parked for the longest time period, and the corresponding time length. If such a car is not unique, then output all of their plate numbers in a line in alphabetical order, separated by a space.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">16 7</span><br><span class="line">JH007BD 18:00:01 in</span><br><span class="line">ZD00001 11:30:08 out</span><br><span class="line">DB8888A 13:00:00 out</span><br><span class="line">ZA3Q625 23:59:50 out</span><br><span class="line">ZA133CH 10:23:00 in</span><br><span class="line">ZD00001 04:09:59 in</span><br><span class="line">JH007BD 05:09:59 in</span><br><span class="line">ZA3Q625 11:42:01 out</span><br><span class="line">JH007BD 05:10:33 in</span><br><span class="line">ZA3Q625 06:30:50 in</span><br><span class="line">JH007BD 12:23:42 out</span><br><span class="line">ZA3Q625 23:55:00 in</span><br><span class="line">JH007BD 12:24:23 out</span><br><span class="line">ZA133CH 17:11:22 out</span><br><span class="line">JH007BD 18:07:01 out</span><br><span class="line">DB8888A 06:30:50 in</span><br><span class="line">05:10:00</span><br><span class="line">06:30:50</span><br><span class="line">11:00:00</span><br><span class="line">12:23:42</span><br><span class="line">14:00:00</span><br><span class="line">18:00:00</span><br><span class="line">23:59:00</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">JH007BD ZD00001 07:20:09</span><br></pre></td></tr></table></figure><ul><li>题意：浙江大学有8个校区和多个大门，每个门口都会记录车辆的进出时间，现在给定一天内车辆进出记录，要求根据指定时间输出当时的停车数量，最后输出停车时长最久的车辆。注：每辆车的进出记录都是匹配的，那些未匹配的记录将被舍弃。同时保证没有车辆在同一时刻进出。</li><li>分析：因为存在无效的记录，因此先把有效记录筛选出来，同时记录停车时长最久的车牌号。之后将有效记录按照时间顺序排序。最后，查询某一时刻的停车数时，如果总是遍历一遍记录，那不用试，肯定会超时的，所以先遍历一遍有效记录，将每个时刻的车辆数都记录下来，最后使用二分查找查找。记录数量的方式：在结构体中用<code>flag</code>将进和出分别标记为1和-1，那么遍历记录时，因为已经按照时间增序，所有flag的累加和就是当前时间时间点的车辆数。</li></ul><p>注意点：把输入的时间全转为秒，便于计算；最后输出的时间都是占两格的。二分查找的时候要如果查找成功，直接输出mid时刻的车辆数即可，如果查找失败，那应该输出小于所要查找时间的最大时刻记录下的数量，也就是right的当前位置。</p><p>最耗时的样例用了75ms，应该不算差了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> time, flag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node &amp;a, node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.name != b.name ? a.name &lt; b.name : a.time &lt; b.time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpByTime</span><span class="params">(node &amp;a, node &amp;b)</span> </span>&#123; <span class="keyword">return</span> a.time &lt; b.time; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, hh, mm, ss, maxP = <span class="number">-1</span>, tempCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> status;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    vector&lt;node&gt; record(n), validRecord;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; record[i].name;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d"</span>, &amp;hh, &amp;mm, &amp;ss);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; status;</span><br><span class="line">        record[i].time = hh * <span class="number">3600</span> + mm * <span class="number">60</span> + ss;</span><br><span class="line">        record[i].flag = status == <span class="string">"in"</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(record.begin(), record.end(), cmp);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (record[i].name == record[i + <span class="number">1</span>].name &amp;&amp;</span><br><span class="line">            record[i].flag == <span class="number">1</span> &amp;&amp; record[i + <span class="number">1</span>].flag == <span class="number">-1</span>) &#123;</span><br><span class="line">            validRecord.push_back(record[i]);</span><br><span class="line">            validRecord.push_back(record[i + <span class="number">1</span>]);</span><br><span class="line">            mp[record[i].name] += record[i + <span class="number">1</span>].time - record[i].time;</span><br><span class="line">            <span class="keyword">int</span> ptime = mp[record[i].name];</span><br><span class="line">            <span class="keyword">if</span> (ptime &gt; maxP) &#123;</span><br><span class="line">                maxP = ptime;</span><br><span class="line">                ans.clear();</span><br><span class="line">                ans.push_back(record[i].name);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ptime == maxP) &#123;</span><br><span class="line">                ans.push_back(record[i].name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(validRecord.begin(), validRecord.end(), cmpByTime);</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; validRecord.size(); i++) &#123;</span><br><span class="line">        tempCnt += validRecord[i].flag;</span><br><span class="line">        cnt[validRecord[i].time] = tempCnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d"</span>, &amp;hh, &amp;mm, &amp;ss);</span><br><span class="line">        <span class="keyword">int</span> time = hh * <span class="number">3600</span> + mm * <span class="number">60</span> + ss;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = validRecord.size() - <span class="number">1</span>, mid, flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (time &lt; validRecord[mid].time) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (time &gt; validRecord[mid].time) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt[validRecord[mid].time]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt[validRecord[right].time]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.begin(), ans.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : ans) <span class="built_in">printf</span>(<span class="string">"%s "</span>, it.c_str());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d"</span>, maxP / <span class="number">3600</span>, (maxP % <span class="number">3600</span>) / <span class="number">60</span>, maxP % <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 模拟问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1087 All Roads Lead to Rome (30分) (Dijkstra+DFS)</title>
      <link href="/2020/02/29/pat-A1087/"/>
      <url>/2020/02/29/pat-A1087/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805379664297984" target="_blank" rel="noopener">A1087 All Roads Lead to Rome (30分)</a></p><p>Indeed there are many different tourist routes from our city to Rome. You are supposed to find your clients the route with the least cost while gaining the most happiness.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 2 positive integers <em>N</em> (2≤<em>N</em>≤200), the number of cities, and <em>K</em>, the total number of routes between pairs of cities; followed by the name of the starting city. The next <em>N</em>−1 lines each gives the name of a city and an integer that represents the happiness one can gain from that city, except the starting city. Then <em>K</em> lines follow, each describes a route between two cities in the format <code>City1 City2 Cost</code>. Here the name of a city is a string of 3 capital English letters, and the destination is always <code>ROM</code> which represents Rome.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, we are supposed to find the route with the least cost. If such a route is not unique, the one with the maximum happiness will be recommanded. If such a route is still not unique, then we output the one with the maximum average happiness – it is guaranteed by the judge that such a solution exists and is unique.</p><p>Hence in the first line of output, you must print 4 numbers: the number of different routes with the least cost, the cost, the happiness, and the average happiness (take the integer part only) of the recommanded route. Then in the next line, you are supposed to print the route in the format <code>City1-&gt;City2-&gt;...-&gt;ROM</code>.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6 7 HZH</span><br><span class="line">ROM 100</span><br><span class="line">PKN 40</span><br><span class="line">GDN 55</span><br><span class="line">PRS 95</span><br><span class="line">BLN 80</span><br><span class="line">ROM GDN 1</span><br><span class="line">BLN ROM 1</span><br><span class="line">HZH PKN 1</span><br><span class="line">PRS ROM 2</span><br><span class="line">BLN HZH 2</span><br><span class="line">PKN GDN 1</span><br><span class="line">HZH PRS 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 3 195 97</span><br><span class="line">HZH-&gt;PRS-&gt;ROM</span><br></pre></td></tr></table></figure><ul><li>题意：条条大路通罗马，在前往罗马的旅行路线中，除了起点每个地方都有它的开心值，两个地点之间存在行径费（如果两点连通），要求找到一条路径使得从起点到罗马途中的花销最小，如果路线不唯一则找到中开心值最大的路径，若仍不唯一则找到平均开心值最高的路径。输出花销最低的路径条数、花销、总开心值与平均开心值。</li><li>分析：这是单源最短路径问题，先用Dijkstra算法找出所有满足的花销最少的路径，然后用DFS依次筛选总开心值最高、同时第二尺标满足平均开心值最高的。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://pintia.cn/problem-sets/994805342720868352/problems/994805379664297984</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> e[N][N], d[N], weight[N] = &#123;<span class="number">0</span>&#125;, n, m, st = <span class="number">0</span>, dest, cntPath = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[N], path, tempPath;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    fill(d, d + N, INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> vis[N] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; d[i] &lt; MIN) &#123;</span><br><span class="line">                u = i;</span><br><span class="line">                MIN = d[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; e[u][v] != INF) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[u] + e[u][v] &lt; d[v]) &#123;</span><br><span class="line">                    d[v] = d[u] + e[u][v];</span><br><span class="line">                    pre[v].clear();</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d[u] + e[u][v] == d[v]) &#123;</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxW = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">double</span> maxAvg = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> sum, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    tempPath.push_back(u);</span><br><span class="line">    <span class="keyword">if</span> (u == st) &#123;</span><br><span class="line">        cntPath++;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; maxW) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> tempAvg = sum * <span class="number">1.0</span> / cnt;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; maxW || (sum == maxW &amp;&amp; tempAvg &gt; maxAvg)) &#123;</span><br><span class="line">            maxW = sum;</span><br><span class="line">            maxAvg = tempAvg;</span><br><span class="line">            path = tempPath;</span><br><span class="line">        &#125;</span><br><span class="line">        tempPath.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> next : pre[u]) dfs(next, sum + weight[next], cnt + <span class="number">1</span>);</span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp, a, b;</span><br><span class="line">    <span class="built_in">string</span> start, s, city1, city2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; start;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; nametoid;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; idtoname;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; weight[i];</span><br><span class="line">        nametoid[s] = i;</span><br><span class="line">        idtoname[i] = s;</span><br><span class="line">    &#125;</span><br><span class="line">    fill(e[<span class="number">0</span>], e[<span class="number">0</span>] + N * N, INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">int</span> a = nametoid[city1], b = nametoid[city2];</span><br><span class="line">        e[a][b] = e[b][a] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    dest = nametoid[<span class="string">"ROM"</span>];</span><br><span class="line">    dijkstra(<span class="number">0</span>);</span><br><span class="line">    dfs(dest, weight[dest], <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d %d\n%s"</span>, cntPath, d[dest], maxW, (<span class="keyword">int</span>)maxAvg, start.c_str());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = path.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-&gt;%s"</span>, idtoname[path[i]].c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DFS有两种写法，总体无异，这似乎也没法剪枝。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    tempPath.push_back(u);</span><br><span class="line">    <span class="keyword">if</span> (pre[u].size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> tempHp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tempPath.size(); i++) tempHp += hp[tempPath[i]];</span><br><span class="line">        <span class="keyword">double</span> tempAvg = tempHp * <span class="number">1.0</span> / (tempPath.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tempHp &gt; maxHp || (tempHp == maxHp &amp;&amp; tempAvg &gt; maxAvg)) &#123;</span><br><span class="line">            maxHp = tempHp;</span><br><span class="line">            maxAvg = tempAvg;</span><br><span class="line">            path = tempPath;</span><br><span class="line">        &#125;</span><br><span class="line">        tempPath.pop_back();</span><br><span class="line">        cntRoute++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : pre[u]) dfs(v);</span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> Dijkstra最短路径算法 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1119 Pre- and Post-order Traversals (30分) (前后序遍历序列建树)</title>
      <link href="/2020/02/28/pat-A1119/"/>
      <url>/2020/02/28/pat-A1119/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805353470869504" target="_blank" rel="noopener">A1119 Pre- and Post-order Traversals (30分)</a></p><p>Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences, or preorder and inorder traversal sequences. However, if only the postorder and preorder traversal sequences are given, the corresponding tree may no longer be unique.</p><p>Now given a pair of postorder and preorder traversal sequences, you are supposed to output the corresponding inorder traversal sequence of the tree. If the tree is not unique, simply output any one of them.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 30), the total number of nodes in the binary tree. The second line gives the preorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, first printf in a line <code>Yes</code> if the tree is unique, or <code>No</code> if not. Then print in the next line the inorder traversal sequence of the corresponding binary tree. If the solution is not unique, any answer would do. It is guaranteed that at least one solution exists. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">1 2 3 4 6 7 5</span><br><span class="line">2 6 7 4 5 3 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">2 1 6 4 7 3 5</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 3 4</span><br><span class="line">2 4 3 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No</span><br><span class="line">2 1 3 4</span><br></pre></td></tr></table></figure><ul><li>题意：已知给定一个二叉树的前中序序列或后中序遍历序列能唯一确定一棵二叉树。现在给定一棵二叉树的前序和后序遍历序列，判断能否复原一棵二叉树，或者如果存在多个满足条件的二叉树，则输出任意一个中序遍历序列。</li><li>分析：先拿先序遍历举例，根据先序遍历的递归特性，一棵二叉树的先序遍历序列总会被分为3个部分【根+左子树先序序列+右子树先序序列】，后序遍历序列正好相反【左子树后序序列+右子树后序序列+根】，因此实际上先序遍历的根，它的右边一个数的就是这棵树左子树的根，之后在后序序列中找到这个数temp，那么后序序列的第一个数到temp这个数为止就是这颗树的左子树，因此就能将左右子树划分出来了，那什么时候是不能确定的呢？就是上面找到的temp在后序遍历序列的倒数第二个位置时就是不能确定的，因为它既可以做左子树又可以做右子树。最后不确定情况全当做左子树或者右子树，这样最后就能至少确定一棵树了（如果存在）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> pre[N], post[N], n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ansIn;</span><br><span class="line"><span class="keyword">bool</span> isunique = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> prel, <span class="keyword">int</span> prer, <span class="keyword">int</span> postl, <span class="keyword">int</span> postr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prel &gt; prer) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (prel == prer) &#123;</span><br><span class="line">        ansIn.push_back(pre[prel]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = postl;</span><br><span class="line">    <span class="keyword">while</span> (post[k] != pre[prel + <span class="number">1</span>]) k++;</span><br><span class="line">    <span class="keyword">int</span> numRight = postr - k - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numRight == <span class="number">0</span>) isunique = <span class="literal">false</span>;</span><br><span class="line">    create(prel + <span class="number">1</span>, prer - numRight, postl, k);</span><br><span class="line">    ansIn.push_back(pre[prel]);</span><br><span class="line">    create(prer - numRight + <span class="number">1</span>, prer, k + <span class="number">1</span>, postr - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;post[i]);</span><br><span class="line">    create(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, isunique ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansIn.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ansIn[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1107 Social Clusters (30分) (并查集)</title>
      <link href="/2020/02/28/pat-A1107/"/>
      <url>/2020/02/28/pat-A1107/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805361586847744" target="_blank" rel="noopener">A1107 Social Clusters (30分)</a></p><p>When register on a social network, you are always asked to specify your hobbies in order to find some potential friends with the same hobbies. A <strong>social cluster</strong> is a set of people who have some of their hobbies in common. You are supposed to find all the clusters.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each test case, the first line contains a positive integer <em>N</em> (≤1000), the total number of people in a social network. Hence the people are numbered from 1 to <em>N</em>. Then <em>N</em> lines follow, each gives the hobby list of a person in the format:</p><p><em>Ki</em>: <em>hi</em>[1] <em>hi</em>[2] … <em>hi</em>[<em>Ki</em>]</p><p>where <em>Ki</em> (&gt;0) is the number of hobbies, and <em>hi</em>[<em>j</em>] is the index of the <em>j</em>-th hobby, which is an integer in [1, 1000].</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, print in one line the total number of clusters in the network. Then in the second line, print the numbers of people in the clusters in non-increasing order. The numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">3: 2 7 10</span><br><span class="line">1: 4</span><br><span class="line">2: 5 3</span><br><span class="line">1: 4</span><br><span class="line">1: 3</span><br><span class="line">1: 4</span><br><span class="line">4: 6 8 1 5</span><br><span class="line">1: 4</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4 3 1</span><br></pre></td></tr></table></figure><ul><li>题意：给出n个人的爱好，人物和爱好编号都为1到N，有同样爱好的人视作在一个群组，要求找出，这群人中有几个共同兴趣小组，输出群组数并按降序输出各组人数。</li><li>分析：需要用到并查集，同时，用<code>hobby</code>数组做哈希表标记谁有当前爱好，如果hobby是0则说明之前没记录过，需要记录一下，如果不为0，这找到其所在的群组，将当前的人合并到这个集合。之后遍历n个人，找到所有的群组并存到<code>unordered_map</code>中，再将结果转到vector中降序输出。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> father[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == father[x] ? x : father[x] = findFather(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span> (faA != faB) father[faA] = faB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) father[i] = i;</span><br><span class="line">    <span class="keyword">int</span> n, k, h, hobby[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d: "</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h);</span><br><span class="line">            <span class="keyword">if</span> (hobby[h] != <span class="number">0</span>) uni(i, findFather(hobby[h]));</span><br><span class="line">            <span class="keyword">else</span> hobby[h] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mp[findFather(i)]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : mp) ans.push_back(it.second);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans.size());</span><br><span class="line">    sort(ans.begin(), ans.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ans.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1103 Integer Factorization (30分) (DFS+剪枝)</title>
      <link href="/2020/02/28/pat-A1103/"/>
      <url>/2020/02/28/pat-A1103/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805364711604224" target="_blank" rel="noopener">A1103 Integer Factorization (30分)</a></p><p>The <em>K</em>−<em>P</em> factorization of a positive integer <em>N</em> is to write <em>N</em> as the sum of the <em>P</em>-th power of <em>K</em> positive integers. You are supposed to write a program to find the <em>K</em>−<em>P</em> factorization of <em>N</em> for any positive integers <em>N</em>, <em>K</em> and <em>P</em>.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case which gives in a line the three positive integers <em>N</em> (≤400), <em>K</em> (≤<em>N</em>) and <em>P</em> (1&lt;<em>P</em>≤7). The numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, if the solution exists, output in the format:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">N</span> = <span class="built_in">n</span>[<span class="number">1</span>]^P + ... <span class="built_in">n</span>[K]^P</span><br></pre></td></tr></table></figure><p>where <code>n[i]</code> (<code>i</code> = 1, …, <code>K</code>) is the <code>i</code>-th factor. All the factors must be printed in non-increasing order.</p><p>Note: the solution may not be unique. For example, the 5-2 factorization of 169 has 9 solutions, such as 12<sup>2</sup>+4<sup>2</sup>+2<sup>2</sup>+2<sup>2</sup>+1<sup>2</sup>, or 11<sup>2</sup>+6<sup>2</sup>+2<sup>2</sup>+2<sup>2</sup>+2<sup>2</sup>, or more. You must output the one with the maximum sum of the factors. If there is a tie, the largest factor sequence must be chosen – sequence { <em>a</em>1,<em>a</em>2,⋯,<em>aK</em> } is said to be <strong>larger</strong> than { <em>b</em>1,<em>b</em>2,⋯,<em>bK</em> } if there exists 1≤<em>L</em>≤<em>K</em> such that <em>ai</em>=<em>bi</em> for <em>i</em>&lt;<em>L</em> and <em>aL</em>&gt;<em>bL</em>.</p><p>If there is no solution, simple output <code>Impossible</code>.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">169 5 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">169 &#x3D; 6^2 + 6^2 + 6^2 + 6^2 + 5^2</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">169 167 3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Impossible</span><br></pre></td></tr></table></figure><ul><li>题意：整数因式分解，将一个整数N拆成K个数的P次方和，这里的P也是整数，如果找到符合的因数有多个则输出数字字典序较大的，例如 [10, 2, 1] 大于 [9, 9, 9]，因为第一个10大于9。</li><li>分析：本题考察DFS深度优先搜索，首先对于要满足的K的数的P次方和等于N，这所拆分的这几个数中最大的数要小于N，那么对于因子来说，它的P次方一样要小于N，因此在寻找这些数的时候，应该从N开P次方的数开始向下找，同时，题目要求输出满足结果中序列较大的那个，那么在DFS的时候就应该从可能的最大的数开始往下寻找。而在DFS时，存在两个分支，分别是当前数的选与不选，“死胡同”则是，当前记录的sum大于N、cntK大于K或者当前数X小于1时候，如果出现以上情况则返回。</li></ul><p>注意：DFS时因为总是要用pow函数重复计算某个数的P次幂，导致存在一个样例超时，所以需要在深搜前把可能用到的数的P次幂先计算出来，按照下标依次存储。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, p, maxFacSum = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp, ans, fac;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> sum, <span class="keyword">int</span> facSum, <span class="keyword">int</span> cntK)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">1</span> || sum &gt; n || cntK &gt; k) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum == n &amp;&amp; cntK == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (facSum &gt; maxFacSum) &#123;</span><br><span class="line">            ans = temp;</span><br><span class="line">            maxFacSum = facSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp.push_back(x);</span><br><span class="line">    dfs(x, sum + fac[x], facSum + x, cntK + <span class="number">1</span>);</span><br><span class="line">    temp.pop_back();</span><br><span class="line">    dfs(x - <span class="number">1</span>, sum, facSum, cntK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;p);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp &lt;= n) &#123;</span><br><span class="line">        fac.push_back(temp);</span><br><span class="line">        temp = <span class="built_in">pow</span>(++i, p);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs((<span class="keyword">int</span>)fac.size() - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans.size() == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d = "</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" + "</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d^%d"</span>, ans[i], p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1111 Online Map (30分) (Dijkstra最短路径算法)</title>
      <link href="/2020/02/27/pat-A1111/"/>
      <url>/2020/02/27/pat-A1111/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805358663417856" target="_blank" rel="noopener">A1111 Online Map (30分)</a></p><p>Input our current position and a destination, an online map can recommend several paths. Now your job is to recommend two paths to your user: one is the shortest, and the other is the fastest. It is guaranteed that a path exists for any request.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives two positive integers <em>N</em> (2≤<em>N</em>≤500), and <em>M</em>, being the total number of streets intersections on a map, and the number of streets, respectively. Then <em>M</em> lines follow, each describes a street in the format:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V1 V2 <span class="literal">one</span>-way <span class="built_in">length</span> <span class="built_in">time</span></span><br></pre></td></tr></table></figure><p>where <code>V1</code> and <code>V2</code> are the indices (from 0 to <em>N</em>−1) of the two ends of the street; <code>one-way</code> is 1 if the street is one-way from <code>V1</code> to <code>V2</code>, or 0 if not; <code>length</code> is the length of the street; and <code>time</code> is the time taken to pass the street.</p><p>Finally a pair of source and destination is given.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, first print the shortest path from the source to the destination with distance <code>D</code> in the format:</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D<span class="function"><span class="title">istance</span> = D: source -&gt;</span> <span class="function"><span class="title">v1</span> -&gt;</span> ... -&gt; destination</span><br></pre></td></tr></table></figure><p>Then in the next line print the fastest path with total time <code>T</code>:</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Time</span> = T: source -&gt; w1 -&gt; ... -&gt; destination</span><br></pre></td></tr></table></figure><p>In case the shortest path is not unique, output the fastest one among the shortest paths, which is guaranteed to be unique. In case the fastest path is not unique, output the one that passes through the fewest intersections, which is guaranteed to be unique.</p><p>In case the shortest and the fastest paths are identical, print them in one line in the format:</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Distance = D; <span class="keyword">Time</span> = T: source -&gt; u1 -&gt; ... -&gt; destination</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">10 15</span><br><span class="line">0 1 0 1 1</span><br><span class="line">8 0 0 1 1</span><br><span class="line">4 8 1 1 1</span><br><span class="line">3 4 0 3 2</span><br><span class="line">3 9 1 4 1</span><br><span class="line">0 6 0 1 1</span><br><span class="line">7 5 1 2 1</span><br><span class="line">8 5 1 2 1</span><br><span class="line">2 3 0 2 2</span><br><span class="line">2 1 1 1 1</span><br><span class="line">1 3 0 3 1</span><br><span class="line">1 4 0 1 1</span><br><span class="line">9 7 1 3 1</span><br><span class="line">5 1 0 5 2</span><br><span class="line">6 5 1 1 2</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Distance &#x3D; 6: 3 -&gt; 4 -&gt; 8 -&gt; 5</span><br><span class="line">Time &#x3D; 3: 3 -&gt; 1 -&gt; 5</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">7 9</span><br><span class="line">0 4 1 1 1</span><br><span class="line">1 6 1 1 3</span><br><span class="line">2 6 1 1 1</span><br><span class="line">2 5 1 2 2</span><br><span class="line">3 0 0 1 1</span><br><span class="line">3 1 1 1 3</span><br><span class="line">3 2 1 1 2</span><br><span class="line">4 5 0 2 2</span><br><span class="line">6 5 1 1 2</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Distance &#x3D; 3; Time &#x3D; 4: 3 -&gt; 2 -&gt; 5</span><br></pre></td></tr></table></figure><ul><li>题意：一张网络地图，给定起点和终点，找到距离最短和用时最少的路径，如果最短路径不唯一则找用时最短的，如果用时最少的路径不唯一则找顶点最少的。</li><li>分析：这题用两次Dijkstra算法就好了，根据题意把路径记录下来存在<code>dispre</code>和<code>timepre</code>中，之后递归输出路径结果，因为路径相等的情况下是一行输出，而且是用<code>vector</code>存的，所以直接用<code>==</code>比较是否相等即可。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N];</span><br><span class="line"><span class="keyword">int</span> n, m, st, dest, Dist[N][N], Time[N][N], d[N], t[N], num[N];</span><br><span class="line">vector&lt;int&gt; dispre(N), timepre(N), dispath, timepath;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstraDistance</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) dispre[i] = i;</span><br><span class="line">    fill(d, d + N, INF);</span><br><span class="line">    fill(t, t + N, INF);</span><br><span class="line">    d[s] = t[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> vis[N] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; d[i] &lt; MIN) &#123;</span><br><span class="line">                u = i;</span><br><span class="line">                MIN = d[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[u] + Dist[u][v] &lt; d[v]) &#123;</span><br><span class="line">                    d[v] = d[u] + Dist[u][v];</span><br><span class="line">                    t[v] = t[u] + Time[u][v];</span><br><span class="line">                    dispre[v] = u;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d[u] + Dist[u][v] == d[v] &amp;&amp; t[u] + Time[u][v] &lt; t[v]) &#123;</span><br><span class="line">                    t[v] = t[u] + Time[u][v];</span><br><span class="line">                    dispre[v] = u;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstraTime</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) timepre[i] = i;</span><br><span class="line">    fill(num, num + N, INF);</span><br><span class="line">    fill(t, t + N, INF);</span><br><span class="line">    num[s] = t[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> vis[N] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; t[i] &lt; MIN) &#123;</span><br><span class="line">                u = i;</span><br><span class="line">                MIN = t[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t[u] + Time[u][v] &lt; t[v]) &#123;</span><br><span class="line">                    t[v] = t[u] + Time[u][v];</span><br><span class="line">                    num[v] = num[u] + <span class="number">1</span>;</span><br><span class="line">                    timepre[v] = u;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t[u] + Time[u][v] == t[v] &amp;&amp; num[u] + <span class="number">1</span> &lt; num[v]) &#123;</span><br><span class="line">                    num[v] = num[u] + <span class="number">1</span>;</span><br><span class="line">                    timepre[v] = u;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == st) &#123;</span><br><span class="line">        path.push_back(u);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfsPath(pre, path, pre[u]);</span><br><span class="line">    path.push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" -&gt; "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, path[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> a, b, oneway, len, time;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;a, &amp;b, &amp;oneway, &amp;len, &amp;time);</span><br><span class="line">        e[a].push_back(b);</span><br><span class="line">        <span class="keyword">if</span> (oneway == <span class="number">0</span>) e[b].push_back(a);</span><br><span class="line">        Dist[a][b] = Dist[b][a] = len;</span><br><span class="line">        Time[a][b] = Time[b][a] = time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;st, &amp;dest);</span><br><span class="line">    dijkstraDistance(st);</span><br><span class="line">    dijkstraTime(st);</span><br><span class="line">    dfsPath(dispre, dispath, dest);</span><br><span class="line">    dfsPath(timepre, timepath, dest);</span><br><span class="line">    <span class="keyword">if</span> (dispath == timepath) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Distance = %d; Time = %d: "</span>, d[dest], t[dest]);</span><br><span class="line">        printPath(dispath);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Distance = %d: "</span>, d[dest]);</span><br><span class="line">        printPath(dispath);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Time = %d: "</span>, t[dest]);</span><br><span class="line">        printPath(timepath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> Dijkstra最短路径算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1123 Is It a Complete AVL Tree (30分) (完全AVL树判定)</title>
      <link href="/2020/02/26/pat-A1123/"/>
      <url>/2020/02/26/pat-A1123/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805351302414336" target="_blank" rel="noopener">A1123 Is It a Complete AVL Tree (30分)</a></p><p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.</p><table><thead><tr><th><img src="https://images.ptausercontent.com/fb337acb-93b0-4af2-9838-deff5ce98058.jpg" alt="F1.jpg"></th><th><img src="https://images.ptausercontent.com/d1635de7-3e3f-4aaa-889b-ba29f35890db.jpg" alt="F2.jpg"></th></tr></thead><tbody><tr><td><img src="https://images.ptausercontent.com/e868e4b9-9fea-4f70-b7a7-1f5d8a3be4ef.jpg" alt="F3.jpg"></td><td><img src="https://images.ptausercontent.com/98aa1782-cea5-4792-8736-999436cf43a9.jpg" alt="F4.jpg"></td></tr></tbody></table><p>Now given a sequence of insertions, you are supposed to output the level-order traversal sequence of the resulting AVL tree, and to tell if it is a complete binary tree.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤ 20). Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, insert the keys one by one into an initially empty AVL tree. Then first print in a line the level-order traversal sequence of the resulting AVL tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Then in the next line, print <code>YES</code> if the tree is complete, or <code>NO</code> if not.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">88 70 61 63 65</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">70 63 88 61 65</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">88 70 61 96 120 90 65 68</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">88 65 96 61 70 90 120 68</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><ul><li>题意：给定插入结点的顺序，将其构建成平衡二叉树，输出这棵AVL树的层序遍历序列，并判断这棵树是不是完全二叉树。</li><li>分析：这题考察的是AVL树的构建和以及完全二叉树的判定。</li></ul><ol start="0"><li>AVL本身是二叉搜索树，为了防止出现一边倒的情况，在插入结点到二叉搜索树的同时，对这棵树做相应调整，使这棵树的任意子树均保持左右子树高度差不超过1的特性。</li><li>对树的调整有4种形态。FIgure1所示，则直接从根节点右旋即可；Figure2所示，则是以88为根的结点需要左旋，而根结点70不需要调整；Figure3所示，则是先将以96为根的子树做右旋，把它调整为右侧较重的形状，之后对70为根的树左旋，刚好又能变得平衡；Figure4则是对以70为根的子树做右旋。</li><li>AVL树构建完成后，层序遍历则是BFS这棵树就行了，这里还要解决问题的是在层序遍历的同时对其是否为完全二叉树做判断。因为这里事先就知道这棵树的结点数了，在对结点做输出的时候，每输出一个结点，cnt就会加1，这里对任意非叶子结点不管其左右孩子谁为空，都将其放进队列中，那么如果是完全二叉树，在遍历的过程中，即cnt未到达n的时队列中一定不会出现NULL元素，由此便可判断其是否为完全二叉树了。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data, height;</span><br><span class="line">    node *left, *right;</span><br><span class="line">    node(<span class="keyword">int</span> x) : data(x) &#123;</span><br><span class="line">        height = <span class="number">1</span>;</span><br><span class="line">        left = right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(node *root)</span> </span>&#123;</span><br><span class="line">    root-&gt;height = max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getHeight(root-&gt;left) - getHeight(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L</span><span class="params">(node *&amp;root)</span> </span>&#123;</span><br><span class="line">    node *temp = root-&gt;right;</span><br><span class="line">    root-&gt;right = temp-&gt;left;</span><br><span class="line">    temp-&gt;left = root;</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">(node *&amp;root)</span> </span>&#123;</span><br><span class="line">    node *temp = root-&gt;left;</span><br><span class="line">    root-&gt;left = temp-&gt;right;</span><br><span class="line">    temp-&gt;right = root;</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node *&amp;root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> node(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; root-&gt;data) &#123;</span><br><span class="line">        insert(root-&gt;left, x);</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        <span class="keyword">if</span> (getBalanceFactor(root) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getBalanceFactor(root-&gt;left) == <span class="number">-1</span>) L(root-&gt;left);</span><br><span class="line">            R(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insert(root-&gt;right, x);</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        <span class="keyword">if</span> (getBalanceFactor(root) == <span class="number">-2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getBalanceFactor(root-&gt;right) == <span class="number">1</span>) R(root-&gt;right);</span><br><span class="line">            L(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(node *root, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node *&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">int</span> iscbt = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        node *now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; n &amp;&amp; now == <span class="literal">NULL</span>) iscbt = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (now) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, now-&gt;data);</span><br><span class="line">            <span class="keyword">if</span> (++cnt &lt; n) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            q.push(now-&gt;left);</span><br><span class="line">            q.push(now-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n%s"</span>, iscbt ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    node *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">        insert(root, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    bfs(root, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 平衡二叉树 </tag>
            
            <tag> AVL </tag>
            
            <tag> 完全二叉树 </tag>
            
            <tag> 完全平衡二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python实现博客站点url实时推送至百度与Linux定时任务</title>
      <link href="/2020/02/26/hexo-baidu-activepush/"/>
      <url>/2020/02/26/hexo-baidu-activepush/</url>
      
        <content type="html"><![CDATA[<p>之前写过一篇关于<a href="https://blog.charjin.top/2020/02/05/hexo-site-autopush/">【Hexo】maupassant 主题设置百度站点自动推送</a> 的博客</p><p>这种自动推送的方式也只有在页面受访时才会被提交至百度，只可惜百度对个人博客url的收录速度确实无法跟Google比呀，因此编写Python脚本通过站点的 <strong>sitemap.xml</strong> 与Linux定时任务实现 <strong>主动推送</strong> 的自动化。具体步骤如下：</p><h1 id="链接提交方式的对比"><a href="#链接提交方式的对比" class="headerlink" title="链接提交方式的对比"></a>链接提交方式的对比</h1><p>可转至 <a href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=2#h2_article_title9" target="_blank" rel="noopener">https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=2#h2_article_title9</a> ，百度搜索资源平台查看链接提交方式的效果差异：</p><ul><li>主动推送：最为 <strong>快速</strong> 的提交方式，建议您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。</li><li>sitemap： 您可以定期将网站链接放到Sitemap中，然后将Sitemap提交给百度。百度会周期性的抓取检查您提交的Sitemap，对其中的链接进行处理，但收录速度慢于主动推送。</li><li>手工提交：如果您不想通过程序提交，那么可以采用此种方式，手动将链接提交给百度。</li><li>自动推送：是轻量级链接提交组件，将自动推送的JS代码放置在站点每一个页面源代码中，当页面被访问时，页面链接会自动推送给百度，有利于新页面更快被百度发现。</li></ul><p>对于以上的sitemap与自动推送方式，此前博主已设置过该方式，但链接提交速度还是不如主动推送。</p><h1 id="个人博客生成sitemap站点地图"><a href="#个人博客生成sitemap站点地图" class="headerlink" title="个人博客生成sitemap站点地图"></a>个人博客生成sitemap站点地图</h1><p>首先，引用百度关于主动推动的相关格式：</p><blockquote><h3 id="推送接口"><a href="#推送接口" class="headerlink" title="推送接口"></a>推送接口</h3><p>接口调用地址：<a href="http://data.zz.baidu.com/urls?site=个人博客地址&amp;token=每个站长有唯一的标识" target="_blank" rel="noopener">http://data.zz.baidu.com/urls?site=个人博客地址&amp;token=每个站长有唯一的标识</a></p><table><thead><tr><th align="left">参数名称</th><th align="left">是否必选</th><th align="left">参数类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">site</td><td align="left">是</td><td align="left">string</td><td align="left">在搜索资源平台验证的站点，比如<a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a></td></tr><tr><td align="left">token</td><td align="left">是</td><td align="left">string</td><td align="left">在搜索资源平台申请的推送用的准入密钥</td></tr></tbody></table><h3 id="推送示例"><a href="#推送示例" class="headerlink" title="推送示例"></a>推送示例</h3><ul><li><p>curl推送示例</p></li><li><p><strong>将要提交的链接按照每行一条的格式写入一个文本文件中，命名此文件为urls.txt，然后进入该文件所在目录，执行如下命令：</strong></p><p>curl -H ‘Content-Type:text/plain’ –data-binary @urls.txt “<a href="http://data.zz.baidu.com/urls?site=个人博客地址&amp;token=每个站长有唯一的标识&quot;" target="_blank" rel="noopener">http://data.zz.baidu.com/urls?site=个人博客地址&amp;token=每个站长有唯一的标识&quot;</a></p></li></ul></blockquote><p>这里要求编写一个 <strong>urls.txt</strong> 文件存放我们想要提交的url。自己手动输入url是件很麻烦的事，因此想到不如从sitemap中提取所有站点url。</p><p>来访搭建了个人博客的博主应该都知道怎么生成sitemap，这里还是简要说明一下，以 <strong>Hexo</strong> 博客框架举例，在博客根目录执行以下代码安装sitemap生成插件：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>之后编辑Hexo博客根目录下的 <strong>_config.yml</strong> 文件，添加如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure><p>安装sitemap生成插件，部署站点后，通过 <strong>https://<u>你的博客url/sitemap.xml</u></strong> 即可访问到 sitemap.xml。</p><h1 id="通过Python提取urls并写入文件"><a href="#通过Python提取urls并写入文件" class="headerlink" title="通过Python提取urls并写入文件"></a>通过Python提取urls并写入文件</h1><p>现在已生成了sitemap，要做的就是将其中所有的url解析出来写入到某个urls.txt文件中。之后再按照百度的要求执行curl命令即可。</p><p>使用到的第三方Python库：Requests</p><p>在Linux环境下（CentOS）需要执行以下代码安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install python3# 如果没有python则需要先安装</span><br><span class="line">sudo pip3 install requests# 安装 requests 库</span><br></pre></td></tr></table></figure><ul><li>代码相关说明： 务必在执行前，修改以下代码中的<code>blog_url</code>和<code>token</code>两个变量，其中<code>token</code>需要先到百度站长中心添加自己的网站才能获取。</li><li>代码基本思路：<ol start="0"><li>通过 <strong>requests</strong> 库将个人站点sitemap中的urls解析出来并到用户目录下的 <strong>urls.txt</strong> 文件中</li><li>通过 <strong>os</strong> 库执行命令，将命令执行后的输出按行写入到用户目录下的 <strong>submit_log.txt</strong> 文件中，以保存作为链接的提交日志。同时记录提交的次数和时间。</li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> et</span><br><span class="line"></span><br><span class="line"><span class="comment"># 务必设定以下两项配置</span></span><br><span class="line">blog_url = <span class="string">'你的博客地址'</span>  <span class="comment"># e.g: blog.charjin.top (不添加http或https)</span></span><br><span class="line">token = <span class="string">'百度搜索资源申请推送的准入密钥'</span> <span class="comment"># e.g: QfemDubDm5aArbp1 (在此处查看https://ziyuan.baidu.com/linksubmit)</span></span><br><span class="line"></span><br><span class="line">userdir = os.path.expanduser(<span class="string">'~'</span>)   <span class="comment"># 获取用户目录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取sitemap.xml提取url写至本地文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseSitemapToFile</span><span class="params">(sitemap_url)</span>:</span></span><br><span class="line">    r = requests.get(sitemap_url)</span><br><span class="line">    r.encoding = <span class="string">'utf-8'</span></span><br><span class="line">    urlset = et.fromstring(r.text)  <span class="comment"># sitemap根元素为urlset</span></span><br><span class="line"></span><br><span class="line">    file = open(userdir + <span class="string">'/urls.txt'</span>, <span class="string">'w'</span>)  <span class="comment"># 写的形式打开文件, 不存在则自动创建</span></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urlset:</span><br><span class="line">        file.write(url[<span class="number">0</span>].text + <span class="string">'\n'</span>)  <span class="comment"># 逐行写入链接</span></span><br><span class="line">    file.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parseSitemapToFile(<span class="string">'https://%s/sitemap.xml'</span> % blog_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建命令</span></span><br><span class="line">cmd = <span class="string">'curl -H \'Content-Type:text/plain\' --data-binary @%s/urls.txt \</span></span><br><span class="line"><span class="string">"http://data.zz.baidu.com/urls?site=%s&amp;token=%s"'</span> % (userdir, blog_url, token)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令并获取输出结果</span></span><br><span class="line">cmt_output = os.popen(cmd).readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取原文件行数便于追加记录, 如果不存在则初始化为0</span></span><br><span class="line">cnt_line = <span class="number">0</span> <span class="keyword">if</span> os.path.exists(userdir + <span class="string">'/submit_log.txt'</span>) == <span class="literal">False</span> <span class="keyword">else</span> len(</span><br><span class="line">    open(userdir + <span class="string">'/submit_log.txt'</span>, <span class="string">'r'</span>).readlines())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前时间用于日志记录</span></span><br><span class="line">current_time = time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以append形式打开文件</span></span><br><span class="line">file_log = open(userdir + <span class="string">'/submit_log.txt'</span>, <span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按格式和序号将提交日志写入文件</span></span><br><span class="line">file_log.write(str(cnt_line + <span class="number">1</span>) + <span class="string">'. '</span> + current_time + <span class="string">' - result: '</span> + cmt_output[<span class="number">0</span>] + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">file_log.close()</span><br></pre></td></tr></table></figure><h1 id="通过Linux服务器执行定时任务"><a href="#通过Linux服务器执行定时任务" class="headerlink" title="通过Linux服务器执行定时任务"></a>通过Linux服务器执行定时任务</h1><p>既然有个人站点，必定是已购买了个人服务器的，所以应充分发挥服务器的作用，哈哈。</p><p>仅以CentOS举例：</p><ul><li>将在本地写好的python代码（此处文件名为 activepush.py ）复制到服务器的用户目录之下：（也可在服务器中直接编辑创建）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp activepush.py 服务器名:~/</span><br></pre></td></tr></table></figure><ul><li>假设是以 <strong>root</strong> 用户登录的，现在cd至<code>/etc/cron.daily</code>目录下，实际上通过tab补全可以看到有多个cron的目录。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/cron.</span><br><span class="line">cron.d/        cron.daily/    cron.hourly/   cron.monthly/  cron.weekly/</span><br></pre></td></tr></table></figure><p>这里不同目录下分别存放的是每天、每周、每小时等等执行的脚本文件。因此进入<code>/etc/cron.hourly</code>目录后，通过vim在其中创建shell脚本文件: <code>vim activepush</code>，在该文件中输入以下命令，之后 <code>:qw</code>退出并保存。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 存放python代码的目录/activepush.py</span><br></pre></td></tr></table></figure><ul><li>最后要让创建的shell脚本可执行，通过chmod修改权限（为了方便设为对所有用户都可执行）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod a+x activepush</span><br></pre></td></tr></table></figure><p>OK，最后昨天凌晨挂上去的，现在查看一下日志文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@server-char]~# cat urls.txt</span><br><span class="line">https://blog.charjin.top/2020/02/25/PAT-A1131/</span><br><span class="line">https://blog.charjin.top/2020/02/25/PAT-A1127/</span><br><span class="line">https://blog.charjin.top/2020/02/24/pat-A1135/</span><br><span class="line">....一共有55条...这里省略了</span><br><span class="line"></span><br><span class="line">[root@server-char]~# cat submit_log.txt</span><br><span class="line">1. 2020-02-26 02:01:04 - result: &#123;"remain":99065,"success":55&#125;</span><br><span class="line">2. 2020-02-26 03:01:01 - result: &#123;"remain":99010,"success":55&#125;</span><br><span class="line">3. 2020-02-26 04:01:05 - result: &#123;"remain":98955,"success":55&#125;</span><br><span class="line">4. 2020-02-26 05:01:05 - result: &#123;"remain":98900,"success":55&#125;</span><br><span class="line">5. 2020-02-26 06:01:06 - result: &#123;"remain":98845,"success":55&#125;</span><br><span class="line">6. 2020-02-26 07:01:05 - result: &#123;"remain":98790,"success":55&#125;</span><br><span class="line">7. 2020-02-26 08:01:03 - result: &#123;"remain":98735,"success":55&#125;</span><br><span class="line">8. 2020-02-26 09:01:04 - result: &#123;"remain":98680,"success":55&#125;</span><br><span class="line">9. 2020-02-26 10:01:05 - result: &#123;"remain":98625,"success":55&#125;</span><br><span class="line">10. 2020-02-26 11:01:04 - result: &#123;"remain":98460,"success":55&#125;</span><br></pre></td></tr></table></figure><p>每小时提交一次，一共提交10次了，这里remain是百度说每日剩余可提交的url数量，但是似乎是每天10万条，怎么提交也不会超过。</p><p>现在我的站点将主动推送也自动化了，集结了主动推送、自动推送以及sitemap自动抓取，这回还不努力收录我的urls，我真要对百度失望了。</p><p>最后，似乎完成对全站的https认证才能提高链接的收录几率。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
            <tag> 站点url自动推送 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1127 ZigZagging on a Tree (30分) (不建树)</title>
      <link href="/2020/02/25/pat-A1127/"/>
      <url>/2020/02/25/pat-A1127/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805349394006016" target="_blank" rel="noopener">A1127 ZigZagging on a Tree (30分)</a></p><p>Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences. And it is a simple standard routine to print the numbers in level-order. However, if you think the problem is too simple, then you are too naive. This time you are supposed to print the numbers in “zigzagging order” – that is, starting from the root, print the numbers level-by-level, alternating between left to right and right to left. For example, for the following tree you must output: 1 11 5 8 17 12 20 15.</p><p><img src="https://images.ptausercontent.com/337cbfb0-a7b2-4500-9664-318e9ffc870e.jpg" alt="zigzag.jpg"></p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the inorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the zigzagging sequence of the tree in a line. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">12 11 20 17 1 15 8 5</span><br><span class="line">12 20 17 11 15 8 5 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 11 5 8 17 12 20 15</span><br></pre></td></tr></table></figure><ul><li>题意：给一个二叉树的后序和中序遍历序列，要求输出这棵树的 “Z” 字形遍历序列。</li><li>分析：这题不需要建树，只用在二叉树中后序序列建树方法的基础上加上<code>depth</code>参数用以记录深度即可，然后通过<code>vector</code>数组依次记录每一层的结点，因为无论前中后遍历二叉树的访问序列都是从上至下从左至右，所以push进<code>vector[层数]</code>同样是按照同一层结点间的顺序的，因此该方式可行，同时在建树方法中记录下出现的最大层数。为了方便记录（其实也差不多），第一层的depth被记为0。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> post[N], in[N], maxDepth = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> postl, <span class="keyword">int</span> postr, <span class="keyword">int</span> inl, <span class="keyword">int</span> inr, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (postl &gt; postr) <span class="keyword">return</span>;</span><br><span class="line">    maxDepth = max(maxDepth, depth);</span><br><span class="line">    ans[depth].push_back(post[postr]);</span><br><span class="line">    <span class="keyword">int</span> k = inl;</span><br><span class="line">    <span class="keyword">while</span> (k &lt;= inr &amp;&amp; in[k] != post[postr]) k++;</span><br><span class="line">    <span class="keyword">int</span> numleft = k - inl;</span><br><span class="line">    create(postl, postl + numleft - <span class="number">1</span>, inl, k - <span class="number">1</span>, depth + <span class="number">1</span>);</span><br><span class="line">    create(postl + numleft, postr - <span class="number">1</span>, k + <span class="number">1</span>, inr, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;in[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;post[i]);</span><br><span class="line">    create(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxDepth; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) reverse(ans[i].begin(), ans[i].end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : ans[i]) <span class="built_in">printf</span>(<span class="string">" %d"</span>, it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> PAT </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1131 Subway Map (30分) (DFS深度优先搜索+剪枝)</title>
      <link href="/2020/02/25/pat-A1131/"/>
      <url>/2020/02/25/pat-A1131/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805347523346432" target="_blank" rel="noopener">A1131 Subway Map (30分)</a></p><p>In the big cities, the subway systems always look so complex to the visitors. To give you some sense, the following figure shows the map of Beijing subway. Now you are supposed to help people with your computer skills! Given the starting position of your user, your task is to find the quickest way to his/her destination.</p><p><img src="https://images.ptausercontent.com/55799c23-4bdb-4e32-af7f-6d41accfdd2b.jpg" alt=""></p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤ 100), the number of subway lines. Then <em>N</em> lines follow, with the <em>i</em>-th (<em>i</em>=1,⋯,<em>N</em>) line describes the <em>i</em>-th subway line in the format:</p><p><em>M</em> S[1] S[2] … S[<em>M</em>]</p><p>where <em>M</em> (≤ 100) is the number of stops, and S[<em>i</em>]’s (<em>i</em>=1,⋯,<em>M</em>) are the indices of the stations (the indices are 4-digit numbers from 0000 to 9999) along the line. It is guaranteed that the stations are given in the correct order – that is, the train travels between S[<em>i</em>] and S[<em>i</em>+1] (<em>i</em>=1,⋯,<em>M</em>−1) without any stop.</p><p>Note: It is possible to have loops, but not self-loop (no train starts from S and stops at S without passing through another station). Each station interval belongs to a unique subway line. Although the lines may cross each other at some stations (so called “transfer stations”), no station can be the conjunction of more than 5 lines.</p><p>After the description of the subway, another positive integer <em>K</em> (≤ 10) is given. Then <em>K</em> lines follow, each gives a query from your user: the two indices as the starting station and the destination, respectively.</p><p>The following figure shows the sample map.</p><p><img src="https://images.ptausercontent.com/932c8f1b-7dd5-489d-a774-a91c1fabba7f.jpg" alt=""></p><p>Note: It is guaranteed that all the stations are reachable, and all the queries consist of legal station numbers.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each query, first print in a line the minimum number of stops. Then you are supposed to show the optimal path in a friendly format as the following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Take Line#X1 from S1 to S2.</span><br><span class="line">Take Line#X2 from S2 to S3.</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>where <code>X</code><em>i</em>‘s are the line numbers and <code>S</code><em>i</em>‘s are the station indices. Note: Besides the starting and ending stations, only the transfer stations shall be printed.</p><p>If the quickest path is not unique, output the one with the minimum number of transfers, which is guaranteed to be unique.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">7 1001 3212 1003 1204 1005 1306 7797</span><br><span class="line">9 9988 2333 1204 2006 2005 2004 2003 2302 2001</span><br><span class="line">13 3011 3812 3013 3001 1306 3003 2333 3066 3212 3008 2302 3010 3011</span><br><span class="line">4 6666 8432 4011 1306</span><br><span class="line">3</span><br><span class="line">3011 3013</span><br><span class="line">6666 2001</span><br><span class="line">2004 3001</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">Take Line#3 from 3011 to 3013.</span><br><span class="line">10</span><br><span class="line">Take Line#4 from 6666 to 1306.</span><br><span class="line">Take Line#3 from 1306 to 2302.</span><br><span class="line">Take Line#2 from 2302 to 2001.</span><br><span class="line">6</span><br><span class="line">Take Line#2 from 2004 to 1204.</span><br><span class="line">Take Line#1 from 1204 to 1306.</span><br><span class="line">Take Line#3 from 1306 to 3001.</span><br></pre></td></tr></table></figure><ul><li>题意：给了一张地铁图，对任意给定的起点和终点，找到一条乘车方案，使行经站最少，如果有多个路线符合则输出换乘最少的（题目保证这是唯一的）。</li><li>分析：这题实际上是个纸老虎，考察的是图的DFS，但是有不少需要注意的点（坑）。</li></ul><p>主要有以下几步：</p><ol start="0"><li>用什么方式表示这张图。因为题目中图的编号不是连续的，而且每个顶点的编号是四位数，所以这里要选用邻接表来存储图。</li><li>怎么找到路径并剪枝。如果只是用图的DFS遍历的话，那只能找到一条从起点到终点的路径，因为每个顶点只访问一次。首先这里铁路图肯定是连通图，之后，原来深度优先搜索的算法是走到哪个顶点就把那个点标记为已访问过，所以额外要改动的就是从某个顶点递归的DFS后再重新把这个点标记为可访问即可。同时，在DFS寻找所有路径的时候，为了适当缩短查找时间在DFS时添加<code>cntStop</code>参数记录当前结点的深度（实际上就是搭乘的站数），如果已经超过了之前记录的最小站数则提前退出，这一步是剪枝。</li><li>怎么计算换乘次数。要知道是否换乘就要知道乘车过程中线路是不是发生了改变，因为相邻的两个点肯定会在一条线路上，所以读入数据的时候需要保存相邻两点的线路编号，起初想法是用二维数组记录线路，但是如果是换乘点则至少会在两条线路上，所以使用哈希表通过 <strong>编号1 * 10000 + 编号2</strong> 作为键来标记这两点间的线路，同时从编号2到编号1亦需标记。之后计算换乘次数则先用<code>preline</code>变量记录初始的线路，随后从第二站开始遍历路径，如果发现线路改变则<code>cnt</code>加1，同时更新<code>preline</code>。</li><li>最后输出时，要求的只输出起点、换乘站和终点，因此思路和之前计算换乘次数是一致的，也是用<code>preline</code>先记录最开始的线路，同时这里还要用是<code>preStop</code>记录上一个输出的换乘站，最后还要输出最后一个换乘站到终点的记录就好了。</li></ol><p>注意点：起初在dfs中判断是否更新最少乘车站时，如果乘车站数比之前记录的还要少，除了要更新最少乘车站数，也要把最少换乘数更新成当前这条线路的换乘数，因为乘车站数是第一尺标，换乘站是跟着它一起的呀，最开始没有更新，虽然只有两个测试点没过，但只有10分 ~_~！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, st, dest, minCntStop, minCntTransfer;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; line;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N], path, tempPath;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTransferCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preline = line[v[<span class="number">0</span>] * <span class="number">10000</span> + v[<span class="number">1</span>]], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nowline = line[v[i] * <span class="number">10000</span> + v[i + <span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">if</span> (nowline != preline) &#123;</span><br><span class="line">            preline = nowline;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> cntStop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cntStop &gt; minCntStop) <span class="keyword">return</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    tempPath.push_back(u);</span><br><span class="line">    <span class="keyword">if</span> (u == dest) &#123;</span><br><span class="line">        <span class="keyword">int</span> cntTransfer = getTransferCount(tempPath);</span><br><span class="line">        <span class="keyword">if</span> (cntStop &lt; minCntStop || cntTransfer &lt; minCntTransfer) &#123;</span><br><span class="line">            minCntTransfer = cntTransfer;</span><br><span class="line">            minCntStop = cntStop;</span><br><span class="line">            path = tempPath;</span><br><span class="line">        &#125;</span><br><span class="line">        tempPath.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> next : e[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[next]) &#123;</span><br><span class="line">            dfs(next, cntStop + <span class="number">1</span>);</span><br><span class="line">            vis[next] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preStop, stop;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;preStop);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;stop);</span><br><span class="line">            e[preStop].push_back(stop);</span><br><span class="line">            e[stop].push_back(preStop);</span><br><span class="line">            line[preStop * <span class="number">10000</span> + stop] = line[stop * <span class="number">10000</span> + preStop] = i;</span><br><span class="line">            preStop = stop;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;st, &amp;dest);</span><br><span class="line">        tempPath.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        minCntStop = minCntTransfer = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        fill(vis, vis + N, <span class="literal">false</span>);</span><br><span class="line">        dfs(st, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, path.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> preline = line[path[<span class="number">0</span>] * <span class="number">10000</span> + path[<span class="number">1</span>]], preStop = path[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; path.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nowline = line[path[i] * <span class="number">10000</span> + path[i + <span class="number">1</span>]];</span><br><span class="line">            <span class="keyword">if</span> (nowline != preline) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Take Line#%d from %04d to %04d.\n"</span>, preline, preStop, path[i]);</span><br><span class="line">                preline = nowline;</span><br><span class="line">                preStop = path[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Take Line#%d from %04d to %04d.\n"</span>, preline, preStop, dest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> DFS </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1135 Is It A Red-Black Tree (30分) (DFS深度优先搜索)</title>
      <link href="/2020/02/24/pat-A1135/"/>
      <url>/2020/02/24/pat-A1135/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805346063728640" target="_blank" rel="noopener">A1135 Is It A Red-Black Tree (30分)</a></p><p>There is a kind of balanced binary search tree named <strong>red-black tree</strong> in the data structure. It has the following 5 properties:</p><ul><li>(1) Every node is either red or black.</li><li>(2) The root is black.</li><li>(3) Every leaf (NULL) is black.</li><li>(4) If a node is red, then both its children are black.</li><li>(5) For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.</li></ul><p>For example, the tree in Figure 1 is a red-black tree, while the ones in Figure 2 and 3 are not.</p><table><thead><tr><th align="center"><img src="https://images.ptausercontent.com/eff80bd4-c833-4818-9786-81680d1b304a.jpg" alt=""></th><th align="center"><img src="https://images.ptausercontent.com/b11184df-eaab-451c-b7d4-7fc1dc82b028.jpg" alt=""></th><th align="center"><img src="https://images.ptausercontent.com/625c532b-22fc-47b9-80ea-0537cf00d922.jpg" alt=""></th></tr></thead><tbody><tr><td align="center">Figure 1</td><td align="center">Figure 2</td><td align="center">Figure 3</td></tr></tbody></table><p>For each given binary search tree, you are supposed to tell if it is a legal red-black tree.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains several test cases. The first line gives a positive integer K (≤30) which is the total number of cases. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the preorder traversal sequence of the tree. While all the keys in a tree are positive integers, we use negative signs to represent red nodes. All the numbers in a line are separated by a space. The sample input cases correspond to the trees shown in Figure 1, 2 and 3.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in a line “Yes” if the given tree is a red-black tree, or “No” if not.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">9</span><br><span class="line">7 -2 1 5 -4 -11 8 14 -15</span><br><span class="line">9</span><br><span class="line">11 -2 1 -7 5 -4 8 14 -15</span><br><span class="line">8</span><br><span class="line">10 -7 5 -6 8 15 -11 17</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure><ul><li><p>题意：题目给出了红黑树的定义：</p><ul><li>（1）每个节点都是红色或黑色。</li><li>（2）根是黑色的。</li><li>（3）每片叶子（NULL）是黑色的。</li><li>（4）如果节点为红色，则其两个子节点均为黑色。</li><li>（5）对于每个节点，从节点到后代叶子的所有简单路径都包含相同数量的黑色节点。</li></ul><p>通过红黑树的定义判断给出的二叉搜索树是不是红黑树；所有结点值都是正整数，用正负号表示颜色（负号为红色）。</p></li><li><p>分析：这道题实际上考察的不是红黑树，要不然甲级就超纲啦，哈哈。题目给了二叉搜索树的先序遍历序列，先根据BST的特性建树（链式存储）。之后判断，如果根是红色则不是红黑树，否则就从根节点开始深度优先，在途中如果发现某个结点是红色，其孩子也出现红色，则把 <code>isrbt</code>标记为false，同时传入参数cnt记录从根节点到叶子结点上黑色结点的个数，当到达递归边界的时候（即空结点）判断从根节点到当前位置上的黑色结点数cnt是不是和之前记录过的cntBlack相等，如果不等则标记<code>isrbt</code>为false，但如果之前没记录过cntBlack（即cntBlack为-1）则不作判断。</p></li></ul><p>注意：1. 插入结点时，传入的root需要使用引用类型。2. 因为有多个序列要判断，所以每次DFS前都要重置<code>isrbt</code>和<code>cntBlack</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    node *left, *right;</span><br><span class="line">    node(<span class="keyword">int</span> x) : data(x) &#123; left = right = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> node(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(x) &lt; <span class="built_in">abs</span>(root-&gt;data)) insert(root-&gt;left, x);</span><br><span class="line">    <span class="keyword">else</span> insert(root-&gt;right, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> isrbt;</span><br><span class="line"><span class="keyword">int</span> cntBlack = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(node* root, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cntBlack == <span class="number">-1</span>) cntBlack = cnt;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cntBlack != cnt) isrbt = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;data &lt; <span class="number">0</span>) isrbt = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span> &amp;&amp; root-&gt;right-&gt;data &lt; <span class="number">0</span>) isrbt = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root-&gt;left, root-&gt;data &gt; <span class="number">0</span> ? cnt + <span class="number">1</span> : cnt);</span><br><span class="line">    dfs(root-&gt;right, root-&gt;data &gt; <span class="number">0</span> ? cnt + <span class="number">1</span> : cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k, n, x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        node* root = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            insert(root, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;data &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            isrbt = <span class="literal">true</span>;</span><br><span class="line">            cntBlack = <span class="number">-1</span>;</span><br><span class="line">            dfs(root, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, isrbt ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 红黑树的判别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1143 Lowest Common Ancestor (30分)</title>
      <link href="/2020/02/24/pat-A1143/"/>
      <url>/2020/02/24/pat-A1143/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805343727501312" target="_blank" rel="noopener">A1143 Lowest Common Ancestor (30分)</a></p><p>The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants.</p><p>A binary search tree (BST) is recursively defined as a binary tree which has the following properties:</p><ul><li>The left subtree of a node contains only nodes with keys less than the node’s key.</li><li>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p>Given any two nodes in a BST, you are supposed to find their LCA.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 1,000), the number of pairs of nodes to be tested; and N (≤ 10,000), the number of keys in the BST, respectively. In the second line, N distinct integers are given as the preorder traversal sequence of the BST. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of <strong>int</strong>.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each given pair of U and V, print in a line <code>LCA of U and V is A.</code> if the LCA is found and <code>A</code> is the key. But if <code>A</code> is one of U and V, print <code>X is an ancestor of Y.</code> where <code>X</code> is <code>A</code> and <code>Y</code> is the other node. If U or V is not found in the BST, print in a line <code>ERROR: U is not found.</code> or <code>ERROR: V is not found.</code> or <code>ERROR: U and V are not found.</code>.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">6 8</span><br><span class="line">6 3 1 2 5 4 8 7</span><br><span class="line">2 5</span><br><span class="line">8 7</span><br><span class="line">1 9</span><br><span class="line">12 -3</span><br><span class="line">0 8</span><br><span class="line">99 99</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LCA of 2 and 5 is 3.</span><br><span class="line">8 is an ancestor of 7.</span><br><span class="line">ERROR: 9 is not found.</span><br><span class="line">ERROR: 12 and -3 are not found.</span><br><span class="line">ERROR: 0 is not found.</span><br><span class="line">ERROR: 99 and 99 are not found.</span><br></pre></td></tr></table></figure><ul><li>题意：给一个二叉搜索树的先序遍历序列，给出任意两结点值找到其最低公共祖先。</li><li>分析：根据二叉搜索树的特性，按照题目中的定义，其根结点总是大于左子树的所有结点，且总大于或等于其右子树的所有结点。那么在寻找a、b结点的最低公共祖先时候可以遍历这棵树的所有结点，找到其值介于a、b之间（可等）的结点即可，因为给出的结点可能并不存在于树中，所以在读入先序序列的时候可以先对树中的结点做标记。之后如果不存在该结点便可直接判断。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pre</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; exist;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre[i]);</span><br><span class="line">        exist[pre[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (!exist[a] &amp;&amp; !exist[b]) <span class="built_in">printf</span>(<span class="string">"ERROR: %d and %d are not found.\n"</span>, a, b);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!exist[a] || !exist[b]) <span class="built_in">printf</span>(<span class="string">"ERROR: %d is not found.\n"</span>, !exist[a] ? a : b);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                ans = pre[i];</span><br><span class="line">                <span class="keyword">if</span> ((ans &gt;= a &amp;&amp; ans &lt;= b) || (ans &gt;= b &amp;&amp; ans &lt;= a)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a == ans || b == ans) <span class="built_in">printf</span>(<span class="string">"%d is an ancestor of %d.\n"</span>, ans, a == ans ? b : a);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"LCA of %d and %d is %d.\n"</span>, a, b, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 二叉树最低公共祖先 </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1147 Heaps (30分) (堆的判定)</title>
      <link href="/2020/02/24/pat-A1147/"/>
      <url>/2020/02/24/pat-A1147/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805342821531648" target="_blank" rel="noopener">A1147 Heaps (30分)</a></p><p>In computer science, a <strong>heap</strong> is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heap_(data_structure)</a>)</p><p>Your job is to tell if a given complete binary tree is a heap.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 100), the number of trees to be tested; and N (1 &lt; N ≤ 1,000), the number of keys in each tree, respectively. Then M lines follow, each contains N distinct integer keys (all in the range of <strong>int</strong>), which gives the level order traversal sequence of a complete binary tree.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each given tree, print in a line <code>Max Heap</code> if it is a max heap, or <code>Min Heap</code> for a min heap, or <code>Not Heap</code> if it is not a heap at all. Then in the next line print the tree’s postorder traversal sequence. All the numbers are separated by a space, and there must no extra space at the beginning or the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 8</span><br><span class="line">98 72 86 60 65 12 23 50</span><br><span class="line">8 38 25 58 52 82 70 60</span><br><span class="line">10 28 15 12 34 9 8 56</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Max Heap</span><br><span class="line">50 60 65 72 12 23 86 98</span><br><span class="line">Min Heap</span><br><span class="line">60 58 52 38 82 70 25 8</span><br><span class="line">Not Heap</span><br><span class="line">56 12 34 28 9 8 15 10</span><br></pre></td></tr></table></figure><ul><li>题意：给出一颗完全二叉树顺序存储的序列，判断这棵树是大顶堆、小顶堆或不是堆，之后输出这完全二叉树的后序遍历序列。</li><li>分析：因为是完全二叉树且是顺序存储的方式，所以从下标为1的位置开始依次读入到heap数组中，之后设定<code>isMaxHeap</code>、<code>isMinHeap</code>两变量，从下标为2的结点开始，遍历该数组，当前结点编号 i 除以2就是父结点编号，如果孩子结点值大于父结点值则一定不是大顶堆，将<code>isMaxHeap</code>标记为 <strong>false</strong>，小顶堆同理。最后递归输出后序遍历序列。</li></ul><p>注意：输出后序遍历序列最后不能有多余空格，因此设置全局变量<code>cnt</code>判断是否输出空格。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m, n, cnt = <span class="number">0</span>, heap[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    postOrder(i * <span class="number">2</span>);</span><br><span class="line">    postOrder(i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, heap[i]);</span><br><span class="line">    <span class="keyword">if</span> (++cnt &lt; n) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;heap[j]);</span><br><span class="line">        <span class="keyword">bool</span> isMaxHeap = <span class="literal">true</span>, isMinHeap = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heap[i] &gt; heap[i / <span class="number">2</span>]) isMaxHeap = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (heap[i] &lt; heap[i / <span class="number">2</span>]) isMinHeap = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isMaxHeap &amp;&amp; !isMinHeap) <span class="built_in">printf</span>(<span class="string">"Not Heap\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, isMaxHeap ? <span class="string">"Max Heap"</span> : <span class="string">"Min Heap"</span>);</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        postOrder(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 堆 </tag>
            
            <tag> 堆的判定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 添加对 Graphviz 的支持</title>
      <link href="/2020/02/24/hexo-graphviz-support/"/>
      <url>/2020/02/24/hexo-graphviz-support/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Graphviz？"><a href="#什么是Graphviz？" class="headerlink" title="什么是Graphviz？"></a><strong>什么是Graphviz？</strong></h2><p><a href="https://graphviz.gitlab.io/" target="_blank" rel="noopener">Graphviz</a>是开源的图形可视化软件。图形可视化是一种将结构信息表示为抽象图形和网络图的方式。它在网络，生物信息学，软件工程，数据库和网页设计，机器学习以及其他技术领域的可视界面中具有重要的应用。 </p><p><img src="https://www.graphviz.org/_pages/Gallery/directed/cluster.png" alt=""></p><p>以上是Graphviz实现作图的示例展示，通过类似于Markdown标记语言的形式，Graphviz使用Dot文本图形描述语言来实现作图。</p><h2 id="Hexo添加对Graphviz的支持"><a href="#Hexo添加对Graphviz的支持" class="headerlink" title="Hexo添加对Graphviz的支持"></a>Hexo添加对Graphviz的支持</h2><ol><li><p>安装相关插件 <a href="https://github.com/sounak98/hexo-graphviz" target="_blank" rel="noopener">hexo-graphviz</a></p><p>在终端<code>cd</code>至hexo博客根目录，通过yarn或者npm包管理器安装</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-graphviz<span class="comment"># 通过yarn安装</span></span><br><span class="line">npm install hexo-graphviz --save<span class="comment"># 通过npm安装</span></span><br></pre></td></tr></table></figure></li><li><p>在布局模板中添加相应的JavaScript代码</p><p><code>cd</code>至 <strong>{博客根目录}/themes/{主题名}/layout/_partial</strong> 目录之下，用<code>vim</code>或编辑器打开 <strong>after-footer</strong> 文件，针对不同类型的模板引擎添加相应代码：</p><ul><li><strong>ejs</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (theme.graphviz.enable) &#123; %&gt;</span><br><span class="line">  &lt;script src=<span class="string">'https://cdnjs.cloudflare.com/ajax/libs/viz.js/1.7.1/viz.js'</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  &lt;script&gt;</span></span><br><span class="line"><span class="regexp">    String.prototype.replaceAll = function(search, replacement) &#123;</span></span><br><span class="line"><span class="regexp">      var target = this;</span></span><br><span class="line"><span class="regexp">      return target.split(search).join(replacement);</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    let vizObjects = document.querySelectorAll('.graphviz')</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    for (let item of vizObjects) &#123;</span></span><br><span class="line"><span class="regexp">      let svg = undefined</span></span><br><span class="line"><span class="regexp">      try &#123;</span></span><br><span class="line"><span class="regexp">        svg = Viz(item.textContent.replaceAll('–', '--'), 'svg')</span></span><br><span class="line"><span class="regexp">      &#125; catch(e) &#123;</span></span><br><span class="line"><span class="regexp">        svg = `&lt;pre class="error"&gt;$&#123;e&#125;&lt;/</span>pre&gt;<span class="string">`</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      item.outerHTML = svg</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>swig</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.graphviz.enable %&#125;</span><br><span class="line">  &lt;script src=<span class="string">'https://cdnjs.cloudflare.com/ajax/libs/viz.js/1.7.1/viz.js'</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  &lt;script&gt;</span></span><br><span class="line"><span class="regexp">    String.prototype.replaceAll = function(search, replacement) &#123;</span></span><br><span class="line"><span class="regexp">      var target = this;</span></span><br><span class="line"><span class="regexp">      return target.split(search).join(replacement);</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    let vizObjects = document.querySelectorAll('.graphviz')</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    for (let item of vizObjects) &#123;</span></span><br><span class="line"><span class="regexp">      let svg = undefined</span></span><br><span class="line"><span class="regexp">      try &#123;</span></span><br><span class="line"><span class="regexp">        svg = Viz(item.textContent.replaceAll('–', '--'), 'svg')</span></span><br><span class="line"><span class="regexp">      &#125; catch(e) &#123;</span></span><br><span class="line"><span class="regexp">        svg = `&lt;pre class="error"&gt;$&#123;e&#125;&lt;/</span>pre&gt;<span class="string">`</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      item.outerHTML = svg</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>pug</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> theme.graphviz.enable == <span class="literal">true</span></span><br><span class="line">  script(type=<span class="string">'text/javascript'</span>, src=<span class="string">'https://cdnjs.cloudflare.com/ajax/libs/viz.js/1.7.1/viz.js'</span>)</span><br><span class="line">  script.</span><br><span class="line">    <span class="built_in">String</span>.prototype.replaceAll = <span class="function"><span class="keyword">function</span>(<span class="params">search, replacement</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> target = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">return</span> target.split(search).join(replacement);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> vizObjects = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.graphviz'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> vizObjects) &#123;</span><br><span class="line">      <span class="keyword">let</span> svg = <span class="literal">undefined</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        svg = Viz(item.textContent.replaceAll(<span class="string">'–'</span>, <span class="string">'--'</span>), <span class="string">'svg'</span>)</span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        svg = <span class="string">`&lt;pre class="error"&gt;<span class="subst">$&#123;e&#125;</span>&lt;/pre&gt;`</span></span><br><span class="line">      &#125;</span><br><span class="line">      item.outerHTML = svg</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>在hexo根目录下的 <strong>_config.yml</strong> 启用 graphviz</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo-graphviz</span></span><br><span class="line"><span class="attr">graphviz:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="示例预览"><a href="#示例预览" class="headerlink" title="示例预览"></a>示例预览</h2><p>插件安装完成之后通过Markdown添加代码块方式声明 <strong>graphviz</strong> 样式即可</p><ul><li>示例1：无向图</li></ul><div><div class="graphviz">graph demo1 {    a -- b -- c;    b -- d;}</div></div><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">graph</span> <span class="comment">demo1</span> <span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span>   <span class="comment">a</span> -- <span class="comment">b</span> -- <span class="comment">c;</span></span><br><span class="line"><span class="comment"></span>   <span class="comment">b</span> -- <span class="comment">d;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>示例2：二叉树</li></ul><div><div class="graphviz">digraph demo2 {    // bgcolor="beige" // 可设置背景颜色    node [shape="record", height=.1]    node0[label="<f0> | <f1> G | <f2>"]    node1[label="<f0> | <f1> E | <f2>"]    node2[label="<f0> | <f1> B | <f2>"]    node0:f0 -> node1:f1    node0:f2 -> node2:f1}</div></div><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">digraph demo2 &#123;</span><br><span class="line">    // bgcolor=<span class="string">"beige"</span> // 可设置背景颜色</span><br><span class="line">    node [shape=<span class="string">"record"</span>, height=.<span class="number">1</span>]</span><br><span class="line">    node0[<span class="keyword">label</span><span class="bash">=<span class="string">"&lt;f0&gt; | &lt;f1&gt; A | &lt;f2&gt;"</span>]</span></span><br><span class="line">    node1[<span class="keyword">label</span><span class="bash">=<span class="string">"&lt;f0&gt; | &lt;f1&gt; B | &lt;f2&gt;"</span>]</span></span><br><span class="line">    node2[<span class="keyword">label</span><span class="bash">=<span class="string">"&lt;f0&gt; | &lt;f1&gt; C | &lt;f2&gt;"</span>]</span></span><br><span class="line">    node0:f0 -&gt; node1:f1</span><br><span class="line">    node0:f2 -&gt; node2:f1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>示例3：大括号子图形式</li></ul><div><div class="graphviz">graph demo3 {    "数据结构三要素" -- {"数据的逻辑结构", "数据的存储结构", "数据的运算"}}</div></div><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph <span class="class">demo3 </span>&#123;</span><br><span class="line">    <span class="string">"数据结构三要素"</span> -- &#123;<span class="string">"数据的逻辑结构"</span>, <span class="string">"数据的存储结构"</span>, <span class="string">"数据的运算"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>示例4：总示例</li></ul><div><div class="graphviz">digraph demo4 {<pre><code>label=&lt;&lt;B&gt;Graphviz基本组成结构&lt;/B&gt;&gt;;labelloc=top;            // 标题位置bgcolor=transparent;    // 背景透明node[shape=box];        // 结点形状为方形//edge[style=bold];// 独立出现的为结点或属性声明, 中括号前为结点名称graphviz[label=&quot;Graphviz&quot;];subgraph{    layout[label=&quot;Layouts&quot;];    script[label=&quot;Script Files&quot;];    api[label=&quot;APIs&quot;];    rank=same;}graphviz -&gt; layout;graphviz -&gt; script;graphviz -&gt; api;// 设置子图api -&gt; subgraph{    layout_etc[label=&quot;......&quot;];}script -&gt;subgraph{    element[label=&quot;Elements&quot;];    attribute[label=&quot;Attributes&quot;];    rank=same;}layout -&gt;subgraph{    layout_dot[label=&quot;dot&quot;];    layout_neato[label=&quot;neato&quot;];}element -&gt;subgraph{    ele_graph[label=&quot;Graph&quot;];    ele_node[label=&quot;Node&quot;];    ele_edge[label=&quot;Edge&quot;];}</code></pre><p>}</div></div></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">digraph demo4 &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">label</span><span class="bash">=&lt;&lt;B&gt;Graphviz基本组成结构&lt;/B&gt;&gt;;</span></span><br><span class="line"></span><br><span class="line">    labelloc=top;// 标题位置</span><br><span class="line">    bgcolor=transparent;// 背景透明</span><br><span class="line">    </span><br><span class="line">    node[shape=box];// 结点形状为方形</span><br><span class="line">    //edge[style=bold];</span><br><span class="line">    </span><br><span class="line">    // 独立出现的为结点或属性声明, 中括号前为结点名称</span><br><span class="line">    graphviz[<span class="keyword">label</span><span class="bash">=<span class="string">"Graphviz"</span>];</span></span><br><span class="line">    </span><br><span class="line">    subgraph&#123;</span><br><span class="line">        layout[<span class="keyword">label</span><span class="bash">=<span class="string">"Layouts"</span>];</span></span><br><span class="line">        script[<span class="keyword">label</span><span class="bash">=<span class="string">"Script Files"</span>];</span></span><br><span class="line">        api[<span class="keyword">label</span><span class="bash">=<span class="string">"APIs"</span>];</span></span><br><span class="line">        rank=same;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    graphviz -&gt; layout;</span><br><span class="line">    graphviz -&gt; script;</span><br><span class="line">    graphviz -&gt; api;</span><br><span class="line">    </span><br><span class="line">    // 设置子图</span><br><span class="line">    api -&gt; </span><br><span class="line">    subgraph&#123;</span><br><span class="line">    layout_etc[<span class="keyword">label</span><span class="bash">=<span class="string">"......"</span>];</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    script -&gt;</span><br><span class="line">    subgraph&#123;</span><br><span class="line">        element[<span class="keyword">label</span><span class="bash">=<span class="string">"Elements"</span>];</span></span><br><span class="line">        attribute[<span class="keyword">label</span><span class="bash">=<span class="string">"Attributes"</span>];</span></span><br><span class="line">        rank=same;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    layout -&gt;</span><br><span class="line">    subgraph&#123;</span><br><span class="line">        layout_dot[<span class="keyword">label</span><span class="bash">=<span class="string">"dot"</span>];</span></span><br><span class="line">        layout_neato[<span class="keyword">label</span><span class="bash">=<span class="string">"neato"</span>];</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    element -&gt;</span><br><span class="line">    subgraph&#123;</span><br><span class="line">        ele_graph[<span class="keyword">label</span><span class="bash">=<span class="string">"Graph"</span>];</span></span><br><span class="line">        ele_node[<span class="keyword">label</span><span class="bash">=<span class="string">"Node"</span>];</span></span><br><span class="line">        ele_edge[<span class="keyword">label</span><span class="bash">=<span class="string">"Edge"</span>];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-14 电话聊天狂人 (25分)</title>
      <link href="/2020/02/24/pta-ds-7-14/"/>
      <url>/2020/02/24/pta-ds-7-14/</url>
      
        <content type="html"><![CDATA[<p>PTA数据结构与算法题目集：<a href="https://pintia.cn/problem-sets/15/problems/722" target="_blank" rel="noopener">7-14 电话聊天狂人 (25分)</a></p><p>给定大量手机用户通话记录，找出其中通话次数最多的聊天狂人。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入首先给出正整数<em>N</em>（≤10<sup>5</sup>），为通话记录条数。随后<em>N</em>行，每行给出一条通话记录。简单起见，这里只列出拨出方和接收方的11位数字构成的手机号码，其中以空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中给出聊天狂人的手机号码及其通话次数，其间以空格分隔。如果这样的人不唯一，则输出狂人中最小的号码及其通话次数，并且附加给出并列狂人的人数。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">13005711862 13588625832</span><br><span class="line">13505711862 13088625832</span><br><span class="line">13588625832 18087925832</span><br><span class="line">15005713862 13588625832</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13588625832 3</span><br></pre></td></tr></table></figure><ul><li>题意：找出通话次数最多的人。</li><li>分析：map记录每个人的通话次数，变量<code>cntDup</code>表示并列狂人的数量，某人通话次数超过所记录的最大值时<code>cntDup</code>重置为1，否则若有通话次数与最大次数相等则加1。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, maxCnt = <span class="number">0</span>, cntDup = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">string</span> s, ans = <span class="string">"99999999999"</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hashCnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">int</span> cnt = ++hashCnt[s];</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; maxCnt) &#123;</span><br><span class="line">            ans = s;</span><br><span class="line">            maxCnt = cnt;</span><br><span class="line">            cntDup = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt == maxCnt) &#123;</span><br><span class="line">            cntDup++;</span><br><span class="line">            <span class="keyword">if</span> (s &lt; ans) ans = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %d"</span>, ans.c_str(), maxCnt);</span><br><span class="line">    <span class="keyword">if</span> (cntDup &gt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">" %d"</span>, cntDup);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-10 公路村村通 (30分) (最小生成树Prime与Kruskal算法)</title>
      <link href="/2020/02/23/pta-ds-7-10/"/>
      <url>/2020/02/23/pta-ds-7-10/</url>
      
        <content type="html"><![CDATA[<p>PTA数据结构与算法题目集：<a href="https://pintia.cn/problem-sets/15/problems/718" target="_blank" rel="noopener">7-10 公路村村通 (30分)</a></p><p>现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入数据包括城镇数目正整数<em>N</em>（≤1000）和候选道路数目<em>M</em>（≤3<em>N</em>）；随后的<em>M</em>行对应<em>M</em>条道路，每行给出3个正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城镇从1到<em>N</em>编号。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出村村通需要的最低成本。如果输入数据不足以保证畅通，则输出−1，表示需要建设更多公路。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">6 15</span><br><span class="line">1 2 5</span><br><span class="line">1 3 3</span><br><span class="line">1 4 7</span><br><span class="line">1 5 4</span><br><span class="line">1 6 2</span><br><span class="line">2 3 4</span><br><span class="line">2 4 6</span><br><span class="line">2 5 2</span><br><span class="line">2 6 6</span><br><span class="line">3 4 6</span><br><span class="line">3 5 1</span><br><span class="line">3 6 1</span><br><span class="line">4 5 10</span><br><span class="line">4 6 8</span><br><span class="line">5 6 3</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><ul><li>题意：现要建设公路使各个村落都得以连通，给出若干条村落间建设公路需要的费用，如果给出的信息足够使得村落全部连通则输出最少的公路建设费用，否则输出 -1。</li><li>分析：题目中的各个村落映射为图中的结点，村落之间连通的费用则是结点间边的权值，同时要求各结点连通且边权和最小，因此很容易就抽象成图的最小生成树问题。</li></ul><p>注：仅通过样例亦无法判断测试样例是稀疏图还是稠密图，因此编写了Prime和Kruskal两种算法下的最小生成树解题代码。通过提交结果可以得到本题中使用Kruskal边贪心的算法效率更高。</p><ul><li>Prime算法：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> e[N][N], d[N], n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> vis[N] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    fill(d, d + N, INF);</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        ans += d[u];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; e[u][v] != INF &amp;&amp; e[u][v] &lt; d[v]) &#123;</span><br><span class="line">                d[v] = e[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    fill(e[<span class="number">0</span>], e[<span class="number">0</span>] + N * N, INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        e[a][b] = e[b][a] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, prime());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Kruskal算法：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, cost;</span><br><span class="line">&#125; e[N * <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, father[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span> </span>&#123; <span class="keyword">return</span> a.cost &lt; b.cost; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == father[x] ? x : father[x] = findFather(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) father[i] = i;</span><br><span class="line">    sort(e, e + m, cmp);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, cntEdge = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> faA = findFather(e[i].u), faB = findFather(e[i].v);</span><br><span class="line">        <span class="keyword">if</span> (faA != faB) &#123;</span><br><span class="line">            father[faA] = faB;</span><br><span class="line">            ans += e[i].cost;</span><br><span class="line">            <span class="keyword">if</span> (++cntEdge == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cntEdge != n - <span class="number">1</span> ? <span class="number">-1</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;e[i].u, &amp;e[i].v, &amp;e[i].cost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, kruskal());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
            <tag> 最小生成树Prime算法 </tag>
            
            <tag> 最小生成树Kruskal算法 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-7 六度空间 (30分)</title>
      <link href="/2020/02/22/pta-ds-7-7/"/>
      <url>/2020/02/22/pta-ds-7-7/</url>
      
        <content type="html"><![CDATA[<p>PTA数据结构与算法题目集：<a href="https://pintia.cn/problem-sets/15/problems/715" target="_blank" rel="noopener">7-7 六度空间 (30分)</a></p><p>“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。</p><p><img src="https://images.ptausercontent.com/35" alt="图1 六度空间示意图"></p><p>“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。</p><p>假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出两个正整数，分别表示社交网络图的结点数<em>N</em>（1&lt;<em>N</em>≤103，表示人数）、边数<em>M</em>（≤33×<em>N</em>，表示社交关系数）。随后的<em>M</em>行对应<em>M</em>条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到<em>N</em>编号）。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10 9</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br><span class="line">6 7</span><br><span class="line">7 8</span><br><span class="line">8 9</span><br><span class="line">9 10</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1: 70.00%</span><br><span class="line">2: 80.00%</span><br><span class="line">3: 90.00%</span><br><span class="line">4: 100.00%</span><br><span class="line">5: 100.00%</span><br><span class="line">6: 100.00%</span><br><span class="line">7: 100.00%</span><br><span class="line">8: 90.00%</span><br><span class="line">9: 80.00%</span><br><span class="line">10: 70.00%</span><br></pre></td></tr></table></figure><ul><li>题意：中文题，见题干描述。</li><li>分析：题目要求找出与某结点相距不超过6的结点个数。比如输入样例中，与结点1相距不超过6的结点有结点1到7（包括结点自己），相邻结点之间的距离是1。这实际上是个广度优先搜索的问题。用邻接表存储无向图，分别从每个结点出发，标记当前结点的深度 <strong>depth</strong> 为1，BFS开始后如果碰到某个结点的深度已经超过6了就直接跳过这个结点。否则就将当前结点的未被访问过的邻接点加入队列，同时把计数的变量<code>cnt</code>加1。题目整体不难的，是对基础数据结构的考察。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>, depth[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> vis[N] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    depth[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (depth[now] &gt; <span class="number">6</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : e[now]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[it]) &#123;</span><br><span class="line">                q.push(it);</span><br><span class="line">                depth[it] = depth[now] + <span class="number">1</span>;</span><br><span class="line">                vis[it] = <span class="literal">true</span>;</span><br><span class="line">                cnt += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        e[a].push_back(b);</span><br><span class="line">        e[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d: %.2f%%\n"</span>, i, bfs(i) * <span class="number">100.0</span> / n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 广度优先搜索 </tag>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-21 求前缀表达式的值 (25分)</title>
      <link href="/2020/02/21/pta-ds-7-21/"/>
      <url>/2020/02/21/pta-ds-7-21/</url>
      
        <content type="html"><![CDATA[<p>PTA数据结构与算法题目集：<a href="https://pintia.cn/problem-sets/15/problems/836" target="_blank" rel="noopener">7-21 求前缀表达式的值 (25分)</a></p><p>算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。前缀表达式指二元运算符位于两个运算数之前，例如<code>2+3*(7-4)+8/4</code>的前缀表达式是：<code>+ + 2 * 3 - 7 4 / 8 4</code>。请设计程序计算前缀表达式的结果值。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行内给出不超过30个字符的前缀表达式，只包含<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>以及运算数，不同对象（运算数、运算符号）之间以空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出前缀表达式的运算结果，保留小数点后1位，或错误信息<code>ERROR</code>。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ + 2 * 3 - 7 4 &#x2F; 8 4</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13.0</span><br></pre></td></tr></table></figure><ul><li>分析：前缀表示式，就是算术表达式的前序遍历序列（算术表达式中的运算符总会作为根），根左右，实际上就是运算符先被访问，再是分别访问左右孩子，所以解题思路就是倒着来，从给定序列的末尾开始，是操作数就进栈，碰到操作符就在栈中取出两个操作数，这一步相当于把以当前这个操作符为根的表达式计算完了，所以取出元素计算完之后要重新进栈。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pop</span><span class="params">(<span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> top = s.top();</span><br><span class="line">    s.pop();</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">compute</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">'-'</span>) <span class="keyword">return</span> a - b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'+'</span>) <span class="keyword">return</span> a + b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'*'</span>) <span class="keyword">return</span> a * b;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt; s;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str) v.push_back(str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        str = move(v[i]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(str[str.length() - <span class="number">1</span>])) &#123;</span><br><span class="line">            s.push(stod(str));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> a = pop(s), b = pop(s);</span><br><span class="line">            s.push(compute(a, b, str[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1f"</span>, s.top());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> PTA </tag>
            
            <tag> 前缀表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级 2019年春季考试（最简短的代码）</title>
      <link href="/2020/02/21/pat-2019-Spring-A/"/>
      <url>/2020/02/21/pat-2019-Spring-A/</url>
      
        <content type="html"><![CDATA[<p>真题估计还得一年才能补充到PAT题库里，做题还需要去<a href="https://pintia.cn/market/item/1103202531641643008" target="_blank" rel="noopener">教育超市</a>购买，坑呀！这是<a href="/PAT2019SpringA.html">导出分析</a></p><h1 id="7-1-Sexy-Primes-20分"><a href="#7-1-Sexy-Primes-20分" class="headerlink" title="7-1 Sexy Primes (20分)"></a>7-1 Sexy Primes (20分)</h1><p>Sexy primes are pairs of primes of the form (<em>p</em>, <em>p</em>+6), so-named since “sex” is the Latin word for “six”. (Quoted from <a href="http://mathworld.wolfram.com/SexyPrimes.html" target="_blank" rel="noopener">http://mathworld.wolfram.com/SexyPrimes.html</a>)</p><p>Now given an integer, you are supposed to tell if it is a sexy prime.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case gives a positive integer <em>N</em> (≤108).</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, print in a line <code>Yes</code> if <em>N</em> is a sexy prime, then print in the next line the other sexy prime paired with <em>N</em> (if the answer is not unique, output the smaller number). Or if <em>N</em> is not a sexy prime, print <code>No</code> instead, then print in the next line the smallest sexy prime which is larger than <em>N</em>.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">47</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">41</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No</span><br><span class="line">23</span><br></pre></td></tr></table></figure><ul><li>题意：性感素数是一种素数对，形如 <code>(p, p + 6)</code>，其中 p 和 p+6 都是素数，即其差值为6。题目要求，如果n是性感素数，则输出与n配对的另一个素数，如果答案不唯一则输出较小的那个，比如n-6与n+6都是素数，则输出n-6；如果n不是性感素数，则输出大于n的最小性感素数。</li><li>分析：根据题目要求，直接同时判定 n和n-6 或 n和n+6 是不是均为素数，如果两个情况都不满足，说明n不是性感素数，则n一直++，当n为素数时候，判断 n-6 或者 n+6 是不是素数即可。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++)</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span> (isprime(n) &amp;&amp; isprime(n - <span class="number">6</span>)) <span class="built_in">printf</span>(<span class="string">"Yes\n%d"</span>, n - <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isprime(n) &amp;&amp; isprime(n + <span class="number">6</span>)) <span class="built_in">printf</span>(<span class="string">"Yes\n%d"</span>, n + <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            <span class="keyword">if</span> (isprime(n) &amp;&amp; (isprime(n - <span class="number">6</span>) || isprime(n + <span class="number">6</span>))) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No\n%d"</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-2-Anniversary-25分"><a href="#7-2-Anniversary-25分" class="headerlink" title="7-2 Anniversary (25分)"></a>7-2 Anniversary (25分)</h1><p>Zhejiang University is about to celebrate her 122th anniversary in 2019. To prepare for the celebration, the alumni association （校友会） has gathered the ID’s of all her alumni. Now your job is to write a program to count the number of alumni among all the people who come to the celebration.</p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first part is about the information of all the alumni. Given in the first line is a positive integer <em>N</em> (≤10<sup>5</sup>). Then <em>N</em> lines follow, each contains an ID number of an alumnus. An ID number is a string of 18 digits or the letter <code>X</code>. It is guaranteed that all the ID’s are distinct.</p><p>The next part gives the information of all the people who come to the celebration. Again given in the first line is a positive integer <em>M</em> (≤10<sup>5</sup>). Then <em>M</em> lines follow, each contains an ID number of a guest. It is guaranteed that all the ID’s are distinct.</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>First print in a line the number of alumni among all the people who come to the celebration. Then in the second line, print the ID of the oldest alumnus – notice that the 7th - 14th digits of the ID gives one’s birth date. If no alumnus comes, output the ID of the oldest guest instead. It is guaranteed that such an alumnus or guest is unique.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">372928196906118710</span><br><span class="line">610481197806202213</span><br><span class="line">440684198612150417</span><br><span class="line">13072819571002001X</span><br><span class="line">150702193604190912</span><br><span class="line">6</span><br><span class="line">530125197901260019</span><br><span class="line">150702193604190912</span><br><span class="line">220221196701020034</span><br><span class="line">610481197806202213</span><br><span class="line">440684198612150417</span><br><span class="line">370205198709275042</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">150702193604190912</span><br></pre></td></tr></table></figure><ul><li>题意：浙大准备在2019年举办122周年庆，题目先给出一份浙大校友名单，再给出一份要来参加浙大周年庆的宾客名单，需要记录宾客中有多少个浙大校友，如果宾客中有校友则输出年龄最大的那位校友的ID，如果宾客名单中不存在校友，则输出宾客中年龄最大的宾客的ID。</li><li>分析：首先用<code>map</code>记录校友的ID，设置两个字符串类型的变量<code>oldestAlumni = &quot;xxxxxx99999999&quot;, oldestGuest = &quot;xxxxxx99999999&quot;</code>分别存年纪最大的校友和宾客的ID，年纪最大实际上就是生日最小，所以生日的初始值设置为最大99999999，输入宾客名单同时总是记录宾客中最老的那个，如果是校友再另行判断。最后直接根据计数的<code>cnt</code>判断输出哪个ID。这思路简直不要太简单了，哈哈。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> oldestAlumni = <span class="string">"xxxxxx99999999"</span>, oldestGuest = <span class="string">"xxxxxx99999999"</span>, id;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; isalumni;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line">        isalumni[id] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line">        <span class="keyword">if</span> (id.substr(<span class="number">6</span>, <span class="number">8</span>) &lt; oldestGuest.substr(<span class="number">6</span>, <span class="number">8</span>)) oldestGuest = id;</span><br><span class="line">        <span class="keyword">if</span> (isalumni[id]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id.substr(<span class="number">6</span>, <span class="number">8</span>) &lt; oldestAlumni.substr(<span class="number">6</span>, <span class="number">8</span>)) oldestAlumni = id;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%s"</span>, cnt, cnt &gt; <span class="number">0</span> ? oldestAlumni.c_str() : oldestGuest.c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-3-Telefraud-Detection-25分"><a href="#7-3-Telefraud-Detection-25分" class="headerlink" title="7-3 Telefraud Detection (25分)"></a>7-3 Telefraud Detection (25分)</h1><p>Telefraud（电信诈骗） remains a common and persistent problem in our society. In some cases, unsuspecting victims lose their entire life savings. To stop this crime, you are supposed to write a program to detect those suspects from a huge amount of phone call records.</p><p>A person must be detected as a suspect if he/she makes more than <em>K</em> short phone calls to <strong>different</strong> people everyday, but no more than 20% of these people would call back. And more, if two suspects are calling each other, we say they might belong to the same gang. <em>A</em> makes a <strong>short</strong> phone call to <em>B</em> means that the total duration of the calls from <em>A</em> to <em>B</em> is no more than 5 minutes.</p><h3 id="Input-Specification-2"><a href="#Input-Specification-2" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives 3 positive integers <em>K</em> (≤500, the threshold（阈值） of the amount of short phone calls), <em>N</em> (≤10<sup>3</sup>, the number of different phone numbers), and <em>M</em> (≤10<sup>5</sup>, the number of phone call records). Then <em>M</em> lines of one day’s records are given, each in the format:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">caller receiver duration</span><br></pre></td></tr></table></figure><p>where <code>caller</code> and <code>receiver</code> are numbered from 1 to <em>N</em>, and <code>duration</code> is no more than 1440 minutes in a day.</p><h3 id="Output-Specification-2"><a href="#Output-Specification-2" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>Print in each line all the detected suspects in a gang, in ascending order of their numbers. The gangs are printed in ascending order of their first members. The numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.</p><p>If no one is detected, output <code>None</code> instead.</p><h3 id="Sample-Input-1-1"><a href="#Sample-Input-1-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">5 15 31</span><br><span class="line">1 4 2</span><br><span class="line">1 5 2</span><br><span class="line">1 5 4</span><br><span class="line">1 7 5</span><br><span class="line">1 8 3</span><br><span class="line">1 9 1</span><br><span class="line">1 6 5</span><br><span class="line">1 15 2</span><br><span class="line">1 15 5</span><br><span class="line">3 2 2</span><br><span class="line">3 5 15</span><br><span class="line">3 13 1</span><br><span class="line">3 12 1</span><br><span class="line">3 14 1</span><br><span class="line">3 10 2</span><br><span class="line">3 11 5</span><br><span class="line">5 2 1</span><br><span class="line">5 3 10</span><br><span class="line">5 1 1</span><br><span class="line">5 7 2</span><br><span class="line">5 6 1</span><br><span class="line">5 13 4</span><br><span class="line">5 15 1</span><br><span class="line">11 10 5</span><br><span class="line">12 14 1</span><br><span class="line">6 1 1</span><br><span class="line">6 9 2</span><br><span class="line">6 10 5</span><br><span class="line">6 11 2</span><br><span class="line">6 12 1</span><br><span class="line">6 13 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1-1"><a href="#Sample-Output-1-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 5</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> In sample 1, although <code>1</code> had 9 records, but there were 7 distinct receivers, among which <code>5</code> and <code>15</code> both had conversations lasted more than 5 minutes in total. Hence <code>1</code> had made 5 short phone calls and didn’t exceed the threshold 5, and therefore is not a suspect.</p><h3 id="Sample-Input-2-1"><a href="#Sample-Input-2-1" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">5 7 8</span><br><span class="line">1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">1 4 1</span><br><span class="line">1 5 1</span><br><span class="line">1 6 1</span><br><span class="line">1 7 1</span><br><span class="line">2 1 1</span><br><span class="line">3 1 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2-1"><a href="#Sample-Output-2-1" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">None</span><br></pre></td></tr></table></figure><ul><li><p>题意：电信诈骗问题，很多人每天都会收到诈骗电话，题目要求通过给出的通话记录找到可能的诈骗犯和诈骗团伙，通话记录中，如果有人一天内打了k个短途电话（通话时长小于等于5分钟），且这些拨过去的<strong>短途</strong>电话里，只有不到20%的人回了电话，那这个拨号者就会被认为是诈骗嫌疑人，如果两个人诈骗嫌疑人彼此拨打过电话则视他们是一个团伙。题目给出阈值k（即拨打的短途电话数量）、不同的电话号码的数量n（编号从1到n）、m条通话记录。注意：一个人可能一天给同一个人拔打了多次电话，只有和对方的通话总时长小于等于5才被视作为一个短途电话。</p></li><li><p>这是四道题里比较麻烦的啦，把思路缕清，解题步骤还是比较清晰的。</p><ol><li>第一步：设置<code>record</code>数组存储通话时长，如record[a][b]表示a给b拨打的电话时长，题目给的电话号码（也可看作人物编号）从1到n依次编号，所以遍历1到n，如果这个人总的通话次数都不超过k，那肯定不会是嫌疑人，之后遍历record[i]，如果拨号者和某人的通话时长小于等于5分钟，那就callto++，同时判断对方是否拨回过电话，有拨回则callback++，最后如果callto大于k且callback和callto的比值小于等于0.2，则添加到嫌疑人名单。</li><li>第二步：找出嫌疑人名单之后就是找到团伙，要用到并查集，两两比较两个嫌疑人之间是否彼此拨过电话，将符合条件的嫌疑人合并到一个集合，之后就是分别输出各个集合了。这里值得注意的是，题目输出要求每个团伙占一行，每行按团伙中人员的编号升序输出，团伙之间则是按照团伙第一个人的编号升序排序。所以并查集的合并方法需要修改成总将较小的作为father，这样最后集合的根一定是里面数值最小的，再之后，团伙间也要有序，则是通过有序map自动排序，同时输出一个团伙时要对团伙中所有人重新排序。如果没有诈骗嫌疑人则输出 None。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == father[x] ? x : father[x] = findFather(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span> (faA &lt; faB) father[faB] = faA;</span><br><span class="line">    <span class="keyword">if</span> (faA &gt; faB) father[faA] = faB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1010</span>; i++) father[i] = i;</span><br><span class="line">    <span class="keyword">int</span> k, n, m, a, b, time;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;k, &amp;n, &amp;m);</span><br><span class="line">    vector&lt;map&lt;int, int&gt; &gt; record(n + 1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;time);</span><br><span class="line">        record[a][b] += time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; suspect;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (record[i].size() &lt;= k) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> callto = <span class="number">0</span>, callback = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : record[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it.second &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">                callto++;</span><br><span class="line">                <span class="keyword">if</span> (record[it.first].find(i) != record[it.first].end()) callback++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (callto &gt; k &amp;&amp; callback * <span class="number">1.0</span> / callto &lt;= <span class="number">0.2</span>) suspect.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (suspect.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"None\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; suspect.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; suspect.size(); j++) &#123;</span><br><span class="line">            a = suspect[i]; b = suspect[j];</span><br><span class="line">            <span class="keyword">if</span> (record[a][b] &gt; <span class="number">0</span> &amp;&amp; record[b][a] &gt; <span class="number">0</span>) uni(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : suspect) mp[findFather(it)].push_back(it);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : mp) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gang = move(it.second);</span><br><span class="line">        sort(gang.begin(), gang.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gang.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, gang[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="7-4-Structure-of-a-Binary-Tree-30分"><a href="#7-4-Structure-of-a-Binary-Tree-30分" class="headerlink" title="7-4 Structure of a Binary Tree (30分)"></a>7-4 Structure of a Binary Tree (30分)</h1><p>Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, a binary tree can be uniquely determined.</p><p>Now given a sequence of statements about the structure of the resulting tree, you are supposed to tell if they are correct or not. A statment is one of the following:</p><ul><li>A is the root</li><li>A and B are siblings</li><li>A is the parent of B</li><li>A is the left child of B</li><li>A is the right child of B</li><li>A and B are on the same level</li><li>It is a full tree</li></ul><p>Note:</p><ul><li>Two nodes are <strong>on the same level</strong>, means that they have the same depth.</li><li>A <strong>full binary tree</strong> is a tree in which every node other than the leaves has two children.</li></ul><h3 id="Input-Specification-3"><a href="#Input-Specification-3" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are no more than 103 and are separated by a space.</p><p>Then another positive integer <em>M</em> (≤30) is given, followed by <em>M</em> lines of statements. It is guaranteed that both <code>A</code> and <code>B</code> in the statements are in the tree.</p><h3 id="Output-Specification-3"><a href="#Output-Specification-3" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each statement, print in a line <code>Yes</code> if it is correct, or <code>No</code> if not.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">16 7 11 32 28 2 23 8 15</span><br><span class="line">16 23 7 32 11 2 28 15 8</span><br><span class="line">7</span><br><span class="line">15 is the root</span><br><span class="line">8 and 2 are siblings</span><br><span class="line">32 is the parent of 11</span><br><span class="line">23 is the left child of 16</span><br><span class="line">28 is the right child of 2</span><br><span class="line">7 and 11 are on the same level</span><br><span class="line">It is a full tree</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><ul><li>题意：给出一个二叉树的后序和中序遍历序列，题目读入m条命题，判断给出的命题是否正确。（具体见上面的说明样例）</li><li>分析：这是一道纯考数据结构的题啦，这道题我思考过两种做法，做法一：通过顺序存储的方式存储二叉树，优点是直接通过结点的编号就能判断结点间的关系。首先对中后序遍历序列复原二叉树的函数做一点调整，函数参数加上 <strong>i</strong> 和 <strong>depth</strong> 用于传递结点编号和深度，稍微麻烦一点的就是是否为满树需要单独判断，循环遍历所有的结点，如果存在一个非叶子结点只有一个孩子那这就不是满树，同时，因为题目说每个结点是不同的正整数，所以直接使用数组做哈希表记录下每个结点的序号。输入命题部分，只需要通过string取子串的方式就好了，用<code>stoi</code>函数将字符串转为整型，之后就是通过结点序号关系判断命题是否正确。做法二：和上面没有太大差异，只需要多设置几个相关的数组去记录父子结点关系、层数等即可。</li></ul><p>另外要注意的是，最开始用 i * 2 大于 len（最大的结点编号）来判断为叶子结点是不对的，我只是用顺序存储方式存储二叉树，但它并不是一颗完全二叉树，这里应该用 <code>tree[i * 2]</code> 的数值是不是为0（或表示为-1也行）来判断是不是叶子结点。最后，题目说 <u>A <strong>full binary tree</strong> is a tree in which every node other than the leaves has two children.</u> 这明明就不是真正的满二叉树呀，可能是陈越姥姥为了降低题目难度才这样定义吧。</p><p>解法一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; post, in;</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">1010</span>], pos[<span class="number">1010</span>], level[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> postl, <span class="keyword">int</span> postr, <span class="keyword">int</span> inl, <span class="keyword">int</span> inr, <span class="keyword">int</span> i, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (postl &gt; postr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    len = max(len, i);</span><br><span class="line">    level[post[postr]] = depth;</span><br><span class="line">    tree[i] = post[postr];</span><br><span class="line">    <span class="keyword">int</span> k = inl;</span><br><span class="line">    <span class="keyword">while</span> (k &lt;= inr &amp;&amp; in[k] != post[postr]) k++;</span><br><span class="line">    <span class="keyword">int</span> numLeft = k - inl;</span><br><span class="line">    tree[i * <span class="number">2</span>] = create(postl, postl + numLeft - <span class="number">1</span>, inl, k - <span class="number">1</span>, i * <span class="number">2</span>, depth + <span class="number">1</span>);</span><br><span class="line">    tree[i * <span class="number">2</span> + <span class="number">1</span>] = create(postl + numLeft, postr - <span class="number">1</span>, k + <span class="number">1</span>, inr, i * <span class="number">2</span> + <span class="number">1</span>, depth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> post[postr];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    post.resize(n);</span><br><span class="line">    in.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;post[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;in[i]);</span><br><span class="line">    create(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bool</span> isfull = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        pos[tree[i]] = i;</span><br><span class="line">        <span class="keyword">if</span> ((tree[i * <span class="number">2</span>] != <span class="number">0</span> || tree[i * <span class="number">2</span> + <span class="number">1</span>] != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">            (tree[i * <span class="number">2</span>] * tree[i * <span class="number">2</span> + <span class="number">1</span>] == <span class="number">0</span>)) &#123;</span><br><span class="line">            isfull = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">bool</span> ans;</span><br><span class="line">        getline(<span class="built_in">cin</span>, s);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'I'</span>) ans = isfull;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a = stoi(s.substr(<span class="number">0</span>, s.find_first_of(<span class="string">' '</span>)));</span><br><span class="line">            <span class="keyword">if</span> (s[s.length() - <span class="number">1</span>] == <span class="string">'t'</span>) ans = pos[a] == <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[s.length() - <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">int</span> b = stoi(s.substr(s.find_last_of(<span class="string">' '</span>) + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (s.find(<span class="string">"pa"</span>) != <span class="built_in">string</span>::npos) ans = pos[a] == pos[b] / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.find(<span class="string">"le"</span>) != <span class="built_in">string</span>::npos) ans = pos[a] == pos[b] * <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> ans = pos[a] == pos[b] * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.erase(<span class="number">0</span>, s.find_first_of(<span class="string">' '</span>));</span><br><span class="line">                <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(s[<span class="number">0</span>])) s.erase(s.begin());</span><br><span class="line">                <span class="keyword">int</span> b = stoi(s.substr(<span class="number">0</span>, s.find_first_of(<span class="string">' '</span>)));</span><br><span class="line">                <span class="keyword">if</span> (s[s.length() - <span class="number">1</span>] == <span class="string">'s'</span>) ans = pos[a] / <span class="number">2</span> == pos[b] / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> ans = level[a] == level[b];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ans ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> post[<span class="number">35</span>], in[<span class="number">35</span>], numlevel = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> isfull = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; father, lchild, rchild, level;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> postl, <span class="keyword">int</span> postr, <span class="keyword">int</span> inl, <span class="keyword">int</span> inr, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (postl &gt; postr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> root = post[postr];</span><br><span class="line">    <span class="keyword">int</span> k = inl;</span><br><span class="line">    <span class="keyword">while</span> (in[k] != post[postr]) k++;</span><br><span class="line">    <span class="keyword">int</span> numleft = k - inl;</span><br><span class="line">    <span class="keyword">int</span> left = create(postl, postl + numleft - <span class="number">1</span>, inl, k - <span class="number">1</span>, depth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> right = create(postl + numleft, postr - <span class="number">1</span>, k + <span class="number">1</span>, inr, depth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ((left == <span class="number">0</span> &amp;&amp; right != <span class="number">0</span>) || (left != <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)) isfull = <span class="literal">false</span>;</span><br><span class="line">    father[left] = father[right] = root;</span><br><span class="line">    lchild[root] = left;</span><br><span class="line">    rchild[root] = right;</span><br><span class="line">    level[left] = level[right] = depth++;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="built_in">string</span> val)</span> </span>&#123; <span class="keyword">return</span> s.find(val) != <span class="built_in">string</span>::npos; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;post[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;in[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">int</span> root = create(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>, s);</span><br><span class="line">        <span class="keyword">bool</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(s[<span class="number">0</span>])) &#123;</span><br><span class="line">            ans = isfull;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a, i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[i])) i++;</span><br><span class="line">            a = stoi(s.substr(<span class="number">0</span>, i));</span><br><span class="line">            <span class="keyword">if</span> (s[s.length() - <span class="number">1</span>] == <span class="string">'t'</span>) &#123;</span><br><span class="line">                ans = (root == a);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.find(<span class="string">"of"</span>) != <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">                <span class="keyword">int</span> start = s.length() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[start])) start--;</span><br><span class="line">                <span class="keyword">int</span> b = stoi(s.substr(++start));</span><br><span class="line">                <span class="keyword">if</span> (find(<span class="string">"pa"</span>)) ans = (father[b] == a);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (find(<span class="string">"le"</span>)) ans = (lchild[b] == a);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (find(<span class="string">"ri"</span>)) ans = (rchild[b] == a);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(s[i])) i++;</span><br><span class="line">                <span class="keyword">int</span> left = i;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[i])) i++;</span><br><span class="line">                <span class="keyword">int</span> b = stoi(s.substr(left, i - left + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (find(<span class="string">"sib"</span>)) ans = (father[a] == father[b]);</span><br><span class="line">                <span class="keyword">else</span> ans = (level[a] == level[b]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ans ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> PAT </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 素数判断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1053 Path of Equal Weight (30分) (DFS深度优先搜索+剪枝)</title>
      <link href="/2020/02/16/pat-A1053/"/>
      <url>/2020/02/16/pat-A1053/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805424153280512" target="_blank" rel="noopener">A1053 Path of Equal Weight (30分)</a></p><p>Given a non-empty tree with root <em>R</em>, and with weight <em>Wi</em> assigned to each tree node <em>Ti</em>. The <strong>weight of a path from <em>R</em> to <em>L</em></strong> is defined to be the sum of the weights of all the nodes along the path from <em>R</em> to any leaf node <em>L</em>.</p><p>Now given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let’s consider the tree showed in the following figure: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in the figure.</p><p><img src="https://images.ptausercontent.com/212" alt=""></p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing 0&lt;<em>N</em>≤100, the number of nodes in a tree, <em>M</em> (&lt;<em>N</em>), the number of non-leaf nodes, and 0&lt;<em>S</em>&lt;2<sup>30</sup>, the given weight number. The next line contains <em>N</em> positive numbers where <em>Wi</em> (&lt;1000) corresponds to the tree node <em>Ti</em>. Then <em>M</em> lines follow, each in the format:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ID K ID[1] ID[2] ... ID[K]</span><br></pre></td></tr></table></figure><p>where <code>ID</code> is a two-digit number representing a given non-leaf node, <code>K</code> is the number of its children, followed by a sequence of two-digit <code>ID</code>‘s of its children. For the sake of simplicity, let us fix the root ID to be <code>00</code>.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print all the paths with weight S in <strong>non-increasing</strong> order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line.</p><p>Note: sequence {<em>A</em>1,<em>A</em>2,⋯,<em>An</em>} is said to be <strong>greater than</strong> sequence {<em>B</em>1,<em>B</em>2,⋯,<em>Bm</em>} if there exists 1≤<em>k</em>&lt;<em>m<strong>i</strong>n</em>{<em>n</em>,<em>m</em>} such that <em>Ai</em>=<em>Bi</em> for <em>i</em>=1,⋯,<em>k</em>, and <em>Ak</em>+1&gt;<em>Bk</em>+1.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">20 9 24</span><br><span class="line">10 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 2</span><br><span class="line">00 4 01 02 03 04</span><br><span class="line">02 1 05</span><br><span class="line">04 2 06 07</span><br><span class="line">03 3 11 12 13</span><br><span class="line">06 1 09</span><br><span class="line">07 2 08 10</span><br><span class="line">16 1 15</span><br><span class="line">13 3 14 16 17</span><br><span class="line">17 2 18 19</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 5 2 7</span><br><span class="line">10 4 10</span><br><span class="line">10 3 3 6 2</span><br><span class="line">10 3 3 6 2</span><br></pre></td></tr></table></figure><ul><li>题意：给出一棵树，树中每个结点包含编号和权值，编号从 0~N，要求输出从根节点到某一叶子结点路径上各结点的权值（要求这条路径上的权值和等于给定的 <strong><em>W</em></strong> ），如果有多条路径满足条件，则按照降序输出各个路径，例如 a = [10, 5, 2]，b = [10, 4, 9]，则说 a &gt; b，因为第二项中 5 &gt; 4。</li><li>分析：其实考察的就是DFS，每个结点有两个属性，所以定义一个结构体数组，每个元素包含其权值和孩子结点的编号。因为要求降序输出，可以在读入孩子结点的时候就按照其权值降序排序。之后在DFS中传入结点编号 <strong>u</strong> 与当前权值和 <strong>sum</strong> 两个属性，如果 sum大于W 或者 sum等于W但当前结点不是叶子结点则退出（剪枝），如果满足条件则直接输出当前路径的权值。另一种方式则是先记录下所有满足条件的路径，之后再一起输出。</li></ul><p>方法一：（剪枝回溯）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">&#125; Node[N];</span><br><span class="line"><span class="keyword">int</span> n, m, w;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> Node[a].weight &gt; Node[b].weight; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; w) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum == w) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Node[u].child.size() != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, Node[path[i]].weight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : Node[u].child) &#123;</span><br><span class="line">        path.push_back(it);</span><br><span class="line">        dfs(it, sum + Node[it].weight);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Node[i].weight);</span><br><span class="line">    <span class="keyword">int</span> parent, child, k;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;parent, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;child);</span><br><span class="line">            Node[parent].child.push_back(child);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(Node[parent].child.begin(), Node[parent].child.end(), cmp);</span><br><span class="line">    &#125;</span><br><span class="line">    path.push_back(<span class="number">0</span>);</span><br><span class="line">    dfs(<span class="number">0</span>, Node[<span class="number">0</span>].weight);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：（记录所有结果再行输出）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">&#125; Node[N];</span><br><span class="line"><span class="keyword">int</span> n, m, w;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> Node[a].weight &gt; Node[b].weight; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    path.push_back(u);</span><br><span class="line">    <span class="keyword">if</span> (Node[u].child.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> tempw = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : path) tempw += Node[it].weight;</span><br><span class="line">        <span class="keyword">if</span> (tempw == w) ans.push_back(path);</span><br><span class="line">        path.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : Node[u].child) dfs(it);</span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Node[i].weight);</span><br><span class="line">    <span class="keyword">int</span> parent, child, k;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;parent, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;child);</span><br><span class="line">            Node[parent].child.push_back(child);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(Node[parent].child.begin(), Node[parent].child.end(), cmp);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ans[i].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, Node[ans[i][j]].weight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> DFS </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 剪枝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1030 Travel Plan (30分) (Dijkstra最短路径算法)</title>
      <link href="/2020/02/12/pat-A1030/"/>
      <url>/2020/02/12/pat-A1030/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805464397627392" target="_blank" rel="noopener">A1030 Travel Plan (30分)</a></p><p>A traveler’s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing 4 positive integers <em>N</em>, <em>M</em>, <em>S</em>, and <em>D</em>, where <em>N</em> (≤500) is the number of cities (and hence the cities are numbered from 0 to <em>N</em>−1); <em>M</em> is the number of highways; <em>S</em> and <em>D</em> are the starting and the destination cities, respectively. Then <em>M</em> lines follow, each provides the information of a highway, in the format:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">City1 City2 Distance Cost</span><br></pre></td></tr></table></figure><p>where the numbers are all integers no more than 500, and are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 5 0 3</span><br><span class="line">0 1 1 20</span><br><span class="line">1 3 2 30</span><br><span class="line">0 3 4 10</span><br><span class="line">0 2 2 20</span><br><span class="line">2 3 1 20</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2 3 3 40</span><br></pre></td></tr></table></figure><ul><li>题意：旅行者的地图上标明了各个城市间的距离和过路费，要求给定任意起点和终点，在地图上找到一条距离最短的路径，如果最短距离不只是一条，则选择花销更短的那条，题目保证最小花销是唯一的。</li><li>分析：这是图的单源最短路径问题，使用<code>Dijsktra</code>最短路径算法求解，题目里给出了距离和花销两个尺标，在满足第一尺标最优的情况下，使得第二尺标最优。这里可以选择 DFS 的方式计算多个最短路径的总花销，但是因为只有两个尺标，所以可以另设<code>int c[N]</code>数组存储起点到某点的花销，直接计算得到最优解。（只用Dijkstra算法也需要用到DFS，但是这里的DFS只是递归输出路径而已）。</li></ul><p>Dijkstra：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, st, dest, e[N][N], cost[N][N] = &#123;<span class="number">0</span>&#125;, d[N], c[N];</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pre</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="keyword">int</span> minCost = INF;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == st) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, u);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(pre[u]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    fill(d, d + N, INF);</span><br><span class="line">    fill(c, c + N, INF);</span><br><span class="line">    d[s] = c[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> vis[N] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; d[i] &lt; MIN) &#123;</span><br><span class="line">                MIN = d[i];</span><br><span class="line">                u = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; e[u][v] != INF) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[u] + e[u][v] &lt; d[v]) &#123;</span><br><span class="line">                    d[v] = d[u] + e[u][v];</span><br><span class="line">                    c[v] = c[u] + cost[u][v];</span><br><span class="line">                    pre[v] = u;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d[u] + e[u][v] == d[v] &amp;&amp; c[u] + cost[u][v] &lt; c[v]) &#123;</span><br><span class="line">                    c[v] = c[u] + cost[u][v];</span><br><span class="line">                    pre[v] = u;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;st, &amp;dest);</span><br><span class="line">    <span class="keyword">int</span> u, v, tdist, tcost;</span><br><span class="line">    fill(e[<span class="number">0</span>], e[<span class="number">0</span>] + N * N, INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;u, &amp;v, &amp;tdist, &amp;tcost);</span><br><span class="line">        e[u][v] = e[v][u] = tdist;</span><br><span class="line">        cost[u][v] = cost[v][u] = tcost;</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra(st);</span><br><span class="line">    dfs(dest);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, d[dest], c[dest]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dijkstra + DFS：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, st, dest, e[N][N], cost[N][N] = &#123;<span class="number">0</span>&#125;, d[N], minCost = INF;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path, tempPath, pre[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    tempPath.push_back(u);</span><br><span class="line">    <span class="keyword">if</span> (u == st) &#123;</span><br><span class="line">        <span class="keyword">int</span> tempCost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tempPath.size() - <span class="number">1</span>; i++)</span><br><span class="line">            tempCost += cost[tempPath[i]][tempPath[i + <span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">if</span> (tempCost &lt; minCost) &#123;</span><br><span class="line">            minCost = tempCost;</span><br><span class="line">            path = tempPath;</span><br><span class="line">        &#125;</span><br><span class="line">        tempPath.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : pre[u]) dfs(it);</span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    fill(d, d + N, INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> vis[N] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; d[i] &lt; MIN) &#123;</span><br><span class="line">                MIN = d[i];</span><br><span class="line">                u = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; e[u][v] != INF) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[u] + e[u][v] &lt; d[v]) &#123;</span><br><span class="line">                    d[v] = d[u] + e[u][v];</span><br><span class="line">                    pre[v].clear();</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d[u] + e[u][v] == d[v]) &#123;</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;st, &amp;dest);</span><br><span class="line">    <span class="keyword">int</span> u, v, tdist, tcost;</span><br><span class="line">    fill(e[<span class="number">0</span>], e[<span class="number">0</span>] + N * N, INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;u, &amp;v, &amp;tdist, &amp;tcost);</span><br><span class="line">        e[u][v] = e[v][u] = tdist;</span><br><span class="line">        cost[u][v] = cost[v][u] = tcost;</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra(st);</span><br><span class="line">    dfs(dest);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = path.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">"%d "</span>, path[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, d[dest], minCost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 最短路径算法 </tag>
            
            <tag> Dijkstra算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1028 List Sorting (25分)</title>
      <link href="/2020/02/10/pat-A1028/"/>
      <url>/2020/02/10/pat-A1028/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805468327690240" target="_blank" rel="noopener">A1028 List Sorting (25分)</a></p><p>Excel can sort records according to any column. Now you are supposed to imitate this function.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains two integers <em>N</em> (≤10<sup>5</sup>) and <em>C</em>, where <em>N</em> is the number of records and <em>C</em> is the column that you are supposed to sort the records with. Then <em>N</em> lines follow, each contains a record of a student. A student’s record consists of his or her distinct ID (a 6-digit number), name (a string with no more than 8 characters without space), and grade (an integer between 0 and 100, inclusive).</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output the sorting result in <em>N</em> lines. That is, if <em>C</em> = 1 then the records must be sorted in increasing order according to ID’s; if <em>C</em> = 2 then the records must be sorted in non-decreasing order according to names; and if <em>C</em> = 3 then the records must be sorted in non-decreasing order according to grades. If there are several students who have the same name or grade, they must be sorted according to their ID’s in increasing order.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 1</span><br><span class="line">000007 James 85</span><br><span class="line">000010 Amy 90</span><br><span class="line">000001 Zoe 60</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">000001 Zoe 60</span><br><span class="line">000007 James 85</span><br><span class="line">000010 Amy 90</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">000007 James 85</span><br><span class="line">000010 Amy 90</span><br><span class="line">000001 Zoe 60</span><br><span class="line">000002 James 98</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000010 Amy 90</span><br><span class="line">000002 James 98</span><br><span class="line">000007 James 85</span><br><span class="line">000001 Zoe 60</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3:"></a>Sample Input 3:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">000007 James 85</span><br><span class="line">000010 Amy 90</span><br><span class="line">000001 Zoe 60</span><br><span class="line">000002 James 90</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3:"></a>Sample Output 3:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000001 Zoe 60</span><br><span class="line">000007 James 85</span><br><span class="line">000002 James 90</span><br><span class="line">000010 Amy 90</span><br></pre></td></tr></table></figure><ul><li>题意：根据要求排序。当<em>C</em>=1时，按学号递增排序；当<em>C</em>=2时，按姓名的非递减字典序排序；当<em>C</em>=3时，按成绩的非递减排序。当若干学生具有相同姓名或者相同成绩时，则按他们的学号递增排序。</li><li>分析：题意简单明了，定义一个全局变量<code>c</code>，根据该变量在<code>cmp</code>函数中做判断即可。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, score;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n, c;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node &amp;a, node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) <span class="keyword">return</span> a.id &lt; b.id;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">2</span>) <span class="keyword">return</span> a.name != b.name ? a.name &lt; b.name : a.id &lt; b.id;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.score != b.score ? a.score &lt; b.score : a.id &lt; b.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;c);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;node&gt; <span class="title">stu</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; stu[i].id &gt;&gt; stu[i].name &gt;&gt; stu[i].score;</span><br><span class="line">    sort(stu.begin(), stu.end(), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : stu) <span class="built_in">printf</span>(<span class="string">"%06d %s %d\n"</span>, it.id, it.name.c_str(), it.score);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 简单排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】二叉树顺序存储结构建树方法</title>
      <link href="/2020/02/08/algo-bt-create/"/>
      <url>/2020/02/08/algo-bt-create/</url>
      
        <content type="html"><![CDATA[<p>顺序存储结构，即使用数组存储，结点从下标为1的位置开始存储，<code>a[i * 2]</code>和<code>a[i * 2 + 1]</code>分别表示<code>a[i]</code>结点的左右孩子。其中若孩子为空，则用 <strong>-1</strong> 代替。</p><ul><li>定义结构体：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    node *left, *right;</span><br><span class="line">    node(<span class="keyword">int</span> x) : data(x) &#123; left = right = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>递归建树：（动态数组 <strong>a</strong> 为引用类型）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= a.size() || a[i] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node* root = <span class="keyword">new</span> node(a[i]);</span><br><span class="line">    root-&gt;left = create(a, i * <span class="number">2</span>);</span><br><span class="line">    root-&gt;right = create(a, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    node *left, *right;</span><br><span class="line">    node(<span class="keyword">int</span> x) : data(x) &#123; left = right = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= a.size() || a[i] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node* root = <span class="keyword">new</span> node(a[i]);</span><br><span class="line">    root-&gt;left = create(a, i * <span class="number">2</span>);</span><br><span class="line">    root-&gt;right = create(a, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先序遍历验证结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;data);</span><br><span class="line">    preOrder(root-&gt;left);</span><br><span class="line">    preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">int</span> temp[] = &#123;<span class="number">-1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) a.push_back(temp[i]);</span><br><span class="line">    node* root = create(a, <span class="number">1</span>);</span><br><span class="line">    preOrder(root);<span class="comment">// 5 1 4 3 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归求解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】判断是否为二叉搜索树</title>
      <link href="/2020/02/08/algo-bt-isBST/"/>
      <url>/2020/02/08/algo-bt-isBST/</url>
      
        <content type="html"><![CDATA[<p>题目来源：</p><ul><li><a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. Validate Binary Search Tree</a></li><li><a href="https://pintia.cn/problem-sets/434/problems/6178" target="_blank" rel="noopener">习题4.3 是否二叉搜索树 (25分)</a></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">3</span>   <span class="number">5</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>起初使用堆的方式判定是不对的，二叉搜索树的任意结点应该 <strong>总大于所有左子树结点以及总小于所有右子树结点</strong>，不能只与左右孩子比较。</p><p>分析：（两种解法）</p><ul><li>方法一：递归求解。设定上下界，如果当前结点在上下界内则是符合的。</li></ul><ol><li>如果是空树，则认为是 BST，返回<code>true</code></li><li>非空，若 &lt;= 下界 或 &gt;= 上界 则返回<code>false</code></li><li>以上条件均不满足，则递归判断左右孩子是否为 BST<ul><li>向左递归时，左孩子应该均小于当前结点，故更新上界为当前结点的值</li><li>向右递归时，同理，右孩子均大于当前结点，故更新下界为当前结点数值</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(node* root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt;= low || root-&gt;val &gt;= high) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root-&gt;left, low, root-&gt;val)</span><br><span class="line">        &amp;&amp; isValidBST(root-&gt;right, root-&gt;val, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node *root = initBinaryTree();</span><br><span class="line">    isBST(root, INT_MIN, INT_MAX);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时，初始的上下界为整型可表示的最小最大值。</p><ul><li>方法二：迭代。二叉搜索树的中序遍历序列是升序的，只需要判断中序序列中两个相邻元素的大小关系即可，使用<code>preValue</code>记录前一个结点的值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;node*&gt; s;</span><br><span class="line">    node* p = root;</span><br><span class="line">    <span class="keyword">long</span> preValue = LONG_MIN;<span class="comment">// 定义最小值</span></span><br><span class="line">    <span class="keyword">while</span> (!s.empty() || p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (;p != <span class="literal">NULL</span>; p = p-&gt;left) s.push(p); <span class="comment">// 左孩子不为NULL, 一直入栈</span></span><br><span class="line">        p = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &lt;= preValue) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 如果不符合则直接返回 false</span></span><br><span class="line">        preValue = p-&gt;val;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法三：同为递归求解，但相对耗时。根据BST性质，判断当前节点是不是总比左子树的最右端的孩子大且总比右子树的最左端孩子小。缺点是对任意结点总要查找一次上面描述的最左右端的结点。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    TreeNode* p = root-&gt;left;</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;right) p = p-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt;= p-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p = root-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;left) p = p-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt;= p-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root-&gt;left) &amp;&amp; isValidBST(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归求解 </tag>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1029 Median (25分)</title>
      <link href="/2020/02/08/pat-A1029/"/>
      <url>/2020/02/08/pat-A1029/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805466364755968" target="_blank" rel="noopener">A1029 Median (25分)</a></p><p>Given an increasing sequence S of N integers, the median is the number at the middle position. For example, the median of S1 = { 11, 12, 13, 14 } is 12, and the median of S2 = { 9, 10, 15, 16, 17 } is 15. The median of two sequences is defined to be the median of the nondecreasing sequence which contains all the elements of both sequences. For example, the median of S1 and S2 is 13.</p><p>Given two increasing sequences of integers, you are asked to find their median.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies 2 lines, each gives the information of a sequence. For each sequence, the first positive integer N (≤2×10<sup>5</sup>) is the size of that sequence. Then N integers follow, separated by a space. It is guaranteed that all the integers are in the range of <strong>long int</strong>.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case you should output the median of the two given sequences in a line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 11 12 13 14</span><br><span class="line">5 9 10 15 16 17</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure><ul><li>题意：给出两个递增序列，找出两个序列合并后的中位数。</li><li>分析：如果真的合并两个序列，重新排序再取中值，那么必然会超时的。先计算出中值的位置<code>pos</code>（<strong>两序列的大小之和加 1 后再除以2</strong>），因为两个序列都是有序的，所以从两个序列的第一个元素开始比较，声明变量<code>i</code>和<code>j</code>分别用以遍历a、b序列，比较当前元素，谁更小就把谁的指针向后移动，同时用<code>cnt</code>计数，当 <strong>cnt == pos</strong> 时退出，如果没找到，则到未遍历完的序列去找。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">int</span> pos = (a.size() + b.size() + <span class="number">1</span>) / <span class="number">2</span>, i = <span class="number">0</span>, j = <span class="number">0</span>, cnt = <span class="number">0</span>, ans;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; a.size() &amp;&amp; j &lt; b.size()) &#123;</span><br><span class="line">        ans = a[i] &lt;= b[j] ? a[i++] : b[j++];</span><br><span class="line">        <span class="keyword">if</span> (++cnt == pos) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; a.size() &amp;&amp; cnt != pos; i++, cnt++) ans = a[i];</span><br><span class="line">    <span class="keyword">for</span> (; j &lt; b.size() &amp;&amp; cnt != pos; j++, cnt++) ans = b[j];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 有序序列的中位数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1027 Colors in Mars (20分)</title>
      <link href="/2020/02/08/pat-A1027/"/>
      <url>/2020/02/08/pat-A1027/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805470349344768" target="_blank" rel="noopener">A1027 Colors in Mars (20分)</a></p><p>People in Mars represent the colors in their computers in a similar way as the Earth people. That is, a color is represented by a 6-digit number, where the first 2 digits are for <code>Red</code>, the middle 2 digits for <code>Green</code>, and the last 2 digits for <code>Blue</code>. The only difference is that they use radix 13 (0-9 and A-C) instead of 16. Now given a color in three decimal numbers (each between 0 and 168), you are supposed to output their Mars RGB values.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case which occupies a line containing the three decimal color values.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case you should output the Mars RGB value in the following format: first output <code>#</code>, then followed by a 6-digit number where all the English characters must be upper-cased. If a single color is only 1-digit long, you must print a <code>0</code> to its left.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15 43 71</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#123456</span><br></pre></td></tr></table></figure><ul><li>题意：把10进制转为13进制（0-9 和 A-C）。</li><li>分析：因为只需要转化两位数，所以不需要写成循环的形式，分别对十位和个位做转换即可。因为13进制包含字母，所以如果超过9，就减去10再加上’A’即可。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &gt; <span class="number">9</span> ? x - <span class="number">10</span> + <span class="string">'A'</span> : x + <span class="string">'0'</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"#"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, change(n / <span class="number">13</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, change(n % <span class="number">13</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 进制转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1045 Favorite Color Stripe (30分) (最长不下降子序列)</title>
      <link href="/2020/02/07/pat-A1045/"/>
      <url>/2020/02/07/pat-A1045/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805437411475456" target="_blank" rel="noopener">A1045 Favorite Color Stripe (30分)</a></p><p>先引入我另一篇关于 <u><a href="https://blog.charjin.top/2020/02/07/algo-dp-LIS/">最长不下降子序列</a></u> 的笔记.</p><p>Eva is trying to make her own color stripe out of a given one. She would like to keep only her favorite colors in her favorite order by cutting off those unwanted pieces and sewing the remaining parts together to form her favorite color stripe.</p><p>It is said that a normal human eye can distinguish about less than 200 different colors, so Eva’s favorite colors are limited. However the original stripe could be very long, and Eva would like to have the remaining favorite stripe with the maximum length. So she needs your help to find her the best result.</p><p>Note that the solution might not be unique, but you only have to tell her the maximum length. For example, given a stripe of colors {2 2 4 1 5 5 6 3 1 1 5 6}. If Eva’s favorite colors are given in her favorite order as {2 3 1 5 6}, then she has 4 possible best solutions {2 2 1 1 1 5 6}, {2 2 1 5 5 5 6}, {2 2 1 5 5 6 6}, and {2 2 3 1 1 5 6}.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤200) which is the total number of colors involved (and hence the colors are numbered from 1 to <em>N</em>). Then the next line starts with a positive integer <em>M</em> (≤200) followed by <em>M</em> Eva’s favorite color numbers given in her favorite order. Finally the third line starts with a positive integer <em>L</em> (≤10<sup>4</sup>) which is the length of the given stripe, followed by <em>L</em> colors on the stripe. All the numbers in a line a separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, simply print in a line the maximum length of Eva’s favorite stripe.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">5 2 3 1 5 6</span><br><span class="line">12 2 2 4 1 5 5 6 3 1 1 5 6</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><ul><li>题意：Eva 要在一条颜色带选出她最喜欢的颜色，将其组成新的颜色带，题目给出 Eva 最喜欢的颜色以及排序，要求按照这个“最喜欢的颜色序列”来选择颜色（即选出的颜色可以不完全包含其最喜欢的颜色，但是必须按照她喜欢的顺序排列），并使组合出的颜色带最长，输出长度。（必须从颜色带的左到右依次选择，不能交替）。</li><li>分析：这是 <strong>最长不下降子序列</strong> 问题，但是大小比较方式不能通过颜色的编号，需要根据 Eva 对某个颜色的喜欢程度比较，所以在读入时对 Eva 最喜欢的颜色通过排名重新编号，记录在<code>number</code>数组中，因为颜色带中可能包含 Eva 不喜欢的颜色，所以为了省去给多余颜色排名的步骤，在读入数据时候直接将这些多余的颜色过滤掉。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, l, temp, dp[<span class="number">10010</span>], number[<span class="number">210</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">        number[temp] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;l);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">        <span class="keyword">if</span> (number[temp] != <span class="number">0</span>) a.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (number[a[i]] &gt;= number[a[j]] &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 最长不下降子序列 </tag>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】动态规划 - 最长不下降子序列（LIS）</title>
      <link href="/2020/02/07/algo-dp-LIS/"/>
      <url>/2020/02/07/algo-dp-LIS/</url>
      
        <content type="html"><![CDATA[<p><strong>最长不下降子序列（Longest Increasing Sequence）</strong>：在一个数字序列中，找到一个最长的子序列（可以不连续），使得这样的子序列是不下降（即非递减）的。</p><p>例如序列 a = {1, 2, 3, -1, -2, 7, 9}，它的最长不下降子序列是 {1, 2, 3, 7, 9} 长度为5，{1, 2, 3} 和 {-2, 7, 9} 也是非递减序列但不是最长的。</p><p>动态规划求解：<strong>dp[i] 表示以 a[i] 结尾的最长不下降子序列的长度</strong>。于是对 a[i] 来说就有两种可能：</p><ol><li>在 a[i] 前存在一个数 a[j]（即 j &lt; i ），使得 <strong>a[j] &lt;= a[i]</strong>，那说明 a[i] 可以跟在 a[j] 的后面形成一个新的不降序列，此时，dp[i] 是否要更新则取决于 <strong>dp[j] + 1 是否大于 dp[i]</strong>。（dp[j] + 1 表示以 a[j] 结尾的LIS加上 a[i] 这个元素后的长度）</li><li>在 a[i] 前的所有元素都比它大，那么以 a[i] 只能自己形成一个LIS，所以 <strong>dp[i] = 1</strong>。</li></ol><p>所以，以 a[i] 结尾的最长不下降子序列的长度就是上面两种结果中较大的那个。状态转移方式：<br>$$<br>dp[i] = max \left ( 1, \ dp[j] + 1 \right )<br>\left ( j = 1,2,\cdots,i-1\ and\ a[j]&lt; a[i] \right )<br>$$</p><p>写出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, a[N], dp[N], ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;<span class="comment">// 初始值为1，即以自己为一个序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt;= a[j] &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span>   </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">-9</span> <span class="number">3</span> <span class="number">9</span> <span class="number">0</span> <span class="number">11</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">9</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span><span class="comment">// 1 2 3 3 9 11</span></span><br></pre></td></tr></table></figure><p>这里主要问题是得到LIS的长度，但是要做一个好的程序员如果不把这个序列输出来，那是真是叫人悲伤。</p><p>解决方案：因为可能不止一个序列满足最长，因此用邻接表的方式，声明<code>vector&lt;int&gt; pre[N]</code>把所有符合条件的序列用前驱指针的方式存起来。<code>vector&lt;int&gt; dest</code>存储可以形成LIS的终点结点的索引。</p><p>之后只需要用 <strong>DFS</strong>，遍历一下 pre 数组就行了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    path.push_back(u);</span><br><span class="line">    <span class="keyword">if</span> (pre[u].size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = path.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, a[path[i]]);</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        path.pop_back();    <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">return</span>;             <span class="comment">// 2 这两句不加也可, 为了体现其已走到尽头, 则做return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : pre[u]) dfs(it);</span><br><span class="line">    path.pop_back();  <span class="comment">// u的所有孩子都访问完了, 把u从路径数组中移除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], dp[N], maxlen = <span class="number">-1</span>, ansIndex = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[N], path, ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    path.push_back(u);</span><br><span class="line">    <span class="keyword">if</span> (pre[u].size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = path.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, a[path[i]]);</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        path.pop_back();    <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">return</span>;             <span class="comment">// 2 这两句不加也可, 为了体现其已走到尽头, 则做return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : pre[u]) dfs(it);</span><br><span class="line">    path.pop_back();  <span class="comment">// u的所有孩子都访问完了, 把u从路径数组中移除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt;= a[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;  <span class="comment">// 比原来的LIS更长, 则i的前驱清空, 将j添加进去</span></span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    pre[i].clear();</span><br><span class="line">                    pre[i].push_back(j);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[j] + <span class="number">1</span> == dp[i]) &#123;  <span class="comment">// 一样长,则j也可作为一种选择, 把j添加进去</span></span><br><span class="line">                    pre[i].push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] &gt; maxlen) &#123;</span><br><span class="line">            maxlen = dp[i];</span><br><span class="line">            ans.clear();</span><br><span class="line">            ans.push_back(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i] == maxlen) &#123;</span><br><span class="line">            ans.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : ans) dfs(it);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span>   </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">-9</span> <span class="number">3</span> <span class="number">9</span> <span class="number">0</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><p>输出：（这里只有一个子串满足LIS）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">9</span> <span class="number">11</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 最长不下降子序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown数学公式语法手册（转载）</title>
      <link href="/2020/02/07/note-markdown-mathformula/"/>
      <url>/2020/02/07/note-markdown-mathformula/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="http://latex.codecogs.com/eqneditor/editor.php" target="_blank" rel="noopener">在线Markdown数学公式生成</a></li></ul><h2 id="行内与独行"><a href="#行内与独行" class="headerlink" title="行内与独行"></a>行内与独行</h2><ol><li>行内公式：将公式插入到本行内，符号：<code>$公式内容$</code>，如：$xyz$</li><li>独行公式：将公式插入到新的一行内，并且居中，符号：<code>$$公式内容$$</code>，如：$$xyz$$</li></ol><h2 id="上标、下标与组合"><a href="#上标、下标与组合" class="headerlink" title="上标、下标与组合"></a>上标、下标与组合</h2><ol><li>上标符号，符号：<code>^</code>，如：$x^4$</li><li>下标符号，符号：<code>_</code>，如：$x_1$</li></ol><h2 id="汉字、字体与格式"><a href="#汉字、字体与格式" class="headerlink" title="汉字、字体与格式"></a>汉字、字体与格式</h2><ol><li>汉字形式，符号：<code>\mbox{}</code>，如：$V_{\mbox{初始}}$</li><li>字体控制，符号：<code>\displaystyle</code>，如：$\displaystyle \frac{x+y}{y+z}$</li><li>下划线符号，符号：<code>\underline</code>，如：$\underline{x+y}$</li><li>标签，符号<code>\tag{数字}</code>，如：$\tag{11}$</li><li>上大括号，符号：<code>\overbrace{算式}</code>，如：$\overbrace{a+b+c+d}^{2.0}$</li><li>下大括号，符号：<code>\underbrace{算式}</code>，如：$a+\underbrace{b+c}_{1.0}+d$</li><li>上位符号，符号：<code>\stacrel{上位符号}{基位符号}</code>，如：$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$</li></ol><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><ol><li>两个quad空格，符号：<code>\qquad</code>，如：$x \qquad y$</li><li>quad空格，符号：<code>\quad</code>，如：$x \quad y$</li><li>大空格，符号<code>\</code>，如：$x \  y$</li><li>中空格，符号<code>\:</code>，如：$x : y$</li><li>小空格，符号<code>\,</code>，如：$x , y$</li><li>没有空格，符号``，如：$xy$</li><li>紧贴，符号<code>\!</code>，如：$x ! y$</li></ol><h2 id="定界符与组合"><a href="#定界符与组合" class="headerlink" title="定界符与组合"></a>定界符与组合</h2><ol><li>括号，符号：<code>（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)</code>，如：$（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$</li><li>中括号，符号：<code>[]</code>，如：$[x+y]$</li><li>大括号，符号：<code>\{ \}</code>，如：${x+y}$</li><li>自适应括号，符号：<code>\left \right</code>，如：$\left(x\right)$，$\left(x{yz}\right)$</li><li>组合公式，符号：<code>{上位公式 \choose 下位公式}</code>，如：${n+1 \choose k}={n \choose k}+{n \choose k-1}$</li><li>组合公式，符号：<code>{上位公式 \atop 下位公式}</code>，如：$\sum_{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n}A_{k_0}A_{k_1}\cdots$</li></ol><h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><ol><li>加法运算，符号：<code>+</code>，如：$x+y=z$</li><li>减法运算，符号：<code>-</code>，如：$x-y=z$</li><li>加减运算，符号：<code>\pm</code>，如：$x \pm y=z$</li><li>减甲运算，符号：<code>\mp</code>，如：$x \mp y=z$</li><li>乘法运算，符号：<code>\times</code>，如：$x \times y=z$</li><li>点乘运算，符号：<code>\cdot</code>，如：$x \cdot y=z$</li><li>星乘运算，符号：<code>\ast</code>，如：$x \ast y=z$</li><li>除法运算，符号：<code>\div</code>，如：$x \div y=z$</li><li>斜法运算，符号：<code>/</code>，如：$x/y=z$</li><li>分式表示，符号：<code>\frac{分子}{分母}</code>，如：$\frac{x+y}{y+z}$</li><li>分式表示，符号：<code>{分子} \voer {分母}</code>，如：${x+y} \over {y+z}$</li><li>绝对值表示，符号：<code>||</code>，如：$|x+y|$</li></ol><h2 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h2><ol><li><p>平均数运算，符号：<code>\overline{算式}</code>，如：$\overline{xyz}$</p></li><li><p>开二次方运算，符号：<code>\sqrt</code>，如：$\sqrt x$</p></li><li><p>开方运算，符号：<code>\sqrt[开方数]{被开方数}</code>，如：$\sqrt[3]{x+y}$</p></li><li><p>对数运算，符号：<code>\log</code>，如：$\log(x)$</p></li><li><p>极限运算，符号：<code>\lim</code>，如：$\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</p></li><li><p>极限运算，符号：<code>\displaystyle \lim</code>，如：$\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</p></li><li><p>求和运算，符号：<code>\sum</code>，如：$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</p></li><li><p>求和运算，符号：<code>\displaystyle \sum</code>，如：$\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</p></li><li><p>积分运算，符号：<code>\int</code>，如：$\int^{\infty}_{0}{xdx}$</p></li><li><p>积分运算，符号：<code>\displaystyle \int</code>，如：$\displaystyle \int^{\infty}_{0}{xdx}$</p></li><li><p>微分运算，符号：<code>\partial</code>，如：$\frac{\partial x}{\partial y}$</p></li><li><p>矩阵表示，符号：<code>\begin{matrix} \end{matrix}</code>，如：（显示有点问题）<br>$$<br>\left[<br>\begin{matrix}<br>1 &amp;2 &amp;\cdots &amp;4                   \<br>5 &amp;6 &amp;\cdots &amp;8                   \<br>\vdots &amp;\vdots &amp;\ddots &amp;\vdots    \<br>13 &amp;14 &amp;\cdots &amp;16                \<br>\end{matrix}<br>\right]<br>$$</p></li></ol><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ol><li>等于运算，符号：<code>=</code>，如：$x+y=z$</li><li>大于运算，符号：<code>&gt;</code>，如：$x+y&gt;z$</li><li>小于运算，符号：<code>&lt;</code>，如：$x+y&lt;z$</li><li>大于等于运算，符号：<code>\geq</code>，如：$x+y \geq z$</li><li>小于等于运算，符号：<code>\leq</code>，如：$x+y \leq z$</li><li>不等于运算，符号：<code>\neq</code>，如：$x+y \neq z$</li><li>不大于等于运算，符号：<code>\ngeq</code>，如：$x+y \ngeq z$</li><li>不大于等于运算，符号：<code>\not\geq</code>，如：$x+y \not\geq z$</li><li>不小于等于运算，符号：<code>\nleq</code>，如：$x+y \nleq z$</li><li>不小于等于运算，符号：<code>\not\leq</code>，如：$x+y \not\leq z$</li><li>约等于运算，符号：<code>\approx</code>，如：$x+y \approx z$</li><li>恒定等于运算，符号：<code>\equiv</code>，如：$x+y \equiv z$</li></ol><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><ol><li>属于运算，符号：<code>\in</code>，如：$x \in y$</li><li>不属于运算，符号：<code>\notin</code>，如：$x \notin y$</li><li>不属于运算，符号：<code>\not\in</code>，如：$x \not\in y$</li><li>子集运算，符号：<code>\subset</code>，如：$x \subset y$</li><li>子集运算，符号：<code>\supset</code>，如：$x \supset y$</li><li>真子集运算，符号：<code>\subseteq</code>，如：$x \subseteq y$</li><li>非真子集运算，符号：<code>\subsetneq</code>，如：$x \subsetneq y$</li><li>真子集运算，符号：<code>\supseteq</code>，如：$x \supseteq y$</li><li>非真子集运算，符号：<code>\supsetneq</code>，如：$x \supsetneq y$</li><li>非子集运算，符号：<code>\not\subset</code>，如：$x \not\subset y$</li><li>非子集运算，符号：<code>\not\supset</code>，如：$x \not\supset y$</li><li>并集运算，符号：<code>\cup</code>，如：$x \cup y$</li><li>交集运算，符号：<code>\cap</code>，如：$x \cap y$</li><li>差集运算，符号：<code>\setminus</code>，如：$x \setminus y$</li><li>同或运算，符号：<code>\bigodot</code>，如：$x \bigodot y$</li><li>同与运算，符号：<code>\bigotimes</code>，如：$x \bigotimes y$</li><li>实数集合，符号：<code>\mathbb{R}</code>，如：<code>\mathbb{R}</code></li><li>自然数集合，符号：<code>\mathbb{Z}</code>，如：<code>\mathbb{Z}</code></li><li>空集，符号：<code>\emptyset</code>，如：$\emptyset$</li></ol><h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><ol><li>无穷，符号：<code>\infty</code>，如：$\infty$</li><li>虚数，符号：<code>\imath</code>，如：$\imath$</li><li>虚数，符号：<code>\jmath</code>，如：$\jmath$</li><li>数学符号，符号<code>\hat{a}</code>，如：$\hat{a}$</li><li>数学符号，符号<code>\check{a}</code>，如：$\check{a}$</li><li>数学符号，符号<code>\breve{a}</code>，如：$\breve{a}$</li><li>数学符号，符号<code>\tilde{a}</code>，如：$\tilde{a}$</li><li>数学符号，符号<code>\bar{a}</code>，如：$\bar{a}$</li><li>矢量符号，符号<code>\vec{a}</code>，如：$\vec{a}$</li><li>数学符号，符号<code>\acute{a}</code>，如：$\acute{a}$</li><li>数学符号，符号<code>\grave{a}</code>，如：$\grave{a}$</li><li>数学符号，符号<code>\mathring{a}</code>，如：$\mathring{a}$</li><li>一阶导数符号，符号<code>\dot{a}</code>，如：$\dot{a}$</li><li>二阶导数符号，符号<code>\ddot{a}</code>，如：$\ddot{a}$</li><li>上箭头，符号：<code>\uparrow</code>，如：$\uparrow$</li><li>上箭头，符号：<code>\Uparrow</code>，如：$\Uparrow$</li><li>下箭头，符号：<code>\downarrow</code>，如：$\downarrow$</li><li>下箭头，符号：<code>\Downarrow</code>，如：$\Downarrow$</li><li>左箭头，符号：<code>\leftarrow</code>，如：$\leftarrow$</li><li>左箭头，符号：<code>\Leftarrow</code>，如：$\Leftarrow$</li><li>右箭头，符号：<code>\rightarrow</code>，如：$\rightarrow$</li><li>右箭头，符号：<code>\Rightarrow</code>，如：$\Rightarrow$</li><li>底端对齐的省略号，符号：<code>\ldots</code>，如：$1,2,\ldots,n$</li><li>中线对齐的省略号，符号：<code>\cdots</code>，如：$x_1^2 + x_2^2 + \cdots + x_n^2$</li><li>竖直对齐的省略号，符号：<code>\vdots</code>，如：$\vdots$</li><li>斜对齐的省略号，符号：<code>\ddots</code>，如：$\ddots$</li></ol><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table><thead><tr><th>字母</th><th>实现</th><th>字母</th><th>实现</th></tr></thead><tbody><tr><td>A</td><td><code>A</code></td><td>α</td><td><code>\alhpa</code></td></tr><tr><td>B</td><td><code>B</code></td><td>β</td><td><code>\beta</code></td></tr><tr><td>Γ</td><td><code>\Gamma</code></td><td>γ</td><td><code>\gamma</code></td></tr><tr><td>Δ</td><td><code>\Delta</code></td><td>δ</td><td><code>\delta</code></td></tr><tr><td>E</td><td><code>E</code></td><td>ϵ</td><td><code>\epsilon</code></td></tr><tr><td>Z</td><td><code>Z</code></td><td>ζ</td><td><code>\zeta</code></td></tr><tr><td>H</td><td><code>H</code></td><td>η</td><td><code>\eta</code></td></tr><tr><td>Θ</td><td><code>\Theta</code></td><td>θ</td><td><code>\theta</code></td></tr><tr><td>I</td><td><code>I</code></td><td>ι</td><td><code>\iota</code></td></tr><tr><td>K</td><td><code>K</code></td><td>κ</td><td><code>\kappa</code></td></tr><tr><td>Λ</td><td><code>\Lambda</code></td><td>λ</td><td><code>\lambda</code></td></tr><tr><td>M</td><td><code>M</code></td><td>μ</td><td><code>\mu</code></td></tr><tr><td>N</td><td><code>N</code></td><td>ν</td><td><code>\nu</code></td></tr><tr><td>Ξ</td><td><code>\Xi</code></td><td>ξ</td><td><code>\xi</code></td></tr><tr><td>O</td><td><code>O</code></td><td>ο</td><td><code>\omicron</code></td></tr><tr><td>Π</td><td><code>\Pi</code></td><td>π</td><td><code>\pi</code></td></tr><tr><td>P</td><td><code>P</code></td><td>ρ</td><td><code>\rho</code></td></tr><tr><td>Σ</td><td><code>\Sigma</code></td><td>σ</td><td><code>\sigma</code></td></tr><tr><td>T</td><td><code>T</code></td><td>τ</td><td><code>\tau</code></td></tr><tr><td>Υ</td><td><code>\Upsilon</code></td><td>υ</td><td><code>\upsilon</code></td></tr><tr><td>Φ</td><td><code>\Phi</code></td><td>ϕ</td><td><code>\phi</code></td></tr><tr><td>X</td><td><code>X</code></td><td>χ</td><td><code>\chi</code></td></tr><tr><td>Ψ</td><td><code>\Psi</code></td><td>ψ</td><td><code>\psi</code></td></tr><tr><td>Ω</td><td><code>\v</code></td><td>ω</td><td><code>\omega</code></td></tr></tbody></table><p>作者：DanielGavin<br>链接：<a href="https://www.jianshu.com/p/e74eb43960a1" target="_blank" rel="noopener">https://www.jianshu.com/p/e74eb43960a1</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 软技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】二分查找详细总结 BinarySearch</title>
      <link href="/2020/02/05/algo-binary-search/"/>
      <url>/2020/02/05/algo-binary-search/</url>
      
        <content type="html"><![CDATA[<p>二分查找算法的两种实现：</p><ul><li>第一种：各类教材、百科的常见写法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = a.size() - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; x) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; x) right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法，每次循环和 <strong>left 与 right</strong> 的中值比较，如果 <strong>x</strong> 大于中间值，往右侧寻找因此 <strong>left = mid + 1</strong>，若 <strong>x</strong> 小于中间值则往左侧寻找，<strong>right = mid - 1</strong>，如果是最坏情况，可能要折半至刚好剩下一个元素才能找到，比如在 <strong>1 2 3 4</strong> 中查找 <strong>4</strong>，查找到最后时 <strong>left</strong> 和 <strong>right</strong> 相等，或是考虑数组a只包含一个元素，那 <strong>left</strong> 和 <strong>right</strong> 显然也是相等的，所以循环条件是 <strong>left &lt;= right</strong>。</p><p>特点总结，以上算法中：</p><ol><li>在查找成功的情况下，能确定的是 <strong>mid</strong> 一定是x所在位置（即下标），<strong>left 与 right不能确定</strong></li><li>在查找失败的情况下：<ul><li>先考虑 <strong>x</strong> 在数组a的最小值和最大值范围之内（但不存在该元素），在查找最后一定会出现只剩下两个元素的情况，那么根据这个二分的算法（小于中值向左找大于中值向右找），<strong>x</strong> 的值一定会在 <strong>a[left] 和 a[right]</strong> 之间，于是再根据二分的算法，中值 <strong>a[mid]</strong> 和 <strong>a[left]</strong> 相等，<strong>a[mid] &lt; x，left = mid + 1</strong>，此时 <strong>left</strong> 和 <strong>right</strong> 相等了，也就是说如果查找失败最后被检索的那个数一定是大于x的，那么再进行下一次循环的时候，x小于中值（即 <strong>a[left]</strong> 和 <strong>a[right]</strong> ）<strong>right = mid - 1</strong>，所以最终 <strong>left == right + 1</strong>。</li><li>再考虑x比数组a的最大元素还要大，那么查找过程中 right 是不会动的，直到 <strong>left == right</strong>，x还是比它两中值大，因此 <strong>left = mid + 1</strong>，仍然满足 <strong>left == right + 1</strong>，当x比数组a最小元素还要小时和上面一种情况是一样的，最终检索的元素比x大，<strong>right = mid - 1</strong>.</li></ul></li></ol><p>其实得到查询失败的后left和right的关系很简单，left &lt;= right 是循环条件，那么当循环结束时，left肯定刚好比right大一。但是现在的主要结论是 <strong>如果查找失败，可以得到 a[right] &lt; x &lt; a[left]</strong> ，即 <strong>right停在了小于x的最大位置上，left停在了大于x的最小位置上</strong> （即使查找的x在数组a的最大最小值范围之外这也在单侧满足），例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">30</span>, <span class="number">36</span>, <span class="number">40</span>&#125;;</span><br><span class="line"></span><br><span class="line">查找元素 <span class="number">1</span>：left = <span class="number">0</span>, right = <span class="number">-1</span>, mid = <span class="number">0</span></span><br><span class="line">查找元素 <span class="number">45</span>：left = <span class="number">8</span>, right = <span class="number">7</span>, mid = <span class="number">7</span></span><br></pre></td></tr></table></figure><p>现在讨论另一种二分查找的写法以及特点</p><ul><li><p>第二种：出现在使用树状数组动态地查找无序序列中第K小的元素是几。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= x) right = mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[left] == x ? left : <span class="number">-1</span>;<span class="comment">// a[right] == x 也是一样的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种是在柳婼的题解中看到的写法，与常见的二叉搜索写法不同的是，这里循环条件变成了 <strong>left &lt; right</strong> ，最大的区别在于，此处即使查找到x也不直接退出，而是等到不满足循环条件后自动退出，选择条件之一变成了 <code>if (a[mid] &gt;= x) right = mid;</code> 但是这里比上面更好分析了，循环结束的条件是 <strong>left 正好等于 right</strong>，所以可以确定的一点是 <strong>不管x是否查找成功，最终 left == right 始终满足</strong>，显然在查找成功后 <strong>a[left] == a[right] == x</strong>，如果查找失败，还是假设最后只剩下两个元素的情况，x在数组最小值和最大值范围内，那么 <strong>mid == left, a[mid] &lt; x =&gt; left = mid + 1</strong>，所以 <strong>left</strong> 和 <strong>right</strong> 最终会停在较大的那一方，所以可以得到的结论：<strong>如果查找成功则left与right均在值为x的元素位置上，如果查找失败则left与right均在大于x的最小位置上</strong>。但如果给的x大于最大值则停在最后一个元素位置上，另一情况亦然。</p></li></ul><p>虽然这种写法表面看起来多此一举，但是一类问题中，比如能确定所要查询的元素在此范围内，要求如果无此结果则要求返回大于该结果的最小值并做相关的处理，或是另一种，实际上比较的不是x的值，而是通过x在另一序列中得到结果，则这样的写法会很简便，虽然这种方式在查找到结果后没有立刻退出，但是时间复杂度依然是 <strong>O(logN)</strong>，也并没耗去过多时间。</p><p>现在将二分查找的相关问题整理明白，而后熟记于心，再碰到与之相关的问题也可免去额外思考的时间。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hexo】maupassant 主题设置百度站点自动推送</title>
      <link href="/2020/02/05/hexo-site-autopush/"/>
      <url>/2020/02/05/hexo-site-autopush/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自动推送是百度搜索资源平台为提高站点新增网页发现速度推出的工具，安装自动推送JS代码的网页，在页面被访问时，页面URL将立即被推送给百度。</p></blockquote><p>进入百度搜索资源平台的 <a href="https://ziyuan.baidu.com/linksubmit/index" target="_blank" rel="noopener">链接提交</a> 处，将百度给出的自动推送JS代码拷贝下来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bp = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">        <span class="keyword">var</span> curProtocol = <span class="built_in">window</span>.location.protocol.split(<span class="string">':'</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (curProtocol === <span class="string">'https'</span>) &#123;</span><br><span class="line">            bp.src = <span class="string">'https://zz.bdstatic.com/linksubmit/push.js'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            bp.src = <span class="string">'http://push.zhanzhang.baidu.com/push.js'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"script"</span>)[<span class="number">0</span>];</span><br><span class="line">        s.parentNode.insertBefore(bp, s);</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>打开主题中的 <strong>head.pug</strong> 文件，路径： <u><strong>yourblogdir</strong>/themes/maupassant/layout/_partial/head.pug</u></p><p>在该文件底部添加以上JS代码：（其中 <code>theme.baidu_autopush</code>是我自己设定的属性名，从 <u>_config.yml</u> 中引用，也可在此处直接设为<code>true</code>）</p><p><img src="/img/hexo_autopush_1.png" alt=""></p><p>之后打开主题配置文件，路径：<u><strong>yourblogdir</strong>/themes/maupassant/_config.yml</u>，在文件任意处设置以下属性值：（注释随意加，注意左侧不能有任何空格与缩进）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_autopush:</span> <span class="literal">true</span>  <span class="comment">## Add pushing automately of baidu site.</span></span><br></pre></td></tr></table></figure><p>本地使用命令<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code>开启服务查看一下，就会发现页面源码中已经加上自动推送的JS代码了。</p><p><img src="/img/hexo_autopush_2.png" alt=""></p><p>现在就靠自己手动刷刷页面让链接自动提交给百度啦，但是话说我已经通过 <strong>sitemap</strong> 让百度自动抓取了，百度接收链接还是奇慢无比，Google上早就能看到我的站点链接了 =_=!!!</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】二叉树输出根节点到x的路径</title>
      <link href="/2020/02/04/algo-bt-findpath/"/>
      <url>/2020/02/04/algo-bt-findpath/</url>
      
        <content type="html"><![CDATA[<p>分析（递归）：</p><ol><li>空树，则查找失败，返回 false</li><li>当前结点为所要查找的值，输出结果，返回 true</li><li>以上条件不满足，则向左找或向右找，找着了说明当前结点是根到x路径上的点，输出并返回 true</li><li>左右都找不到，查找失败，无此结点，返回 false</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">printPath</span><span class="params">(node* root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == x) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, x);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (printPath(root-&gt;left, x) || printPath(root-&gt;right, x)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;data);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    node *left, *right;</span><br><span class="line">    node(<span class="keyword">int</span> x) : data(x) &#123; left = right = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> pre[] = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, in[] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> prel, <span class="keyword">int</span> prer, <span class="keyword">int</span> inl, <span class="keyword">int</span> inr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prel &gt; prer) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node* root = <span class="keyword">new</span> node(pre[prel]);</span><br><span class="line">    <span class="keyword">int</span> k = inl;</span><br><span class="line">    <span class="keyword">while</span> (in[k] != pre[prel]) k++;</span><br><span class="line">    <span class="keyword">int</span> numleft = k - inl;</span><br><span class="line">    root-&gt;left = create(prel + <span class="number">1</span>, prel + numleft, inl, k - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = create(prel + numleft + <span class="number">1</span>, prer, k + <span class="number">1</span>, inr);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出从根节点到x的路径</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">printPath</span><span class="params">(node* root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == x) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, x);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (printPath(root-&gt;left, x) || printPath(root-&gt;right, x)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;data);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">9</span>;</span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; n; i++) scanf("%d", pre + i);</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; n; i++) scanf("%d", in + i);</span></span><br><span class="line">    node* root = create(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    printPath(root, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">8 </span><span class="number">5</span> <span class="number">4</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归求解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天梯赛 L2-012 关于堆的判断 (25分)</title>
      <link href="/2020/02/04/pta-L2-012/"/>
      <url>/2020/02/04/pta-L2-012/</url>
      
        <content type="html"><![CDATA[<p>团体程序设计天梯赛-练习集： <a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805064676261888" target="_blank" rel="noopener">L2-012 关于堆的判断</a></p><p>将一系列给定数字顺序插入一个初始为空的小顶堆<code>H[]</code>。随后判断一系列相关命题是否为真。命题分下列几种：</p><ul><li><code>x is the root</code>：<code>x</code>是根结点；</li><li><code>x and y are siblings</code>：<code>x</code>和<code>y</code>是兄弟结点；</li><li><code>x is the parent of y</code>：<code>x</code>是<code>y</code>的父结点；</li><li><code>x is a child of y</code>：<code>x</code>是<code>y</code>的一个子结点。</li></ul><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每组测试第1行包含2个正整数<code>N</code>（≤ 1000）和<code>M</code>（≤ 20），分别是插入元素的个数、以及需要判断的命题数。下一行给出区间[−10000,10000]内的<code>N</code>个要被插入一个初始为空的小顶堆的整数。之后<code>M</code>行，每行给出一个命题。题目保证命题中的结点键值都是存在的。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对输入的每个命题，如果其为真，则在一行中输出<code>T</code>，否则输出<code>F</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">46 23 26 24 10</span><br><span class="line">24 is the root</span><br><span class="line">26 and 23 are siblings</span><br><span class="line">46 is the parent of 23</span><br><span class="line">23 is a child of 10</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F</span><br><span class="line">T</span><br><span class="line">F</span><br><span class="line">T</span><br></pre></td></tr></table></figure><p>分析：根据输入依次在堆中插入元素建立小顶堆，因为判断元素间关系需要用位置做判断，因此通过 <code>unordered_map</code> 记录每个元素的数组中的序号，在接收到命题之后直接取出元素对应的位置 <code>pos</code> 就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hole = ++len;</span><br><span class="line">    <span class="keyword">for</span> (; hole &gt; <span class="number">1</span> &amp;&amp; heap[hole / <span class="number">2</span>] &gt; x; hole /= <span class="number">2</span>)</span><br><span class="line">        heap[hole] = move(heap[hole / <span class="number">2</span>]);</span><br><span class="line">    heap[hole] = move(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    heap.resize(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">        insert(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pos[heap[i]] = i;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %s"</span>, &amp;a, temp);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(temp, <span class="string">"and"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %*s %*s"</span>, &amp;b);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, pos[a] / <span class="number">2</span> == pos[b] / <span class="number">2</span> ? <span class="string">'T'</span> : <span class="string">'F'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%*s %s"</span>, temp);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(temp, <span class="string">"root"</span>) == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, a == heap[<span class="number">1</span>] ? <span class="string">'T'</span> : <span class="string">'F'</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%*s %d"</span>, &amp;b);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(temp, <span class="string">"parent"</span>) == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, pos[a] == pos[b] / <span class="number">2</span> ? <span class="string">'T'</span> : <span class="string">'F'</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, pos[b] == pos[a] / <span class="number">2</span> ? <span class="string">'T'</span> : <span class="string">'F'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 团体程序设计天梯赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C/C++】move函数的概念与使用</title>
      <link href="/2020/02/04/cpp-fun-move/"/>
      <url>/2020/02/04/cpp-fun-move/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>std::move</code> is used to <em>indicate</em> that an object <code>t</code> may be “moved from”, i.e. allowing the efficient transfer of resources from <code>t</code> to another object. </p><p>In particular, <code>std::move</code> produces an xvalue expression that identifies its argument <code>t</code>. It is exactly equivalent to a static_cast to an rvalue reference type.</p></blockquote><p>在《Data Structures And Algorithm Analysis in Cpp》中学习堆的相关操作，碰到 <code>move</code> 函数的使用，做点笔记。以下是书中小顶堆的插入实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Insert item x, allowing duplicates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">( <span class="keyword">const</span> Comparable &amp; x )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( currentSize == <span class="built_in">array</span>.size( ) - <span class="number">1</span> )</span><br><span class="line">        <span class="built_in">array</span>.resize( <span class="built_in">array</span>.size( ) * <span class="number">2</span> );</span><br><span class="line">    <span class="comment">// Percolate up</span></span><br><span class="line">    <span class="keyword">int</span> hole = ++currentSize;</span><br><span class="line">    Comparable copy = x;</span><br><span class="line">    <span class="built_in">array</span>[ <span class="number">0</span> ] = <span class="built_in">std</span>::move( copy );</span><br><span class="line">    <span class="keyword">for</span>( ; x &lt; <span class="built_in">array</span>[ hole / <span class="number">2</span> ]; hole /= <span class="number">2</span> )</span><br><span class="line">        <span class="built_in">array</span>[ hole ] = <span class="built_in">std</span>::move( <span class="built_in">array</span>[ hole / <span class="number">2</span> ] );</span><br><span class="line">    <span class="built_in">array</span>[ hole ] = <span class="built_in">std</span>::move( <span class="built_in">array</span>[ <span class="number">0</span> ] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原本在编程过程常遇到大量查询并复制等操作，如果元素个数较多或是结构体，可能会增加较大的额外复制开销。使用 <code>move</code> 相当于将对象使用权转交给另一对象，而不用额外的空间去做被复制对象的暂存，节省内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;// move 函数所在头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 使用 push_back(const T&amp;) 重载，</span></span><br><span class="line">    <span class="comment">// 表示我们将带来复制 str 的成本</span></span><br><span class="line">    v.push_back(str);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"After copy, str is \""</span> &lt;&lt; str &lt;&lt; <span class="string">"\"\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用右值引用 push_back(T&amp;&amp;) 重载，</span></span><br><span class="line">    <span class="comment">// 表示不复制字符串；而是</span></span><br><span class="line">    <span class="comment">// str 的内容被移动进 vector</span></span><br><span class="line">    <span class="comment">// 这个开销比较低，但也意味着 str 现在可能为空。</span></span><br><span class="line">    v.push_back(<span class="built_in">std</span>::move(str));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"After move, str is \""</span> &lt;&lt; str &lt;&lt; <span class="string">"\"\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The contents of the vector are \""</span></span><br><span class="line">        &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">"\", \""</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="string">"\"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">After</span> <span class="keyword">copy</span>, str <span class="keyword">is</span> "Hello"</span><br><span class="line"><span class="keyword">After</span> <span class="keyword">move</span>, str <span class="keyword">is</span> ""</span><br><span class="line">The contents <span class="keyword">of</span> the vector are "Hello", "Hello"</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】C语言的特殊输入问题</title>
      <link href="/2020/02/03/c-cpp-input/"/>
      <url>/2020/02/03/c-cpp-input/</url>
      
        <content type="html"><![CDATA[<p>在 <a href="https://pintia.cn" target="_blank" rel="noopener">PTA</a> 上问题碰到特殊输入问题，做个小的笔记。</p><p>在 <a href="https://blog.charjin.top/2020/02/04/pta-L2-012/">L2-012 关于堆的判断 (25分)</a> 这道题中，题目要求对给出的命题做判断，因为所给的命题是不确定的，无法在程序中直接使用<code>scanf</code>的格式化输入。最初通过<code>cin &gt;&gt; string</code>的方式读入数据，通过字符串解析、求子串取出数据，提交的代码出现运行时错误，之后是发现题目中说给的数据是包括负数的，包含负数对<code>扣数字</code>的操作又要麻烦不少。</p><p>后续通过<code>scanf</code>的<code>%*s</code>格式读入数据，也就是针对这一部分数据我不需要提供变量去接收。举例说明：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">5 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">46 </span><span class="number">23</span> <span class="number">26</span> <span class="number">24</span> <span class="number">10</span></span><br><span class="line"><span class="symbol">24 </span>is the root</span><br><span class="line"><span class="symbol">26 </span><span class="keyword">and</span> <span class="number">23</span> are siblings</span><br><span class="line"><span class="symbol">46 </span>is the parent of <span class="number">23</span></span><br><span class="line"><span class="symbol">23 </span>is a child of <span class="number">10</span></span><br></pre></td></tr></table></figure><p>题目给的输入是这样的，我需要在命题中取出数字。其中有一条<code>26 and 23 are siblings</code>判断是否为兄弟结点的命题，在输入的第三部分包含数字，所以最开始先使用<code>scanf(&quot;%d %s&quot;, &amp;a, temp);</code>接收，判断 <strong>temp</strong> 是否等于 <strong>and</strong>，如果是，则剩下的那部分，我可以直接使用<code>scanf(&quot;%d %*s %*s&quot;, &amp;b);</code>去读入，并把需要的数读入变量 <strong>b</strong>；如果不是，则剩下的命题中，判断是否为根节点的命题还剩下两个字符串未被接收，所以要再次使用<code>scanf(&quot;%*s %s&quot;, temp);</code>读入数据并判断 <strong>temp</strong> 是否为 <strong>root</strong>，问题出在不是 <strong>root</strong> 的情况。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">46 </span>is the parent of <span class="number">23</span></span><br><span class="line"><span class="symbol">23 </span>is a child of <span class="number">10</span></span><br></pre></td></tr></table></figure><p>针对这两条语句，还剩下 <strong>“of + 整型”</strong> 未被接收，因此我用了<code>scanf(&quot;of %d&quot;, &amp;b);</code>去接收剩下的字符串，但是程序一直出现错误，错误在于<code>of</code>前还需要加一个 <strong>空格</strong>。但为什么需要再加空格，我重新研究了一下scanf格式化输入的用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br></pre></td></tr></table></figure><p>上面两行代码其实是完全等价的，两个格式控制符之间如果没有空格，那么默认其存在一个空格。</p><p>但是实际上下面两行代码依旧是等价的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d    %d"</span>, &amp;a, &amp;b);</span><br></pre></td></tr></table></figure><p>输入 <u><strong>3&nbsp; &nbsp; &nbsp;  4</strong></u> 和输入 <u><strong>3&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;4</strong></u>，a、b都能被赋值，所以两个格式控制符之间无论存在多少个空格均表示的是要分别读入两个数值，不管其中存在多少个空格，这点在输入时也是一样的。</p><p>而这种默认含有分隔，只对两个相邻格式控制符适用，如果是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"z%d"</span>, &amp;a);</span><br></pre></td></tr></table></figure><p>则输入必须是<code>z+整型</code>，而如果是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"z %d"</span>, &amp;a);</span><br></pre></td></tr></table></figure><p>其实也是不管 <strong>z</strong> 之后有多少个空格，<strong>a</strong> 都是可以被输入的，例如输入 <u><strong>z &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 250</strong></u> 。</p><p>因此，针对最上面提到的题目，使用 <u><strong>scanf(“&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;&nbsp;&nbsp;&nbsp;%d”, &amp;b);</strong></u> 提交代码后结果也是正确的。那么，下回再遇到这类问题就尽情地打上空格吧 haha..</p><table><thead><tr><th align="left">类型</th><th align="left">合格的输入</th><th align="left">参数类型</th></tr></thead><tbody><tr><td align="left">%a %A</td><td align="left">读入一个浮点值(仅 C99 有效)。</td><td align="left">float *</td></tr><tr><td align="left">%c</td><td align="left">单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。</td><td align="left">char *</td></tr><tr><td align="left">%d</td><td align="left">十进制整数：数字前面的 + 或 - 号是可选的。</td><td align="left">int *</td></tr><tr><td align="left">%e %E %f %F %g %G</td><td align="left">浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4</td><td align="left">float *</td></tr><tr><td align="left">%i</td><td align="left">读入十进制，八进制，十六进制整数 。</td><td align="left">int *</td></tr><tr><td align="left">%o</td><td align="left">八进制整数。</td><td align="left">int *</td></tr><tr><td align="left">%s</td><td align="left">字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。</td><td align="left">char *</td></tr><tr><td align="left">%u</td><td align="left">无符号的十进制整数。</td><td align="left">unsigned int *</td></tr><tr><td align="left">%x %X</td><td align="left">十六进制整数。</td><td align="left">int *</td></tr><tr><td align="left">%p</td><td align="left">读入一个指针 。</td><td align="left"></td></tr><tr><td align="left">%[]</td><td align="left">扫描字符集合 。</td><td align="left"></td></tr><tr><td align="left">%%</td><td align="left">读 % 符号。</td><td align="left"></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> OJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】树状数组及查询第K小的数</title>
      <link href="/2020/02/03/algo-binary-indexed-trees/"/>
      <url>/2020/02/03/algo-binary-indexed-trees/</url>
      
        <content type="html"><![CDATA[<ul><li>宏定义<code>lowbit</code>函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-x))</span></span><br></pre></td></tr></table></figure><ul><li><code>add</code>函数，更新当前元素时将所有可分解出当前数的元素均加上 v</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; N; i += lowbit(i)) c[i] += v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>getSum</code>函数，得到前x个元素累加和</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> c[x] + getSum(x - lowbit(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>树状数组完整实现与应用：查询第K小的数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1025</span>;</span><br><span class="line"><span class="keyword">int</span> c[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; N; i += lowbit(i)) c[i] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> c[x] + getSum(x - lowbit(x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getKthLeast</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = N - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (getSum(mid) &gt;= k) right = mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, temp, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; temp, temp != <span class="number">-1</span>) &#123;</span><br><span class="line">            add(temp, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Input the k to search: "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"The k-th least number is %d\n"</span>, getKthLeast(k));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C/C++】string 类型基本用法</title>
      <link href="/2020/02/03/cpp-string/"/>
      <url>/2020/02/03/cpp-string/</url>
      
        <content type="html"><![CDATA[<p><code>string</code>  使用操作，引入 <code>#inlcude&lt;string&gt;</code> 与 <code>using namespace std;</code></p><ul><li>擦除元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.erase(<span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// 整型参数:(起始位置, 长度)</span></span><br><span class="line">s.erase(s.begin(), s.begin() + <span class="number">5</span>); <span class="comment">// 迭代器类型:(起始位置, 结束位置)</span></span><br></pre></td></tr></table></figure><ul><li>求子串</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; s.substr(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 整型参数:(起始位置, 长度) =&gt; 123</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.substr(<span class="number">5</span>);    <span class="comment">// 整型参数:(起始位置)到最后 =&gt; 56789</span></span><br></pre></td></tr></table></figure><ul><li>查找子串</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s.find(<span class="string">'4'</span>);  <span class="comment">// 查找字符, 返回找到的第一个字符'4'所在位置</span></span><br><span class="line">s.find(<span class="string">"345"</span>);  <span class="comment">// 查找字符串，返回找到的第一个"345"子串所在位置</span></span><br><span class="line"><span class="comment">// 参数含义与上相同</span></span><br><span class="line">s.find_first_of(<span class="string">'1'</span>);</span><br><span class="line">s.find_last_of(<span class="string">'1'</span>);</span><br><span class="line">s.find_first_not_of(<span class="string">'1'</span>);</span><br><span class="line">s.find_last_not_of(<span class="string">'1'</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】堆、堆排序、堆的应用</title>
      <link href="/2020/02/01/ds-heap/"/>
      <url>/2020/02/01/ds-heap/</url>
      
        <content type="html"><![CDATA[<ul><li>堆只关心 <strong>父子结点间</strong> 的大小关系，对兄弟结点不做要求，即只需要满足根结点总大于或小于所有孩子结点。</li><li>堆排序是选择排序的一种改进，选择排序进行 n - 1 遍历，每次选出最小的元素放在有序序列的最后一个位置，再在剩下的序列中选择最小的元素。所以选择排序产生的序列 <strong>前 m (&lt;= n) 项</strong> 总是有序的。</li></ul><ul><li><p>堆排序通过优化查找 <strong>最大或最小值</strong> 的时间改进快速排序。</p></li><li><p>升序排序，将原序列建成大顶堆（或是最大堆），大顶堆保证了树的根结点始终是该树中数值最大的元素，对外层遍历的时候，将堆的根节点与最后一个元素交换，这样就保证了序列的最后一个元素为最大值，再将剩下的 <code>n - i</code> （ <code>i</code>  是已经有序的元素个数）个元素重新调整成大顶推。</p></li></ul><h1 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h1><p>默认将堆中的结点元素视为整型，定义数组表示堆结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">heap</span><span class="params">(size)</span></span>; <span class="comment">// size 为结点数量</span></span><br></pre></td></tr></table></figure><h2 id="建立大顶堆"><a href="#建立大顶堆" class="headerlink" title="建立大顶堆"></a>建立大顶堆</h2><p>建堆过程，从最后一个非叶子结点开始，因为堆是个完全二叉树，使用数组存储，根结点存在下标为 <code>1</code> 的位置，<code>2 * i</code> 与 <code>2 * i + 1</code> 分别为第 <code>i</code> 个结点的孩子，因此最后一个结点的位置为 <code>n</code>，那么最后一个父亲结点位置为 <code>n / 2</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为是全局变量故省掉了参数 (vector&lt;int&gt; &amp;heap, int n), 下同</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;<span class="comment">// 从最后一个父亲结点向前移都是父亲结点</span></span><br><span class="line">        downAdjust(i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向下调整"><a href="#向下调整" class="headerlink" title="向下调整"></a>向下调整</h2><p><code>downAdjust</code> 向下调整是将当前子树（其实就可以看作为独立的一棵树）调整为以 <strong>根节点为最大值</strong> 的完全二叉树。调整过程，即如果当前结点均大于两个孩子结点，则将当前结点与两个孩子中 <strong>较大的结点</strong> 交换，再将所交换的孩子作为根结点继续向下调整。</p><p>最重要的，因为从最后一个父亲结点开始调整，因此，再往前调整其他的子树时就能保证其左右子树已经形成以根结点为最大值的树了，因此每次交换时总能把 <strong>左右子树中最大的值</strong> 换到根的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = i * i;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= high &amp;&amp; heap[j + <span class="number">1</span>] &gt; heap[j]) j = j + <span class="number">1</span>; <span class="comment">// 比 j++ 更直观</span></span><br><span class="line">        <span class="keyword">if</span> (heap[i] &gt;= heap[j]) <span class="keyword">break</span>;  <span class="comment">// 父结点大于或等于较大的孩子结点则直接退出</span></span><br><span class="line">        swap(heap[i], heap[j]);</span><br><span class="line">        i = j;</span><br><span class="line">        j = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是对大顶堆做调整，如果是小顶堆则直接修改注释行，为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (heap[i] &lt;= heap[j]) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h2 id="向上调整"><a href="#向上调整" class="headerlink" title="向上调整"></a>向上调整</h2><p>建堆过程实际上是对父子结点间无序的完全二叉树进行调整，如果在建堆完成后要插入新的结点，就必须重新对堆做调整，因为插入结点后，仍然要保持 CBT 的结构，因此必须也只能在堆的最后的一个位置后插入新结点，也就是数组的第 <code>n + 1</code> 个位置上。之后从新加入的结点开始 <strong>向上调整 (upAdjust)</strong> ，即如果该结点的值大于其父结点就一直向上交换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = high, j = i / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= low) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap[j] &gt;= heap[i]) <span class="keyword">break</span>;<span class="comment">// 父结点比新插入的结点大直接退出</span></span><br><span class="line">        swap(heap[j], heap[i]);</span><br><span class="line">        i = j;</span><br><span class="line">        j = i / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为向上调整只与父亲结点比较大小，因此不存在与较大值比较的情况，所以相对 <code>downAdjust</code> 少了一行代码。</p><p>用 <code>for</code> 循环有更简便的写法，但是逻辑上似乎没上面那么直观，考试编码时适用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = low, j = i * <span class="number">2</span>; j &lt;= high; i = j, j *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= high &amp;&amp; heap[j + <span class="number">1</span>] &gt; heap[j]) j++;</span><br><span class="line">        <span class="keyword">if</span> (heap[i] &gt;= heap[j]) <span class="keyword">break</span>;</span><br><span class="line">        swap(heap[i], heap[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = high, j = i / <span class="number">2</span>; j &gt;= low; i = j, j /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap[j] &lt;= heap[i]) <span class="keyword">break</span>;</span><br><span class="line">        swap(heap[j], heap[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆的插入与删除"><a href="#堆的插入与删除" class="headerlink" title="堆的插入与删除"></a>堆的插入与删除</h2><p>现在有了 <code>downAdjust</code> 和 <code>upAdjust</code>，在堆中 <strong>插入</strong> 和 <strong>删除</strong> 结点就变得很容易了。</p><ul><li>插入结点，即在 <strong>堆末尾</strong> 插入新结点，堆的大小 <strong>加一</strong> ，再从末尾元素向上调整。</li><li>删除结点，即取出根节点，将 <strong>最后一个结点作为根节点</strong> ，堆的大小 <strong>减一</strong> ，再从根节点向下调整。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在末尾插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertHeap</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    heap[++n] = x;</span><br><span class="line">    upAdjust(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除堆顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    heap[<span class="number">1</span>] = heap[n--];</span><br><span class="line">    downAdjust(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆的基本操作完结。</p><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序。堆虽然用数组存储，但是逻辑上是完全二叉树，对于选择排序中 <strong>找最大元素</strong> 的操作，对堆而言其实是 <code>O(1)</code> 的时间复杂度，但是因为每次取出最大元素后都要从根结点重新向下调整，这个调整的过程其实跟堆的层数有关，所以实际上在堆中取最大元素可以视作是 <code>O(logN)</code> 的时间复杂度，那么一共是 <code>n - 1</code> 次查找，所以堆排序的时间复杂度是 <code>O(N·logN)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    createHeap();   <span class="comment">// 先建堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        swap(heap[i], heap[<span class="number">1</span>]);  <span class="comment">// 将堆顶元素(最大值)与最后一个元素交换</span></span><br><span class="line">        downAdjust(<span class="number">1</span>, i - <span class="number">1</span>);  <span class="comment">// 将堆重新调整</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆的其他问题"><a href="#堆的其他问题" class="headerlink" title="堆的其他问题"></a>堆的其他问题</h1><p>在 <a href="https://pintia.cn/" target="_blank" rel="noopener">PTA</a> 上刷题，碰到考察判断某个序列是大顶堆还是小顶推或不是堆的题目。因此先留下写过的解决方案以便回顾。</p><ul><li><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805342821531648" target="_blank" rel="noopener">A1147 Heaps (30分)</a></li><li><a href="https://pintia.cn/problem-sets/994805342720868352/problems/1071785408849047552" target="_blank" rel="noopener">A1155 Heap Paths (30分)</a></li></ul><p>首先想到的是，堆是二叉树的结构，所以直接写成递归了。先考虑边界情况再做递归：</p><ol><li><p>如果是 <strong>空树或叶子结点</strong> 则视作是堆（A或B，如果A为真则不会执行B了，因此在一个 <code>if</code> 中判断）</p></li><li><p>如果是非叶子结点，则判断根结点与左右孩子是否符合根结点最大的条件（堆是完全二叉树，如果是非叶子结点至少能保证左孩子一定存在，因此同样在一个 <code>if</code> 中判断）</p></li><li><p>如果符合以上条件再递归地判断左右孩子是不是堆</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMaxHeap</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; n || i * <span class="number">2</span> &gt; n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (heap[i] &lt; heap[i * <span class="number">2</span>] || (i * <span class="number">2</span> + <span class="number">1</span> &lt;= n &amp;&amp; heap[i] &lt; heap[i * <span class="number">2</span> + <span class="number">1</span>])) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isMaxHeap(i * <span class="number">2</span>) &amp;&amp; isMaxHeap(i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMinHeap</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; n || i * <span class="number">2</span> &gt; n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (heap[i] &gt; heap[i * <span class="number">2</span>] || (i * <span class="number">2</span> + <span class="number">1</span> &lt;= n &amp;&amp; heap[i] &gt; heap[i * <span class="number">2</span> + <span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isMinHeap(i * <span class="number">2</span>) &amp;&amp; isMinHeap(i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法是正常思路，也算简洁，但却是蠢办法，哈哈。堆是完全二叉树，用数组存储，直接遍历一遍数组，判断一下父结点和孩子结点是不是满足大小关系不就好了吗，不满足直接返回 <code>false</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMaxHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (heap[i / <span class="number">2</span>] &lt; heap[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMinHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (heap[i / <span class="number">2</span>] &gt; heap[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h1><p>学习堆的时候，听到堆最常见的应用是实现优先队列。比如操作系统中的，优先级调度算法，当有优先级更高的任务来的时候，下一次要执行的应该是优先级更高的任务，而不是 <code>FIFO</code> 了。</p><p>恰好，在PTA中碰到这样一题：</p><ul><li><a href="https://pintia.cn/problem-sets/15/problems/841" target="_blank" rel="noopener">7-26 Windows消息队列 (25分)</a></li></ul><blockquote><p>消息队列是Windows系统的基础。对于每个进程，系统维护一个消息队列。如果在进程中有特定事件发生，如点击鼠标、文字改变等，系统将把这个消息加到队列当中。同时，如果队列不是空的，这一进程循环地从队列中按照优先级获取消息。请注意优先级值低意味着优先级高。请编辑程序模拟消息队列，将消息加到队列中以及从队列中获取消息。</p><p>输入格式:<br>输入首先给出正整数N（≤105），随后N行，每行给出一个指令—— <code>GET</code> 或 <code>PUT</code> ，分别表示从队列中取出消息或将消息添加到队列中。如果指令是 <code>PUT</code> ，后面就有一个消息名称、以及一个正整数表示消息的优先级，此数越小表示优先级越高。消息名称是长度不超过10个字符且不含空格的字符串；题目保证队列中消息的优先级无重复，且输入至少有一个 <code>GET</code>。</p><p>输出格式:<br>对于每个 <code>GET</code> 指令，在一行中输出消息队列中优先级最高的消息的名称和参数。如果消息队列中没有消息，输出 <code>EMPTY QUEUE!</code> 。对于 <code>PUT</code> 指令则没有输出。</p><p>输入样例:<br>9<br>PUT msg1 5<br>PUT msg2 4<br>GET<br>PUT msg3 2<br>PUT msg4 4<br>GET<br>GET<br>GET<br>GET  </p><p>输出样例:<br>msg2<br>msg3<br>msg4<br>msg1<br>EMPTY QUEUE!  </p></blockquote><p>因为题目说，优先级数值越小的优先级越高，所以这里应该用到小顶堆。每个消息包含  <strong>消息的内容</strong> 和 <strong>优先级数值</strong> ，因此需要创建结构体表示消息实体。优先队列中的 <code>PUT</code> 和 <code>GET</code> 对应的就是堆中的插入和删除操作，那么剩下的就很容易了。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> msg[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">int</span> prior;  <span class="comment">// priority</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node*&gt; heap;  <span class="comment">//地址传递减少开销</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = i * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= high &amp;&amp; heap[j + <span class="number">1</span>]-&gt;prior &lt; heap[j]-&gt;prior) j = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (heap[i]-&gt;prior &lt;= heap[j]-&gt;prior) <span class="keyword">break</span>;</span><br><span class="line">        swap(heap[i], heap[j]);</span><br><span class="line">        i = j;</span><br><span class="line">        j = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = high, j = i / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= low) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap[j]-&gt;prior &lt;= heap[i]-&gt;prior) <span class="keyword">break</span>;</span><br><span class="line">        swap(heap[j], heap[i]);</span><br><span class="line">        i = j;</span><br><span class="line">        j = i / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node* <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* root = heap[<span class="number">1</span>];</span><br><span class="line">    heap[<span class="number">1</span>] = heap[len--];</span><br><span class="line">    downAdjust(<span class="number">1</span>, len);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertHeap</span><span class="params">(node* Node)</span> </span>&#123;</span><br><span class="line">    heap[++len] = Node;</span><br><span class="line">    upAdjust(<span class="number">1</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    heap.resize(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">        <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'G'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"EMPTY QUEUE!\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                node* top = deleteMin();</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, top-&gt;msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node* Node = <span class="keyword">new</span> node;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, Node-&gt;msg, &amp;Node-&gt;prior);</span><br><span class="line">            insertHeap(Node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，为了减少值传递的时间消耗，在 <code>vector</code> 中以指针的形式存放数据，其他的逻辑都很清晰。用堆实现代码过程主要是为了复习堆的基本操作，但是在 <u>C++</u> 的标准模板库中已经包含对优先队列的实现，所以直接用 <code>priority_queue</code> 再写了一个代码版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> msg[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">int</span> prior;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; a) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;prior &gt; a.prior; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    <span class="keyword">int</span> n, prior;</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">        <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'G'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.empty()) <span class="built_in">printf</span>(<span class="string">"EMPTY QUEUE!\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, q.top().msg);</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node Node;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, Node.msg, &amp;Node.prior);</span><br><span class="line">            q.push(Node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <u>C++</u> 中的基础数据类型都有默认的大小比较方式，在 <code>priority_queue&lt;数据类型&gt;</code> 中可以直接使用，优先队列知道如何给元素进行调整，但是自己定义的结构体，对 <code>priority_queue</code> 而言，并不知道如何比较大小关系，因为 <code>priority_queue</code> 内部实现是用小于运算符对元素作比较，故需要在结构体中重载 <code>&lt;</code> 运算符，也可单独定义 <code>cmp</code> 函数作为优先队列的参数，但是谁会愿意使多写几行代码呢，哈哈。</p><p>注意：起初为了代码更简洁，使用 <code>string</code> 类型，以及<code>cin</code> 、<code>cout</code> 做输入输出，但是在题目输入最大规模数据量的样例中超时了，无奈改成了字符数组和 <code>scanf</code> 。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于堆的内容，这里已经记录的差不多了，作为笔记篇，主要为了方便今后自己复习查看。若有错误，麻烦读者指出。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆排序 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT 1063 Set Similarity (25分) 使用set与map的超时问题</title>
      <link href="/2020/02/01/cpp-set-map-overtime/"/>
      <url>/2020/02/01/cpp-set-map-overtime/</url>
      
        <content type="html"><![CDATA[<p>在 <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805409175420928" target="_blank" rel="noopener">1063 Set Similarity (25分)</a> 这道题目中，使用 unorderd_set 和 unordered_map 时出现超时问题，</p><p>Given two sets of integers, the similarity of the sets is defined to be <strong><em>Nc</em></strong>/<strong><em>Nt</em></strong>×100%, where <strong><em>Nc</em></strong> is the number of distinct common numbers shared by the two sets, and <em>Nt</em> is the total number of distinct numbers in the two sets. Your job is to calculate the similarity of any given pair of sets.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case first gives a positive integer <em>N</em> (≤50) which is the total number of sets. Then <em>N</em> lines follow, each gives a set with a positive <em>M</em> (≤10<sup>4</sup>) and followed by <em>M</em> integers in the range [0,109]. After the input of sets, a positive integer <em>K</em> (≤2000) is given, followed by <em>K</em> lines of queries. Each query gives a pair of set numbers (the sets are numbered from 1 to <em>N</em>). All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each query, print in one line the similarity of the sets, in the percentage form accurate up to 1 decimal place.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 99 87 101</span><br><span class="line">4 87 101 5 87</span><br><span class="line">7 99 101 18 5 135 18 99</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">50.0%</span><br><span class="line">33.3%</span><br></pre></td></tr></table></figure><ul><li>题意：<strong>Nc</strong> 是两个集合之间共有的值不相等的元素个数，意思是说两个集合（也不是真正意义上的集合）可能存在重复的值，那么两个集合间的共有元素可能会被重复计算，<strong>Nc</strong> 是指不同的这些“共有元素”的个数。<strong>Nt</strong> 是两个集合所有的不同元素的个数，简单说就是把两个集合合并，里面有多少个不同的元素。集合相似度就是 <strong>Nc/Nt</strong></li></ul><p>初始代码思路是，直接用集合存储数据，计算相似度的时候，先遍历第一个集合，用 map 记录出现过的元素，在遍历第二个集合的时候如果出现之前记录过的元素时，计算两集合重复的元素个数，然后两集合元素总数减去重复的数量就是所有不同元素的数量。相除即得到集合相似度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k, a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">            v[i].insert(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; vis;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : v[a]) vis[it] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : v[b])</span><br><span class="line">            <span class="keyword">if</span> (vis[it] == <span class="literal">true</span>) cnt++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.1f%%\n"</span>, cnt * <span class="number">1.0</span> / (v[a].size() + v[b].size() - cnt) * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是最后一个样例超时了，只得到21分。之后参考其他代码对原代码做改进：直接在一个集合中查找另一个集合元素中的元素，来计算重合元素的个数。</p><p>只对查找部分的代码做修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (k--) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">      <span class="keyword">int</span> nc = <span class="number">0</span>, nt = v[b].size();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> it : v[a]) &#123;</span><br><span class="line">          <span class="keyword">if</span> (v[b].find(it) == v[b].end()) nt++;<span class="comment">// 没找到总数+1</span></span><br><span class="line">          <span class="keyword">else</span> nc++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%.1f%%\n"</span>, nc * <span class="number">1.0</span> / nt * <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>分析：原本以为之前的方式简单快捷，实际上，使用 <code>unordered_map</code> 的思路对两个集合都需要做一次遍历，在 <code>unordered_map</code> 中插入元素时也需要消耗时间。后一种思路，实际上只遍历了一个集合中的元素，而在另一个集合中查找，因为 <code>unordered_set</code> 使用哈希表实现，对元素的查找几乎是常数级的时间复杂度，所以总体时间复杂度应该是 <code>O(M·N)</code> — M 是在另一集合中查找的平均查找次数。</p><p><strong>总结：</strong> 之后碰到类似的查找问题，直接使用 <code>unordered_set</code> 的 <code>find()</code> 函数是正确的选择，<code>unorderd_map</code> 也是同样的。如果需要用到有序的特性，再根据具体情况做选择。</p><p>最终代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k, a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">            v[i].insert(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">int</span> nc = <span class="number">0</span>, nt = v[b].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : v[a]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[b].find(it) == v[b].end()) nt++;</span><br><span class="line">            <span class="keyword">else</span> nc++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.1f%%\n"</span>, nc * <span class="number">1.0</span> / nt * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 编程 </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】树的同构 Isomorphism</title>
      <link href="/2020/02/01/algo-tree-isomorphic/"/>
      <url>/2020/02/01/algo-tree-isomorphic/</url>
      
        <content type="html"><![CDATA[<p>给定两棵树 T1 和 T2，如果 T1 可以通过若干次左右孩子互换变成 T2，则称两棵树是 <strong>同构</strong> 的。</p><p><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/ISomorphicTrees-e1368593305854.png" alt="以上两棵树为同构"></p><p>相关题目：</p><ul><li><a href="https://pintia.cn/problem-sets/15/problems/711" target="_blank" rel="noopener">7-3 树的同构 (25分)</a></li><li><a href="https://pintia.cn/problem-sets/16/problems/702" target="_blank" rel="noopener">6-7 Isomorphic (20分)</a></li></ul><p>分析（递归求解）：</p><ol><li>都为空树，视为同构 =&gt; True</li><li>其中一棵为 NULL =&gt; False</li><li>以上条件不满足，则两棵树均不为空，此时若值不相等，则不是同构 =&gt; False</li><li>当前两结点不空且值相等，递归判断以下条件是否符合<ul><li>T1 的左、右子树分别与 T2 的左、右子树为同构 或</li><li>T1 的左、右子树分别与 T2 的右、左子树为同构</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Isomorphic</span><span class="params">(Tree T1, Tree T2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T1 == <span class="literal">NULL</span> &amp;&amp; T2 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (T1 == <span class="literal">NULL</span> || T2 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (T1-&gt;Element != T2-&gt;Element) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (Isomorphic(T1-&gt;Left, T2-&gt;Left) &amp;&amp; Isomorphic(T1-&gt;Right, T2-&gt;Right)) ||</span><br><span class="line">           Isomorphic(T1-&gt;Left, T2-&gt;Right) &amp;&amp; Isomorphic(T1-&gt;Right, T2-&gt;Left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归求解 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】并查集</title>
      <link href="/2020/02/01/algo-union-find-set/"/>
      <url>/2020/02/01/algo-union-find-set/</url>
      
        <content type="html"><![CDATA[<p>不管后面写了啥，一定要把最重要的写在前面：（总记不住）</p><ul><li>使用并查集前 <strong>一定要初始化、一定要初始化、一定初始化</strong></li><li>用 <strong>findFather(i)</strong> 找根结点，不是 <strong>father[i]</strong> 数组</li></ul><h1 id="并查集的基本操作"><a href="#并查集的基本操作" class="headerlink" title="并查集的基本操作"></a>并查集的基本操作</h1><p>使用数组表示并查集：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> father[N];</span><br></pre></td></tr></table></figure><p><code>father[i]</code> 表示元素 <code>i</code> 的父亲结点</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始情况下，每个元素都是单独的集合，因此其父结点是自己，这在并查集中被称为 <u><strong>Reflexive</strong></u></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    father[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找与路径压缩"><a href="#查找与路径压缩" class="headerlink" title="查找与路径压缩"></a>查找与路径压缩</h2><p>一个集合中只有一个根结点，因此反复地查找父结点，直到 <code>father[x] == x</code> ，则 <code>x</code> 为该集合的根节点。</p><ul><li><p><strong>递推与递归方式查找根（无路径压缩）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推方式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != father[x]) &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == father[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> findFather(father[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的查找方式非常简单，但是对每个结点而言，要查找根总需要反复地向上找，比较费时，所以更好的办法是在查找根结点的同时，在路上把所有 <code>x</code> 的爸爸爷爷结点直接指向根。这样后面再找的时候时间就是 <code>O(1)</code> 了。</p></li><li><p><strong>递归方式查找根并压缩路径</strong></p><p>简单分析：</p><ol><li>若当前结点的父亲结点等于自己则表示找到了集合的根</li><li>若不相等，则递归地查找其父结点的根。同时，将当前结点的父结点直接指向根结点</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == father[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> fa = findFather(father[x]);</span><br><span class="line">    father[x] = fa;</span><br><span class="line">    <span class="keyword">return</span> fa;</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == father[x] ? x : father[x] = findFather(father[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>迭代的方式查找根结点与压缩路径</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = x;</span><br><span class="line">    <span class="keyword">while</span> (x != father[x]) x = father[x];</span><br><span class="line">    <span class="keyword">while</span> (z != father[z]) &#123;</span><br><span class="line">      <span class="keyword">int</span> z = a;</span><br><span class="line">      a = father[a];</span><br><span class="line">      father[z] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="合并集合"><a href="#合并集合" class="headerlink" title="合并集合"></a>合并集合</h2><p>将两个集合合并在一起，只需要找到两个集合的根，将其中一个根的父结点设为另一个根即可。因为和 C/C++ 中的 <code>union</code> 关键字冲突，所以函数写成了 <code>uni</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span> (faA != faB) father[faA] = faB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并查集解题中的习惯操作"><a href="#并查集解题中的习惯操作" class="headerlink" title="并查集解题中的习惯操作"></a>并查集解题中的习惯操作</h1><p>并查集有一些基础的常规操作，为了缩短在编程考试中减少对“常规”操作的思考时间（虽然也很简单），故记录下来，形成自己习惯性的模板代码。</p><h2 id="对象散列编号"><a href="#对象散列编号" class="headerlink" title="对象散列编号"></a>对象散列编号</h2><p>题目中常常给定的元素编号是连续的，通常是 <strong><em>1~N</em></strong> ，因此可以直接将对象 id 作为下标，表示其在并查集中的位置，但是有时候给定的是字符串，或是给定的范围很大，这个时候需要对每个元素重新编号，最好的方式是 <strong>从序号1开始，用两个map分别做 id-&gt;num 和 num-&gt;id 的映射</strong> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">1</span>;<span class="comment">// 初始编号从 1 开始</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; idToNum;<span class="comment">// 不管给定的是什么类型和数据，都管它叫 id</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; numToId;<span class="comment">// num 即编号</span></span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;<span class="comment">// T 为给定要循环输入的次数</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">int</span> ta, tb;</span><br><span class="line">        <span class="keyword">if</span> (idToNum[a] != <span class="number">0</span>) ta = idToNum[a];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            numToId[pos] = a;</span><br><span class="line">            idToNum[a] = pos;</span><br><span class="line">            ta = pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idToNum[b] != <span class="number">0</span>) tb = idToNum[b];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            numToId[pos] = b;</span><br><span class="line">            idToNum[b] = pos;</span><br><span class="line">            tb = pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        uni(ta, tb);<span class="comment">// 合并 ta、tb</span></span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用-unordered-set-记录序号非连续元素"><a href="#用-unordered-set-记录序号非连续元素" class="headerlink" title="用 unordered_set 记录序号非连续元素"></a>用 unordered_set 记录序号非连续元素</h2><p>有时候题目给定了元素的编号，并且这个编号在合理的范围内，但是编号不连续，因为并查集建立完成后需要遍历所有元素以找出不同集合，所以，如果是不连续的元素编号则可以使用 <code>unordered_set</code> 记录输入的元素，之前想过用 <code>vector</code> 但是可能出现重复输入一样的编号，所以不适用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">string</span> a, b;</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 有些时候需要判断a、b是否不为-1</span></span><br><span class="line">    s.insert(a);</span><br><span class="line">    s.insert(b);</span><br><span class="line">    ...</span><br><span class="line">    uni(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : s) &#123;</span><br><span class="line">    <span class="keyword">int</span> fa = findFather(it);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历元素查找集合"><a href="#遍历元素查找集合" class="headerlink" title="遍历元素查找集合"></a>遍历元素查找集合</h2><p>在并查集建立好之后，需要找出各个集合对之做操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pos; i++) &#123;<span class="comment">// 如果无需做散列，则是 1~N</span></span><br><span class="line">    <span class="keyword">int</span> fa = findFather(numToId[i]);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候需要将一个集合作为一个结构去看，其中需要保存一些题目要求的数据，并做排序。则要用到 map 和 vector</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> ...properties... &#125;;</span><br><span class="line">......</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, node&gt; mp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pos; i++) &#123;<span class="comment">// 如果无需做散列，则是 1~N</span></span><br><span class="line">    <span class="keyword">int</span> fa = findFather(numToId[i]);</span><br><span class="line">    mp[fa].property1 = ... ;</span><br><span class="line">    mp[fa].property2 = ... ;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : mp) ans.push_back(it.second);</span><br><span class="line">sort(ans.begin(), ans.end(), cmp);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】堆栈模拟队列</title>
      <link href="/2020/02/01/ds-stack-queue/"/>
      <url>/2020/02/01/ds-stack-queue/</url>
      
        <content type="html"><![CDATA[<p>相关题目： <a href="https://pintia.cn/problem-sets/15/problems/837" target="_blank" rel="noopener">7-22 堆栈模拟队列 (25分)</a></p><ol><li>将两个堆栈编号为s1、s2 （将容量较小的栈编号为 s1）</li><li>用较小的栈作为临时存储栈（保证临时栈满时能完全移动到输出栈，即 s1 做临时栈）<ul><li><code>Push</code> 操作，将元素压入 s1</li><li><code>Pop</code> 操作，在 s2 中取栈顶元素</li><li>即临时栈负责进，输出栈负责出</li></ul></li><li><code>Push</code> 操作<ul><li>若 s1 不满，则直接压入 s1</li><li>若 s1 满且 s2 为空，则将 s1 中的元素全部移至 s2，将新元素压入 s1</li><li>若 s1 满且 s2 不为空，则视栈满，即队列已满（ERROR: FULL）</li></ul></li><li><code>Pop</code> 操作<ul><li>若 s2 不为空，则直接取 s2 的栈顶元素（Print *Top）</li><li>若 s2 为空：<ul><li>s1 为空，则表示队列为空，<code>Pop</code> 操作失败（ERROR: Empty）</li><li>s1 不为空，则将 s1 的全部元素移至 s2 ，取出 s2 的栈顶元素 (Print *Top)</li></ul></li></ul></li></ol><hr><h1 id="7-22-堆栈模拟队列-25分"><a href="#7-22-堆栈模拟队列-25分" class="headerlink" title="7-22 堆栈模拟队列 (25分)"></a>7-22 堆栈模拟队列 (25分)</h1><p>设已知有两个堆栈S1和S2，请用这两个堆栈模拟出一个队列Q。</p><p>所谓用堆栈模拟队列，实际上就是通过调用堆栈的下列操作函数:</p><ul><li><code>int IsFull(Stack S)</code>：判断堆栈<code>S</code>是否已满，返回1或0；</li><li><code>int IsEmpty (Stack S )</code>：判断堆栈<code>S</code>是否为空，返回1或0；</li><li><code>void Push(Stack S, ElementType item )</code>：将元素<code>item</code>压入堆栈<code>S</code>；</li><li><code>ElementType Pop(Stack S )</code>：删除并返回<code>S</code>的栈顶元素。</li></ul><p>实现队列的操作，即入队<code>void AddQ(ElementType item)</code>和出队<code>ElementType DeleteQ()</code>。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入首先给出两个正整数<code>N1</code>和<code>N2</code>，表示堆栈<code>S1</code>和<code>S2</code>的最大容量。随后给出一系列的队列操作：<code>A  item</code>表示将<code>item</code>入列（这里假设<code>item</code>为整型数字）；<code>D</code>表示出队操作；<code>T</code>表示输入结束。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对输入中的每个<code>D</code>操作，输出相应出队的数字，或者错误信息<code>ERROR:Empty</code>。如果入队操作无法执行，也需要输出<code>ERROR:Full</code>。每个输出占1行。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">A 1 A 2 A 3 A 4 A 5 D A 6 D A 7 D A 8 D D D D T</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ERROR:Full</span><br><span class="line">1</span><br><span class="line">ERROR:Full</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">ERROR:Empty</span><br></pre></td></tr></table></figure><p>根据以上描述写出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; &amp;s1, <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; &amp;s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!s1.empty()) &#123;</span><br><span class="line">        s2.push(s1.top());</span><br><span class="line">        s1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1, n2, x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n1, &amp;n2);</span><br><span class="line">    <span class="keyword">if</span> (n1 &gt; n2) swap(n1, n2);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1, s2;</span><br><span class="line">    <span class="keyword">char</span> op;</span><br><span class="line">    <span class="keyword">while</span> (op = getchar(), op != <span class="string">'T'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">'A'</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %d "</span>, &amp;x);</span><br><span class="line">            <span class="keyword">if</span> (s1.size() &lt; n1) s1.push(x);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s2.size() != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"ERROR:Full\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                move(s1, s2);</span><br><span class="line">                s1.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getchar();  <span class="comment">// 接收后一个空格</span></span><br><span class="line">            <span class="keyword">if</span> (!s2.empty()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s2.top());</span><br><span class="line">                s2.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s1.empty()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"ERROR:Empty\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                move(s1, s2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s2.top());</span><br><span class="line">                s2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】动态规划</title>
      <link href="/2020/01/29/dynamic-prgramming/"/>
      <url>/2020/01/29/dynamic-prgramming/</url>
      
        <content type="html"><![CDATA[<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>有n件物品，每件物品的重量为w[i]，价值为c[i]。现有一个重量为V的背包，问如何选取物品放入背包，使得背包内物品的总价值最大。其中每种物品只有1件。</p><ul><li>dp[i][v] 表示前 i 件物品恰好装入容量为 v 的背包所能获得的最大价值<ul><li>不放第i件物品，则 <code>dp[i][v] = dp[i-1][v]</code></li><li>放第i件物品，那么问题转化为前 i–1 件物品恰好装入容量j – w[i]的背包中所能获得的最大价值 <code>dp[i-1][v-w[i]] + c[i]</code></li></ul></li><li>递推方程<code>dp[i][v] = max(dp[i-1][v], dp[i-1][v-w[i]]+c[i]);</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 基础知识点记录</title>
      <link href="/2020/01/22/spring-basics/"/>
      <url>/2020/01/22/spring-basics/</url>
      
        <content type="html"><![CDATA[<p><code>@ContextConfiguration</code> 注解引入 Spring 配置文件，通过value只能引用XML配置文件<br>@ContextConfiguration(value= [“classpath:chapter3-config.xml”])<br>@ContextConfiguration(classes = [Cha3Config::class])</p><p>在Spring5中 <code>@SpringJUnitConfig</code> 注解代替 <code>@ExtendWith(SpringExtension::class)</code> 和 <code>@ContextConfiguration(classes = [Cha3Config::class])</code>, 但是在引用配置文件时需要使用value属性而不是classes，即 <code>@SpringJUnitConfig(value = [Cha3Config::class])</code></p>]]></content>
      
      
      <categories>
          
          <category> 开发框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】Kotlin 作用域函数</title>
      <link href="/2020/01/22/kotlin-inline-functions/"/>
      <url>/2020/01/22/kotlin-inline-functions/</url>
      
        <content type="html"><![CDATA[<p>官方参考资料：<a href="https://kotlinlang.org/docs/reference/scope-functions.html" target="_blank" rel="noopener">https://kotlinlang.org/docs/reference/scope-functions.html</a></p><p>Kotlin 的 <strong>Scope Functions</strong> 包括 let、run、with、apply、also 等</p><blockquote><p>Basically, these functions do the same: execute a block of code on an object. What’s different is how this object becomes available inside the block and what is the result of the whole expression.</p></blockquote><p>Kotlin 中的作用域函数使用上非常相似，它们之间的主要区别在于：</p><ul><li>引用上下文对象的方式<ul><li>run、with、apply 将 Context Object 作为 lambda 的接收器</li><li>let 和 also 则将上下文对象作为 lambda 表达式参数</li></ul></li><li>返回值<ul><li>apply、also 返回上下文对象本身</li><li>let、run、with 返回 lambda 表达式的结果 （最后一条语句的执行结果）</li></ul></li></ul><p>举一个适合比较的例子，在 apply 和 let 的函数定义上即可看出：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>apply 函数需要一个 block 作为参数，这个参数的类型为 <code>T.() -&gt; Unit</code>（在 Kotlin 中函数也能作为参数），这个类型表示 block 为一个无参且无返回值的函数，那么为什么不定义为 <code>() -&gt; Unit</code> ，上面说到，apply 将上下文对象作为接收者，实际上它是 block 的接收者，通过这样的定义，我可以在 block 中通过 <code>this</code> 关键字使用该接收者的方法与属性，或是缺省方式直接引用方法与属性。而 apply 函数的返回类型为 T，即这个上下文对象。</p><p>与之相比，<code>let</code> 函数的定义更好理解了，let 函数同样需要一个 block 作为参数，这个参数是一个 <strong>以 T 为参数，以 R 为返回类型</strong> 的函数。因此根据 Kotlin 的语法特性，T 作为参数，我可以声明符合语法规定的参数名来使用它（默认为 it），而 block 函数的结果 R，实际上也是 let 函数的返回结果。</p><h1 id="Fun1-apply"><a href="#Fun1-apply" class="headerlink" title="Fun1: apply()"></a>Fun1: apply()</h1><p>apply 返回对象本身，适合在创建实例时，对非构造器参数做初始化</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span>, <span class="keyword">var</span> city: String = <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> adam = Person(<span class="string">"Adam"</span>).apply &#123; </span><br><span class="line">        age = <span class="number">20</span>                       <span class="comment">// same as this.age = 20 or adam.age = 20</span></span><br><span class="line">        city = <span class="string">"London"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处缺省 <code>this</code> 关键字，如果在该对象声明处所在Scope中有与之成员变量重名的<br>属性时候，需要添加this，即 <code>this.length = 4</code>.</p><h1 id="Fun2-with"><a href="#Fun2-with" class="headerlink" title="Fun2: with()"></a>Fun2: with()</h1><p>with 不是一个扩展函数，而是直接将对象传入作为参数</p><blockquote><p>We recommend <code>with</code> for calling functions on the context object without providing the lambda result. In the code, <code>with</code> can be read as “<em>with this object, do the following.</em>”</p></blockquote><p>官方推荐用 <code>with</code> 来调用上下文对象上的函数，而不使用 lambda 表达式的结果，这可被理解为“对于该对象，执行以下操作”。例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = mutableListOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>)</span><br><span class="line">with(numbers) &#123;</span><br><span class="line">    println(<span class="string">"'with' is called with argument <span class="variable">$this</span>"</span>)</span><br><span class="line">    println(<span class="string">"It contains <span class="variable">$size</span> elements"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从语义上来说，以这种方式使用 <code>with</code> 函数是相对恰当的，但是也有另一种适合的使用场景：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = mutableListOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>)</span><br><span class="line"><span class="keyword">val</span> firstAndLast = with(numbers) &#123;</span><br><span class="line">    <span class="string">"The first element is <span class="subst">$&#123;first()&#125;</span>,"</span> +</span><br><span class="line">    <span class="string">" the last element is <span class="subst">$&#123;last()&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line">println(firstAndLast)</span><br></pre></td></tr></table></figure><p>with 引入一个辅助对象，通过该对象的方法和属性计算得到另一个结果并通过 lambda 表达式返回。为了方便从语义上理解，我认为这可以视作是“with(某个对象)得到结果”。</p><p><strong>适用场景：</strong>需要大量使用某对象的方法时，例如，在Android开发中，通过 model 对 RecyclerView 的 item 进行数据绑定的时候。</p><h1 id="Function3：let"><a href="#Function3：let" class="headerlink" title="Function3：let()"></a>Function3：let()</h1><p>let 函数常用方式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person(<span class="string">"Alice"</span>, <span class="number">20</span>, <span class="string">"Amsterdam"</span>).let &#123;</span><br><span class="line">    println(it)</span><br><span class="line">    it.moveTo(<span class="string">"London"</span>)</span><br><span class="line">    it.incrementAge()</span><br><span class="line">    println(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上不添加 <code>.let</code> 则是代码是这样的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> alice = Person(<span class="string">"Alice"</span>, <span class="number">20</span>, <span class="string">"Amsterdam"</span>)</span><br><span class="line">println(alice)</span><br><span class="line">alice.moveTo(<span class="string">"London"</span>)</span><br><span class="line">alice.incrementAge()</span><br><span class="line">println(alice)</span><br></pre></td></tr></table></figure><p>区别在于后者必须引入变量来对 Person 对象做引用，而不巧的也许是变量  <code>alice</code> 在当前域中只使用这么一次，因此这种写法就不太优雅了</p><p><strong>适用场景：</strong>仅执行某个类（或是 Util 类）中的方法，而这个类的对象并不会在下文产生引用</p><table><thead><tr><th align="left">函数</th><th align="left">对象引用</th><th align="left">返回值</th><th align="left">是否是扩展函数</th></tr></thead><tbody><tr><td align="left"><code>let</code></td><td align="left"><code>it</code></td><td align="left">Lambda 表达式结果</td><td align="left">是</td></tr><tr><td align="left"><code>run</code></td><td align="left"><code>this</code></td><td align="left">Lambda 表达式结果</td><td align="left">是</td></tr><tr><td align="left"><code>run</code></td><td align="left">-</td><td align="left">Lambda 表达式结果</td><td align="left">不是：调用无需上下文对象</td></tr><tr><td align="left"><code>with</code></td><td align="left"><code>this</code></td><td align="left">Lambda 表达式结果</td><td align="left">不是：把上下文对象当做参数</td></tr><tr><td align="left"><code>apply</code></td><td align="left"><code>this</code></td><td align="left">上下文对象</td><td align="left">是</td></tr><tr><td align="left"><code>also</code></td><td align="left"><code>it</code></td><td align="left">上下文对象</td><td align="left">是</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 中JUnit单元测试问题</title>
      <link href="/2020/01/17/spring-junit5/"/>
      <url>/2020/01/17/spring-junit5/</url>
      
        <content type="html"><![CDATA[<p>最近在读 Spring in Action 4th，书中包含不少单元测试的样例，基础格式：(示例语言 <code>Kotlin</code> )</p><a id="more"></a><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> springinaction</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner::class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = [JavaConfig::class])</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> ...<span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testConfig</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Spring 的项目开发中，单元测试是常见的临时测试代码模块的方式，以上格式主要是包含两个类级注解 <code>@RunWith</code>，<code>@ContextConfiguration</code>，其中 <code>@RunWith</code> 如其名，意思是让当前的单元测试以怎样的环境运行，这里使用Spring的 <code>SpringJUnit4ClassRunner</code>，用于在测试时自动创建Spring的应用上下文 (<strong>Context</strong> 我更偏向于翻译成运行环境)，该 Context 具体做怎样的配置在于 <code>@ContextConfiguration</code> 注解中所传入的基于Java的配置类，这个类应至少标上 <code>@Configuration</code> 注解，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> springinaction</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> ...<span class="title">Config</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">createJaveBean</span><span class="params">()</span></span> : JaveBean = JavaBean()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- more --><p>其中，<code>@ComponentScan</code> 注解不是必需的，其作用是查找与本类在同一 <strong>package</strong> 下且通过注解方式注入 Spring 容器的 JavaBean (未提供参数，则默认在本类所在的package中扫描) 并将其创建添加至容器。</p><p>为节省配置Spring依赖的时间，我使用 <strong>Spring Boot</strong> 和 <strong>Gradle</strong> 构建项目以做示例实现，但在项目构建结束后无法找到 <code>@RunWith</code> 注解，虽说在Spring Boot中可使用 <code>@SpringBootTest</code> 注解作为代替，但是我仍旧想解决 <code>@RunWith</code> 无法找到的问题，Google一下并未找到解决方案，或说大多解决方案是添加 <code>spring-boot-test-starter</code> 相关依赖，但这不是问题的原因。</p><p>于是，查找官方文档，在JUnit5的 <a href="https://junit.org/junit5/docs/current/user-guide/" target="_blank" rel="noopener">User Guide</a> 中，关于 <strong><a href="https://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4-tips" target="_blank" rel="noopener">Migrating from JUnit4</a></strong> 章节中找到如下描述：</p><blockquote><h3 id="3-2-Migration-Tips"><a href="#3-2-Migration-Tips" class="headerlink" title="3.2. Migration Tips"></a>3.2. Migration Tips</h3><p>The following are topics that you should be aware of when migrating existing JUnit 4 tests to JUnit Jupiter.</p><ul><li>Annotations reside in the <code>org.junit.jupiter.api</code> package.</li><li>Assertions reside in <code>org.junit.jupiter.api.Assertions</code>.<ul><li>Note that you may continue to use assertion methods from <code>org.junit.Assert</code> or any other assertion library such as <a href="https://joel-costigliola.github.io/assertj/" target="_blank" rel="noopener">AssertJ</a>, <a href="https://hamcrest.org/JavaHamcrest/" target="_blank" rel="noopener">Hamcrest</a>, <a href="https://google.github.io/truth/" target="_blank" rel="noopener">Truth</a>, etc.</li></ul></li><li>Assumptions reside in <code>org.junit.jupiter.api.Assumptions</code>.<ul><li>Note that JUnit Jupiter 5.4 and later versions support methods from JUnit 4’s <code>org.junit.Assume</code> class for assumptions. Specifically, JUnit Jupiter supports JUnit 4’s <code>AssumptionViolatedException</code> to signal that a test should be aborted instead of marked as a failure.</li></ul></li><li><code>@Before</code> and <code>@After</code> no longer exist; use <code>@BeforeEach</code> and <code>@AfterEach</code> instead.</li><li><code>@BeforeClass</code> and <code>@AfterClass</code> no longer exist; use <code>@BeforeAll</code> and <code>@AfterAll</code> instead.</li><li><code>@Ignore</code> no longer exists: use <code>@Disabled</code> or one of the other built-in <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-conditional-execution" target="_blank" rel="noopener">execution conditions</a> instead<ul><li>See also <a href="https://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4-ignore-annotation-support" target="_blank" rel="noopener">JUnit 4 @Ignore Support</a>.</li></ul></li><li><code>@Category</code> no longer exists; use <code>@Tag</code> instead.</li><li><code>@RunWith</code> no longer exists; superseded by <code>@ExtendWith</code>.</li><li><code>@Rule</code> and <code>@ClassRule</code> no longer exist; superseded by <code>@ExtendWith</code> and <code>@RegisterExtension</code><ul><li>See also <a href="https://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4-rule-support" target="_blank" rel="noopener">Limited JUnit 4 Rule Support</a>.</li></ul></li></ul></blockquote><p>之前的注解类现在位于 <code>org.junit.jupiter.api</code>包中，经查看，在新的 JUnit5 中此前 <code>@RunWith</code> 注解所在的 <code>org.junit.runner</code> 包已经不存在，且文档中提到 <u><code>@RunWith</code> no longer exists; superseded by <code>@ExtendWith.</code></u> ，即 <code>@RunWith</code> 将由 <code>@ExtendWith</code> 替代。至此，这个问题解决了，只要替换下注解节即可。</p><p>但实际上 <code>@ExtendWith</code> 与 <code>@RunWith</code> 有所区别，<code>@ExtendWith</code> 无法接收 <code>SpringJUnit4ClassRunner::class</code> 作为参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Repeatable</span>(Extensions<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">API</span>(<span class="title">status</span> </span>= STABLE, since = <span class="string">"5.0"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExtendWith &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An array of one or more &#123;<span class="doctag">@link</span> Extension&#125; classes to register.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;? extends Extension&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看到它接收任意一个实现了 <code>Extension</code> 接口的Java类 <strong>数组</strong> ，那么为了得到与 <code>@RunWith(SpringJUnit4ClassRunner::class)</code> 等价的效果，需要在 <code>@ExtendWith</code> 注解中传入 <code>SpringExtension::class</code>，即 <code>@ExtendWith(SpringExtension::class)</code> (传入单个值可不以数组形式)。为了更加理解 Extension 的作用，我查看源码，在 SpringExtension 的类注释中看到以下描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> SpringExtension&#125; integrates the &lt;em&gt;Spring TestContext Framework&lt;/em&gt;</span></span><br><span class="line"><span class="comment"> * into JUnit 5's &lt;em&gt;Jupiter&lt;/em&gt; programming model.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;To use this extension, simply annotate a JUnit Jupiter based test class with</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@ExtendWith</span>(SpringExtension.class)&#125;, &#123;<span class="doctag">@code</span> <span class="doctag">@SpringJUnitConfig</span>&#125;, or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@SpringJUnitWebConfig</span>&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br></pre></td></tr></table></figure><p>即，SpringExtension将Spring的测试上下文框架集成到JUnit 5的Jupiter编程模型中。</p><p>对于 JUnit Jupiter，官方文档是这样解释的：</p><blockquote><p><strong>JUnit Jupiter</strong> is the combination of the new <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests" target="_blank" rel="noopener">programming model</a> and <a href="https://junit.org/junit5/docs/current/user-guide/#extensions" target="_blank" rel="noopener">extension model</a> for writing tests and extensions in JUnit 5. The Jupiter sub-project provides a <code>TestEngine</code> for running Jupiter based tests on the platform.</p></blockquote><p>它是新的 <strong>编程模型</strong> 与 <strong>扩展模型</strong> 的结合，以我自己的理解方式，新的编程模型，即在新的 JUnit5 中较 Junit4 新的改进，很表面的变化可以说包含了一些新的用于测试的注解与注解更名，而大的变化在于与扩展模型的结合，在 JUnit4.0 中，对一个测试类而言，只有一种扩展JUnit的方式，即创建一个新的Runner，然后在测试类上添加 <code>@RunWith(MyRunner::class)</code>注解，也就是形如前文描述的那样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner::class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = [JavaConfig::class])</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> ...<span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testConfig</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为仅有一种扩展方式，因此</p><div style="font-size: 40px; font-weight: 500;">待补充。</div>]]></content>
      
      
      <categories>
          
          <category> 开发框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> JUnit </tag>
            
            <tag> 单元测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019的简短总结与Quick Sort之动态规划</title>
      <link href="/2020/01/05/pat-a1101-b1045/"/>
      <url>/2020/01/05/pat-a1101-b1045/</url>
      
        <content type="html"><![CDATA[<p>离上一篇<a href="https://blog.charjin.top/2019/09/13/the-first-pat-advanced"> PAT甲级2019秋季 - 初考总结篇 </a>的文章已经过去接近4个月的时间，大四上学年这最后几个月，亦有忙碌亦有清闲之时，有收获却感觉失去的更多，最大的遗憾或是没参加2020的研究生考试，是所谓对的决定还是逃避的表现，心里的答案已经给了后者。最早决定考研的人没有走上考场，而在21号清晨7点一刻看涌向学校的考生和比平时繁多的接送车，心里默默给他们和在绍兴的雨斌加油，思考来年自己是不是也和他们一个样子。今天收拾完行李，把没翻过几次的两大箱书寄回家，想到去年离家至今已快满一年，这接近一年的时间除了在脑子里装进了几个梦和被岁月在我头顶夺走几缕秀发外，没什么别的变化。后天走上归程，期待儿子回家的老妈肯定还是认为这是那个优秀的大儿子，(感叹) 早就想回温州吃10碗瘦肉丸和老妈做的饭了。</p><a id="more"></a><p>现在，整顿过后杂乱的房间，终于有点要离开的样子了，没有室友的房间并没什么与室友告别的伤感，待到下次回来，这里也只是个留宿之地了。</p><p>搭建这个博客起初的目的也想记录生活，但写下的完整的博文也是寥寥无几。唯一还有的好习惯便是每天至少做几道编程题了。安静下来，假期后的周边也不再喧闹，写道题回去继续开始。</p><hr><p>题目来源:</p><ul><li><a href="https://pintia.cn/problem-sets/994805342720868352/problems/type/7" target="_blank" rel="noopener">PAT (Advanced Level) Practice</a></li><li><a href="https://pintia.cn/problem-sets/994805260223102976/problems/type/7" target="_blank" rel="noopener">PAT (Basic Level) Practice（中文）</a></li></ul><hr><h1 id="A1101-Quick-Sort-B1045-快速排序"><a href="#A1101-Quick-Sort-B1045-快速排序" class="headerlink" title="A1101 Quick Sort | B1045 快速排序"></a><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805366343188480" target="_blank" rel="noopener">A1101 Quick Sort</a><a href=""> | </a><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805278589960192">B1045 快速排序</a></h1><p>作者: CAO Peng, 单位: Google, 时间限制: 200 ms, 内存限制: 64 MB</p><blockquote><p>There is a classical process named <strong>partition</strong> in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given <strong>N</strong> distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition?</p><p>For example, given <strong>N</strong> = <strong>5</strong> and the numbers 1, 3, 2, 4, and 5. We have:</p><ul><li>1 could be the pivot since there is no element to its left and all the elements to its right are larger than it;</li><li>3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well;</li><li>2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well;</li><li>and for the similar reason, 4 and 5 could also be the pivot.<br>Hence in total there are 3 pivot candidates.</li></ul><p><strong>Input Specification:</strong><br>Each input file contains one test case. For each case, the first line gives a positive integer <strong><em>N</em></strong> (≤ <strong>10</strong><sup>5</sup>). Then the next line contains <strong><em>N</em></strong> distinct positive integers no larger than <strong>10</strong><sup>9</sup>. The numbers in a line are separated by spaces.</p><p><strong>Output Specification:</strong><br>For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line.</p><p><strong>Sample Input:</strong><br>5<br>1 3 2 4 5</p><p><strong>Sample Output:</strong><br>3<br>1 4 5</p></blockquote><ul><li>题意：简单地描述快速排序的过程，即每趟排序均选择一个主元，将序列中所有小于主元的数排在其左侧，反之，将大于该主元的数排在其右侧，再将该主元两侧的序列递归地通过此方式排序，最终可使该序列整体有序。题目要求在给定的序列中找出可能是主元的数，并升序输出。具体描述可参考本题的乙级中文版 <a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805278589960192" target="_blank" rel="noopener">1045 快速排序 (25分)</a></li><li>思路：题目中已经给出例子，实际上只需要遍历该序列，并判断当前元素是否比所有其左侧元素都大且比所有其右侧元素均小即可。</li></ul><p>哈哈…当然没这么简单啦。</p><p>这类题读完的第一反应是暴力解决，直接嵌套两个for循环，把符合条件的结果保存到 <code>vector</code> 中即能得到答案，第二反应是看时间限制，<code>200ms</code> ，题目中 <strong>N</strong> 的最大规模是 <strong>10<sup>5</sup></strong>，暴力法的时间复杂度 <code>O(n</code><sup><code>2</code></sup><code>)</code>，那么实际上问题规模就变成了 <strong>10<sup>10</sup></strong>，这个执行次数在最坏情况下所用的时间已经远远超过 <code>100s</code> 了，所以暴力法一定会存在超时的测试点。于是我立马想到了可以稍作优化的解决方案：在遍历过程中，如果已经判定当前元素可以作为主元，那么至少我能保证在这个元素之后的所有元素均是大于该数的，因此在对下一个元素进行判定的时候就不需要再将当前元素与所有前面的元素进行大小比较了，而是直接从上一个满足条件的主元开始，于是设置一个 <code>left</code> 变量来记录左侧判断时循环开始的位置。但是这种做法，时间复杂度的数量级还是 <code>O(n</code><sup><code>2</code></sup><code>)</code>，所以当n很大的时候这种优化并没有多少意义，但是执念还是让我把代码写出来了，哈哈。</p><p>提交代码如下，核心代码 <strong>9-28</strong> 行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; v(n), ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i]);</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;                 <span class="comment">// 设置标志位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt; i; j++) &#123;  <span class="comment">// 从left开始</span></span><br><span class="line">            <span class="keyword">if</span> (v[j] &gt; v[i]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 及时退出, 下同</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果左侧判断均通过则还需判定右侧, 因此循环条件中先加入flag</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; flag &amp;&amp; j &lt; v.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[j] &lt; v[i]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;  <span class="comment">// 符合条件, 添加进vector</span></span><br><span class="line">            ans.push_back(v[i]);</span><br><span class="line">            left = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.begin(), ans.end());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans.size());</span><br><span class="line">    <span class="keyword">if</span> (ans.size() == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果不出所料的，有两个样例没通过，拿到 <strong>20/25分</strong> (这题目考察点就在算法的时间复杂度上)</p><p><img src="/img/pat-a1101(1).png" alt="暴力法提交结果"><br>所以，这题暴力法行不通（但考试的时候如果能在10分钟内把25分题拿到20分那也不错了，可以先直接换到下一题，哈哈）。于是更换思路，像这种类型的题，还能想到的方法是动态规划。设立 <code>dp</code> 数组，<code>dp[i]</code> 存放 <code>v[0~i]</code> 中最大的值，那么，对于满足条件的元素 <code>dp[i]</code> 必定是等于 <code>v[i]</code> 的，因此根据dp的定义，可以得到这样的式子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(dp[i - <span class="number">1</span>], v[i]);</span><br></pre></td></tr></table></figure><p>实际上，在动态规划中，把 <code>dp[i]</code> 称为问题的状态，上面的式子称作状态转移方程。那么对于判断当前元素是否是大于所有左侧元素就变成了判断 <code>v[i]</code> 是否与 <code>dp[i]</code> 相等。</p><p>再次提交代码，核心代码 <strong>8-22</strong> 行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; v(n), dp(n), ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i]);</span><br><span class="line">    dp[<span class="number">0</span>] = v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>], v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] != v[i]) flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; flag &amp;&amp; j &lt; v.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[j] &lt; v[i]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) ans.push_back(v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.begin(), ans.end());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans.size());</span><br><span class="line">    <span class="keyword">if</span> (ans.size() == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果较暴力法又多对了一个样例 ^_^!!</p><p><img src="/img/pat-a1101(2).png" alt="动态规划提交结果"><br>在上面这个解法中，动态规划的思想只使用于判断左侧元素是否均小于当前元素，实际上时间复杂度还是 <code>O(n</code><sup><code>2</code></sup><code>)</code>。所以，对于右侧元素还是同理，再另设dpMin数组，<code>dpMin[i]</code> 存放 <code>v[i~(n-1)]</code> 中最小的值，状态转移方程为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpMin[n - i - <span class="number">1</span>] = min(dpMin[n - i], v[n - i - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>再次提交代码如下，核心代码 <strong>8-16</strong> 行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    vector&lt;int&gt; v(n), dpMax(n), dpMin(n), ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i]);</span><br><span class="line">    dpMax[<span class="number">0</span>] = v[<span class="number">0</span>];</span><br><span class="line">    dpMin[n - <span class="number">1</span>] = v[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dpMax[i] = max(dpMax[i - <span class="number">1</span>], v[i]);</span><br><span class="line">        dpMin[n - i - <span class="number">1</span>] = min(dpMin[n - i], v[n - i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dpMax[i] == v[i] &amp;&amp; dpMin[i] == v[i]) ans.push_back(v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.begin(), ans.end());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans.size());</span><br><span class="line">    <span class="keyword">if</span> (ans.size() == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果预料之内，本题终于 <code>AC</code> 了，惊呼amazing，哈哈</p><p><img src="/img/pat-a1101(3).png" alt="动态规划提交结果"><br>其中最耗时的样例（也许是最大规模的极端数据）只用了 44ms，而这一次的时间复杂度变成了 <code>O(n)</code>，在大规模的问题中，时间复杂度从 <strong>O(n<sup>2</sup>)</strong> 到 <strong>O(n)</strong> 是很大的优化。至此本题也结束。</p><p>这道题从 <u>暴力法</u> 到 <u>动态规划</u> 直至 AC，写代码的过程并没花多少时间，但是这个思路的快速转变也是自己很大的进步，虽然是最基础的动态规划思想的使用，但是也完全体现出了动态规划的魅力，也使代码变得简短直观。</p><blockquote><p>Ps: 提交完AC的代码，也查看了其他网友的解法，似乎没人用DP，也许是大材小用吧，哈哈。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>距离上次，去年9月8号参加PAT甲级秋季考试已经过去4个月，上次的考试经历可谓糟糕且是一塌糊涂，从那到现在一直不变的始终是每天做题的习惯。今年3月，春季的甲级考试希望能拿到100分。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> PAT </tag>
            
            <tag> 编程 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级2019秋季 - 初考总结篇</title>
      <link href="/2019/09/13/algo-pat2019-autumn-A/"/>
      <url>/2019/09/13/algo-pat2019-autumn-A/</url>
      
        <content type="html"><![CDATA[<p>上周末, 2019年9月8日, 终于结束了我 <a href="https://patest.cn" target="_blank" rel="noopener">PAT</a> 甲级的首次考试, 成绩 <strong>37/100, 1246/3943 (分数,排名)</strong>, 伤心之余, 记录并总结这次难得的经历与经验, 他日回首,方可对自己臭骂一句: <code>弱爆了</code>.</p><p>贴出 <a href="https://pintia.cn/market/item/1170913054376931328" target="_blank" rel="noopener">教育超市</a> 线上模拟后重新AC后的代码 <a href="/img/pat.html"><u>导出分析</u></a></p><h1 id="7-1-Forever-20-分"><a href="#7-1-Forever-20-分" class="headerlink" title="7-1 Forever (20 分)"></a>7-1 Forever (20 分)</h1><p>作者: 陈越, 单位: 浙江大学, 时间限制: 3000 ms, 内存限制: 64 MB</p><blockquote><p>“Forever number” is a positive integer <strong>A</strong> with <strong>K</strong> digits, satisfying the following constrains:</p><ul><li>the sum of all the digits of <strong>A</strong> is <em>m</em></li><li>the sum of all the digits of <strong>A+1</strong> is <em>n</em>; and</li><li>the greatest common divisor of m and n is a prime number which is greater than 2.</li></ul><p>Now you are supposed to find these forever numbers.</p><a id="more"></a><p><strong>Input Specification:</strong><br>Each input file contains one test case. For each test case, the first line contains a positive integer <strong>N</strong> (≤ <strong>5</strong>). Then N lines follow, each gives a pair of <strong>K</strong> (<strong>3</strong> &lt; <strong>K</strong> &lt; <strong>10</strong>) and m (<strong>1</strong> &lt; <strong>m</strong> &lt; <strong>90</strong>), of which the meanings are given in the problem description.</p><p><strong>Output Specification:</strong><br>For each pair of <strong>K</strong> and <em>m</em>, first print in a line <code>Case X</code>, where <code>X</code> is the case index (starts from 1). Then print n and <strong>A</strong> in the following line. The numbers must be separated by a space. If the solution is not unique, output in the ascending order of <em>n</em>. If still not unique, output in the ascending order of <strong>A</strong>. If there is no solution, output <code>No Solution</code>.</p><p><strong>Sample Input:</strong><br>2<br>6 45<br>7 80</p><p><strong>Sample Output:</strong><br>Case 1<br>10 189999<br>10 279999<br>10 369999<br>10 459999<br>10 549999<br>10 639999<br>10 729999<br>10 819999<br>10 909999<br>Case 2<br>No Solution</p></blockquote><p>这次的第一题坑了很多人, 以往的真题通常第一题都是十几分钟就能搞定的, 但是这次这个题的通过率是最低的. =_=!!</p><ul><li>大致题意: 定义一个”永远数”, 满足以下条件: 一个正整数 <strong>A</strong> 有<em>k</em> 位, 其每一位相加和为 <strong>m</strong>, 而 <strong>A+1</strong> 的每一位相加和为 <strong>n</strong>, 并且 <strong>m</strong> 和 <strong>n</strong> 的 <strong>最大公约数</strong> (这里把我坑惨了)是一个 <strong>大于2</strong> 的素数</li><li>答题过程: 开考后, 花一分钟读完第一题, 立马瞟了一眼时间限制, 给了3秒的时间, 那么长, 绝对是暴力法搞定. 立马把判定素数的函数先写出来<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>然后开始暴力枚举, 最初想的是k位, 假如是4位, 那么范围就是[1000, 9999], 用<code>pow</code>函数很轻松就得到<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minValue = <span class="built_in">pow</span>(<span class="number">10</span>, k - <span class="number">1</span>);</span><br><span class="line">maxValue = <span class="built_in">pow</span>(<span class="number">10</span>, k) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>然后依次获得每个数的各位之和 <strong>m</strong> 和 <strong>n</strong>, 再之后看一眼第三个定义条件, 抠脚操作就在这里开始了, <code>divisor</code>, divide是除的意思 好的, <code>divisor</code> 是除数. 然后用 <em>m</em> 和 <em>n</em> 中较大的除以较小的, 尝试提交样例测试代码,,,什么卵都没有, 错了, 哪错了, 从头到尾检查一遍代码, 难道不是 <strong>除数?</strong>, 余数是 remainder 啊, 不管了, 试试吧, 用大的数对小的数取余, 测试一次样例, 我去还是什么卵都没有, 难道是两数只差, 不可能, 但是也试试吧, 果不其然还是错. 放弃吧, 第一题用一个小时还没搞定我也是醉了. 然后第二题, 链表题, 噼里啪啦..对了, 终于AC了一道题, 心态好了些, 回到第一题, 再仔细读一遍题吧, 以前做真题因为没仔细读题错了好多次, <code>public common divisor</code> 最大公共除数不就是最大公约数吗, 换个叫法就不知道了我去. 这下恍然大悟, 但是又蒙了, 求最大公约数的代码好久没写过了, 怎么求? 突然脑子里想到大一学C语言的一个场景–”老冯说, 辗转相除法”, 我去就是这个, 但是怎么辗转呢 哈哈, 一顿噼里啪啦推导了几分钟, 搞定了, 开心地提交代码. 只过了两个样例, 12分, 啊, 暴力法时间复杂度 <strong>O(n<sup>10</sup>·k)</strong> 相对时间限制太高了. 绝望了, 第一题死活搞不定吗. 计时器只剩下70+分钟, 最后两题都没做, 先做后面的题吧…</li></ul><p><strong>当时提交的代码:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; a) swap(a, b);</span><br><span class="line">    <span class="keyword">int</span> c = b % a;</span><br><span class="line">    <span class="keyword">while</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        b = a;</span><br><span class="line">        a = c;</span><br><span class="line">        c = b % a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        sum += x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d\n"</span>, i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;k, &amp;m);</span><br><span class="line">        <span class="keyword">int</span> minValue = <span class="built_in">pow</span>(<span class="number">10</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="built_in">pow</span>(<span class="number">10</span>, k) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = minValue; j &lt;= maxValue; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> dm = getSum(j), dn = getSum(j + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (dm == m) &#123;</span><br><span class="line">                <span class="keyword">int</span> div = gcd(dm, dn);</span><br><span class="line">                <span class="keyword">if</span> (isPrime(div) &amp;&amp; div &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, dn, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No Solution\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后回来的第三天, 知乎上开始出现讨论 <strong>参加2019年9月8日秋季PAT测试是怎样的一种体验?</strong> 的话题, PAT的创始人兼主出题人 <a href="https://weibo.com/chenyuell?refer_flag=1005055013_" target="_blank" rel="noopener">陈越姥姥</a> 在里面回答各种问题, 大多都是吐槽最后二十分钟服务器崩掉不能提交和看题以及吐槽第一题暴力难AC的, 都被第一题难倒啦, 哈哈, 各种解法层出不穷: 暴力法, 打表, 排序, DFS… 但是姥姥说这题她的时间限制就是按照暴力解法定的,  今天我耐心的打表找一下规律, 每个满足条件的”Forever number”最后两位一定是 <strong>99</strong>, 考试的时候真的太蠢了, 如果不是99, 那么m和n差值为1, 最大公约数只能是1, 怎么可能大于2. 改进了局部代码试了一下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> minValue = <span class="built_in">pow</span>(<span class="number">10</span>, k - <span class="number">1</span> - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> maxValue = <span class="built_in">pow</span>(<span class="number">10</span>, k - <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = minValue; j &lt;= maxValue; j++) &#123;</span><br><span class="line">    <span class="keyword">int</span> dm = getSum(j) + <span class="number">18</span>, dn = getSum(j * <span class="number">100</span> + <span class="number">99</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (dm == m) &#123;</span><br><span class="line">        <span class="keyword">int</span> div = gcd(dm, dn);</span><br><span class="line">        <span class="keyword">if</span> (isPrime(div) &amp;&amp; div &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, dn, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然最后两位一定是99, 那么一个 <strong>k</strong> 位数, 我只需要枚举 <strong>k-2</strong> 位数, 然后*100+99得到实际数值即可, 改进之后, 在 <a href="https://pintia.cn/market/item/1170913054376931328" target="_blank" rel="noopener">PTA拼题教育超市</a> 重新购买考试卷模拟考试之后, 重新提交代码, 有进步, 最后一个测试样例不超时了, 但是第三个样例显示错误, <del>这个问题到现在还没想明白, 也没看到哪个网友用暴力法最终解决了这个问题, 若有读者看到此处麻烦指点一二.</del>  就在刚刚(2019/09/15 18:38)想明白了, 题目最后说了这么一段话:  <code>If the solution is not unique, output in the ascending order of n. If still not unique, output in the ascending order of A. If there is no solution, output No Solution.</code> 题目最后说按照 <code>n</code> 升序输出, 如果答案不唯一按照 <code>A</code> 升序输出, 马上告诉我朋友谷雨斌, 哈哈他和我一起破口大骂: <strong>卧槽!!!</strong>, 因为他只差这一个测试点就能拿到满分, 这尼玛已经不是第一次做题栽在看题上了, 我的印象里只有按照 <code>A</code> 升序, 读文章只看首和尾, 卧槽.</p><blockquote><p> 试试方式二: DFS </p></blockquote><p>考试结束我朋友说这题他用DFS做了两个小时, 虽然最后因为读题导致第三个测试点没通过, 但是这题用DFS的思路真的不会去想, 哪有第一题就用深度优先搜索的, 疯了, 静下来冷静思考, 确实DFS最容易解题啊, 然后 <strong>剪枝(用DFS的关键所在)</strong> 减少搜索深度.</p><ul><li>思路: <strong>k</strong> 位数, 考虑枚举分别以[1-9]开头的所有数(排除以0开头的情况, 否则就会出现 <strong>k - 1</strong> 位数的情况), 因为要记录 <strong>当前数值, 位数, 各位数之和</strong>, 所以在DFS函数中加入 <code>number, numDigit, sumD</code> 作为参数, 得到以下代码: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> number, <span class="keyword">int</span> numDigit, <span class="keyword">int</span> sumD)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sumD &gt; m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sumD + <span class="number">9</span> * (k - numDigit) &lt; m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (numDigit == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sumD != m) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> n = getDigitSum(number + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> x = gcd(m, n);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">2</span> &amp;&amp; isPrime(x)) &#123;</span><br><span class="line">            ans.push_back(&#123;n,number&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        dfs(number * <span class="number">10</span> + i, numDigit + <span class="number">1</span>, sumD + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这段递归函数中有两个 <strong><em>死胡同</em></strong> :</li></ul><ol><li>如果当前数值的各位之和已经大于m, 那么就没必要继续往下递归, 需要返回, 于是得到 <code>if (sumD != m) return;</code></li><li>假设当前记录的位数已有5位, 那么剩余位数就为 <code>k - 5</code> 位, 如果这 <code>k - 5</code> 位数都取9, 且此时的各位之和加上 <code>9 * (k - 5)</code> 都不能达到m的话, 说明后面的情况均不能得到结果, 需要及时返回 (也就是所谓的回溯), 于是得到 <code>if (sumD + 9 * (k - numDigit) &lt; m) return;</code>, 如果不做 <strong>剪枝</strong> 样例4仍然是超时的. </li></ol><p>最后将符合的结果 <code>push</code> 进vector中, 因为排序有两个条件, 所以定义一个 <code>node</code> 结构体来表示一个正确结果, 最后sort函数排序即可. 今天刚AC的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n, k, m;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.n != b.n) <span class="keyword">return</span> a.n &lt; b.n;</span><br><span class="line">    <span class="keyword">return</span> a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sumD = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        sumD += x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sumD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> number, <span class="keyword">int</span> numDigit, <span class="keyword">int</span> sumD)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sumD &gt; m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sumD + <span class="number">9</span> * (k - numDigit) &lt; m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (numDigit == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sumD != m) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> n = getDigitSum(number + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> x = gcd(m, n);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">2</span> &amp;&amp; isPrime(x)) &#123;</span><br><span class="line">            ans.push_back(&#123;n,number&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        dfs(number * <span class="number">10</span> + i, numDigit + <span class="number">1</span>, sumD + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d\n"</span>, i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;k, &amp;m);</span><br><span class="line">        ans.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">            dfs(j, <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No Solution\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sort(ans.begin(), ans.end(), cmp);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it : ans) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, it.n, it.v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是最快的方法的解法, 最耗时的样例也只用了 <code>3ms</code>, 最后, 有始有终, 把最初使用的暴力法也给AC了, 不过同样要优化枚举次数 (即限定最后两个数为 <strong>99</strong>), 代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.n != b.n) <span class="keyword">return</span> a.n &lt; b.n;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sumD = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        sumD += x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sumD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d\n"</span>, i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;k, &amp;m);</span><br><span class="line">        <span class="keyword">int</span> minValue = <span class="built_in">pow</span>(<span class="number">10</span>, k - <span class="number">1</span> - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="built_in">pow</span>(<span class="number">10</span>, k - <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">        ans.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = minValue; j &lt;= maxValue; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> dm = getDigitSum(j) + <span class="number">18</span>, dn = getDigitSum(j * <span class="number">100</span> + <span class="number">99</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (dm == m) &#123;</span><br><span class="line">                <span class="keyword">int</span> div = gcd(dm, dn);</span><br><span class="line">                <span class="keyword">if</span> (isPrime(div) &amp;&amp; div &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                    ans.push_back(&#123;dn, j * <span class="number">100</span> + <span class="number">99</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No Solution\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sort(ans.begin(), ans.end(), cmp);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it : ans) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, it.n, it.v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="7-2-Merging-Linked-Lists-25-分"><a href="#7-2-Merging-Linked-Lists-25-分" class="headerlink" title="7-2 Merging Linked Lists (25 分)"></a>7-2 Merging Linked Lists (25 分)</h1><p>作者: 陈越, 单位: 浙江大学, 时间限制: 400 ms, 内存限制: 64 MB</p><blockquote><p>Given two singly linked lists <strong><em>L<sub>1</sub> = a<sub>1</sub>→a<sub>2</sub>→⋯→a​<sub>n−1</sub>→a​<sub>n</sub></em></strong> and <strong><em>L​<sub>2​</sub> = b​<sub>1</sub>→b​<sub>2</sub>→⋯→b​<sub>m−1</sub>→b​m<sub>​</sub></em></strong> . If <strong><em>n</em></strong> ≥ <strong><em>2m</em></strong>, you are supposed to reverse and merge the shorter one into the longer one to obtain a list like <strong><em>a<sub>1</sub>→a<sub>2</sub>→b​<sub>m</sub>​→a<sub>3</sub>→a<sub>4</sub>→b​<sub>m−1</sub>⋯</em></strong>. For example, given one list being 6→7 and the other one 1→2→3→4→5, you must output 1→2→7→3→4→6→5.</p><p><strong>Input Specification:</strong><br>Each input file contains one test case. For each case, the first line contains the two addresses of the first nodes of <strong><em>L​<sub>1</sub></em></strong>​ and <strong><em>L​<sub>2</sub></em></strong>​​ , plus a positive <strong><em>N</em></strong> (≤ <strong><em>10​<sup>5</sup></em></strong>) which is the total number of nodes given. The address of a node is a 5-digit nonnegative integer, and NULL is represented by <code>-1</code>.</p><p>Then <strong><em>N</em></strong> lines follow, each describes a node in the format:</p><p><code>Address Data Next</code></p><p>where <code>Address</code> is the position of the node, <code>Data</code> is a positive integer no more than <strong><em>10<sup>5</sup>​</em></strong>​ , and <code>Next</code> is the position of the next node. It is guaranteed that no list is empty, and the longer list is at least twice as long as the shorter one.</p><p><strong>Output Specification:</strong><br>For each case, output in order the resulting linked list. Each node occupies a line, and is printed in the same format as in the input.</p><p><strong>Sample Input:</strong><br>00100 01000 7<br>2233 2 34891<br>0100 6 00001<br>4891 3 10086<br>1000 1 02233<br>0033 5 -1<br>0086 4 00033<br>0001 7 -1</p><p><strong>Sample Output:</strong><br>1000 1 02233<br>2233 2 00001<br>0001 7 34891<br>4891 3 10086<br>0086 4 00100<br>0100 6 00033<br>0033 5 -1</p></blockquote><p>这道最常规的题成为这四道题里我唯一AC的题（┬＿┬）. 前面第一题因为<u>最大公约数</u>的原因, 我直接跳到了第二题, 看到这样的题, 就会莫名有亲切感, 链表, 最容易了, 哈哈.</p><ul><li>大致题意: 有L1,L2两个链表, 如果L1的长度 &gt;= 2倍的L2长度, 则把L2中的元素逆序插入L1中, 插入规则: <strong>从L1的首结点开始, 每碰到两个结点就从L2的末尾取一个结点插入L1的当前位置之后</strong>.</li><li>思路: 这种题如果按照链表的做法思路就很清晰了, 因为<code>PAT</code>的链表题都是给定结点地址和后继结点地址的, 显然这不是内存地址, 所以一定是用静态链表来表示链表结构.</li><li>解题步骤:<ol><li>逆置链表L2, 因为所给的链表都没有头结点, 为了逆置链表, 必须自行添加一个头结点, 为了避免使用已有结点的地址, 所以头结点的指针(即数组中的索引)需要从 <code>maxn - 1</code> 往前取, 然后其后继指针指向链表的第一个元素.</li><li>然后遍历设 <code>p</code> 指针, 遍历长链表, 遍历过程中通过 <code>cnt</code> 计数, 达到2, 则插入短链表的第一个结点, 然后重置 <code>cnt</code> 为 0.</li></ol></li></ul><p><strong>当时提交的代码:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data, address, next;</span><br><span class="line">&#125; Node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverseList</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = maxn - <span class="number">1</span>;</span><br><span class="line">    Node[head].next = start;</span><br><span class="line">    <span class="keyword">int</span> last = Node[head].next, p = Node[last].next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">        Node[last].next = Node[p].next;</span><br><span class="line">        Node[p].next = Node[head].next;</span><br><span class="line">        Node[head].next = p;</span><br><span class="line">        p = Node[last].next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Node[head].next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">int</span> head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d "</span>, Node[p].address, Node[p].data);</span><br><span class="line">        <span class="keyword">if</span> (Node[p].next == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%05d\n"</span>, Node[p].next);</span><br><span class="line">        p = Node[p].next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLen</span><span class="params">(<span class="keyword">int</span> head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = head, len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">        p = Node[p].next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head1, head2, n, address;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;head1, &amp;head2, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;address);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;Node[address].data, &amp;Node[address].next);</span><br><span class="line">        Node[address].address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len1 = getLen(head1), len2 = getLen(head2);</span><br><span class="line">    <span class="keyword">if</span> (len1 == <span class="number">0</span>) printList(head2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (len2 == <span class="number">0</span>) printList(head1);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q, p;</span><br><span class="line">        <span class="keyword">if</span> (len1 &gt;= len2 * <span class="number">2</span>) &#123;</span><br><span class="line">            p = head1;</span><br><span class="line">            q = reverseList(head2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len2 &gt;= <span class="number">2</span> * len1) &#123;</span><br><span class="line">            p = head2;</span><br><span class="line">            q = reverseList(head1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="number">-1</span> &amp;&amp; q != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++cnt == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = Node[q].next;</span><br><span class="line">                Node[q].next = Node[p].next;</span><br><span class="line">                Node[p].next = q;</span><br><span class="line">                p = Node[p].next;</span><br><span class="line">                q = temp;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = Node[p].next;</span><br><span class="line">        &#125;</span><br><span class="line">        printList(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来思考中间有一部分逻辑判断是无用, 但是考试的时候一看AC了也就没管了.</p><p>然而这就开心了吗, 哎, 做过<code>PAT</code>的所有真题, 链表题通常都不是用链表的方法做的, 考试的时候没想这么多, 虽然AC了, 但是这题做了四十多分钟, 今天教育超市重新模拟, 换了另一种 <del>常规</del> 解法: 因为, 提交代码后的测试样例只检验输出结果是否正确, 并不分析源码, 所以只需要所得一个结果而不是真的去改变链表的结构.</p><ul><li>思路: 遍历L1, L2把结点分别 <code>push</code> 进vector中 (定义<code>vecotr&lt;node&gt; l1, l2</code>), 另外声明一个同样类型的变量 <code>ans</code>(解题的常规操作), 遍历较长的链表把其结点依次 <code>push</code> 进 <code>ans</code> 中, 每插入两个结点就从l2结尾取一个结点插入 <code>ans</code>.</li></ul><p><strong>代码如下:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> adr, data, next;</span><br><span class="line">&#125; Node[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; l1, l2, ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateList</span><span class="params">(<span class="built_in">vector</span>&lt;node&gt; &amp;L, <span class="keyword">int</span> head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">        L.push_back(Node[p]);</span><br><span class="line">        p = Node[p].next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="built_in">vector</span>&lt;node&gt; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>, L[i].adr, L[i].data, L[i + <span class="number">1</span>].adr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%05d %d -1\n"</span>, L[L.size() - <span class="number">1</span>].adr, L[L.size() - <span class="number">1</span>].data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h1, h2, n, adr;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; h1 &gt;&gt; h2 &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; adr;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; Node[adr].data &gt;&gt; Node[adr].next;</span><br><span class="line">        Node[adr].adr = adr;</span><br><span class="line">    &#125;</span><br><span class="line">    generateList(l1, h1);</span><br><span class="line">    generateList(l2, h2);</span><br><span class="line">    <span class="keyword">if</span> (l1.size() &lt; l2.size()) &#123;</span><br><span class="line">        swap(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1.size() &gt;= l2.size() * <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, pos = l2.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : l1) &#123;</span><br><span class="line">            ans.push_back(it);</span><br><span class="line">            <span class="keyword">if</span> (++cnt % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; pos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ans.push_back(l2[pos--]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printList(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意点: <code>generateList</code> 函数中的第一个参数 <code>L</code> 必须用引用类型.</p></blockquote><p>用 <code>vector</code> 来解决链表问题是最常用的手段, 也能极大缩短编码时间. 这道题虽然AC了, 但是一开始用了蠢办法浪费了太多考试时间.</p><hr><h1 id="7-3-Postfix-Expression-25-分"><a href="#7-3-Postfix-Expression-25-分" class="headerlink" title="7-3 Postfix Expression (25 分)"></a>7-3 Postfix Expression (25 分)</h1><p>作者: 陈越, 单位: 浙江大学, 时间限制: 400 ms, 内存限制: 64 MB</p><blockquote><p>Given a syntax tree (binary), you are supposed to output the corresponding postfix expression, with parentheses reflecting the precedences of the operators.</p><p><strong>Input Specification:</strong><br>Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 20) which is the total number of nodes in the syntax tree. Then N lines follow, each gives the information of a node (the <strong><em>i</em></strong> -th line corresponds to the <strong><em>i</em></strong> -th node) in the format:</p><p><code>data left_child right_child</code></p><p>where <code>data</code> is a string of no more than 10 characters, <code>left_child</code> and <code>right_child</code> are the indices of this node’s left and right children, respectively. The nodes are indexed from 1 to N. The NULL link is represented by −1. The figures 1 and 2 correspond to the samples 1 and 2, respectively.</p><table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><img src="/img/first_pat_p1.JPG" alt="Figure 1"></td><td align="center"><img src="/img/first_pat_p2.JPG" alt="Figure 2"></td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><p><strong>Output Specification:</strong><br>For each case, print in a line the postfix expression, with parentheses reflecting the precedences of the operators.There must be no space between any symbols.</p><p><strong>Sample Input 1:</strong><br>8<br>* 8 7<br>a -1 -1<br>* 4 1<br>+ 2 5<br>b -1 -1<br>d -1 -1<br>- -1 6<br>c -1 -1</p><p><strong>Sample Output 1:</strong><br>(((a)(b)+)((c)(-(d))*)*)</p><p><strong>Sample Input 2:</strong><br>8<br>2.35 -1 -1<br>* 6 1<br>- -1 4<br>% 7 8<br>+ 2 3<br>a -1 -1<br>str -1 -1<br>871 -1 -1</p><p><strong>Sample Output 2:</strong><br>(((a)(2.35)*)(-((str)(871)%))+)</p></blockquote><p>这道题目初次瞄到这两张Figure的时候, 看了一眼输入输出样例, 与我当初看过的一道计算器算法题尤为相似, 非递归求解非常复杂, 当时没细看, 心想: 我去, 怕什么来什么吗. 所以直接跳到了下题. 直到今天重新做题, 我太抓狂了, 这道题非常非常的简单, 十几分钟就能写完的题目, 我考试的时候连提交都没有提交啊.</p><ul><li>题意: 后缀表达式, 通过输出括弧表示操作符的优先级.</li><li>思路: 给出的结构是二叉树(静态二叉树表示), 如果只是后缀表达的话, 就非常简单, 只用 <code>递归的后序遍历</code> 即可, 像这样:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    postOrder(Node[root].lchild);</span><br><span class="line">    postOrder(Node[root].rchild);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Node[root].data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>用 <code>Figure1</code> 举例, 在后序遍历输出第一个数 <code>a</code> 的时候, 前面需要输出3个左括弧, 这实际上对应了 <code>a</code> 所在的层数(也就对应了递归调用 <code>postOrder</code> 的深度), 所以需要在当前结点向左孩子递归之前就输出这个 <code>(</code> , 同时, 输出一个操作数之后需要立马输出一个 <code>)</code> , 所以最后会得到这样的代码:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span>;</span><br><span class="line">    postOrder(Node[root].lc);</span><br><span class="line">    postOrder(Node[root].rc);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Node[root].v;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>先运行一下代码测试第一个样例, 得到这样的输出:    <figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(((<span class="name">a</span>)(<span class="name">b</span>)+)((<span class="name">c</span>)((<span class="name">d</span>)-)*)*)</span><br></pre></td></tr></table></figure>看着感觉像回事了, 但是发现 <code>d</code> 的后面的负号实际上不是<code>空字符-d</code>, 而是表示 <code>d</code> 是个负数, 所以如果某一个操作符如果 <strong>左子树为空, 右子树不为空</strong>, 就说明这个符号是用来表示正负号的, 不应该放到这个操作数的后面. 所以思路就变得清晰了: <strong>操作符比操作数先输出, 对应到二叉树的结构中就是根节点先输出再输出孩子结点</strong>, 也就是 <strong>先序或中序遍历</strong>, 但是这里一定是从二叉树的最左侧结点开始输出, 所以不可能再是先序遍历了, 于是很容易就得到以下代码:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOperator</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str == <span class="string">"-"</span> || str == <span class="string">"/"</span> || str == <span class="string">"*"</span> || str == <span class="string">"+"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span>;</span><br><span class="line">    postOrder(Node[root].lc);</span><br><span class="line">    <span class="keyword">if</span> (isOperator(Node[root].v) &amp;&amp; Node[root].lc == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Node[root].v;</span><br><span class="line">        postOrder(Node[root].rc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        postOrder(Node[root].rc);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Node[root].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>全部代码如下:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> v;</span><br><span class="line">    <span class="keyword">int</span> lc, rc;</span><br><span class="line">&#125; Node[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span>;</span><br><span class="line">    postOrder(Node[root].lc);</span><br><span class="line">    <span class="keyword">if</span> (Node[root].v == <span class="string">"-"</span> &amp;&amp; Node[root].lc == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Node[root].v;</span><br><span class="line">        postOrder(Node[root].rc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        postOrder(Node[root].rc);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Node[root].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; Node[i].v &gt;&gt; Node[i].lc &gt;&gt; Node[i].rc;</span><br><span class="line">        <span class="keyword">if</span> (Node[i].lc != <span class="number">-1</span>) vis[Node[i].lc] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (Node[i].rc != <span class="number">-1</span>) vis[Node[i].rc] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> R;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            R = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(R);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题从读题到完成AC只用了十几分钟, 但是考试的时候我没提交… 25分随之飘走.</p><hr><h1 id="7-4-Dijkstra-Sequence-30-分"><a href="#7-4-Dijkstra-Sequence-30-分" class="headerlink" title="7-4 Dijkstra Sequence (30 分)"></a>7-4 Dijkstra Sequence (30 分)</h1><p>作者: 陈越, 单位: 浙江大学, 时间限制: 1500 ms, 内存限制: 64 MB</p><blockquote><p>Dijkstra’s algorithm is one of the very famous greedy algorithms. It is used for solving the single source shortest path problem which gives the shortest paths from one particular source vertex to all the other vertices of the given graph. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.</p><p>In this algorithm, a set contains vertices included in shortest path tree is maintained. During each step, we find one vertex which is not yet included and has a minimum distance from the source, and collect it into the set. Hence step by step an ordered sequence of vertices, let’s call it <strong>Dijkstra sequence</strong>, is generated by Dijkstra’s algorithm.</p><p>On the other hand, for a given graph, there could be more than one Dijkstra sequence. For example, both { 5, 1, 3, 4, 2 } and { 5, 3, 1, 2, 4 } are Dijkstra sequences for the graph, where 5 is the source. Your job is to check whether a given sequence is Dijkstra sequence or not.</p><p><strong>Input Specification:</strong><br>Each input file contains one test case. For each case, the first line contains two positive integers <strong><em>N</em></strong><sub>v</sub> (≤ 10<sup>3</sup>) and <strong><em>N</em></strong><sub>e</sub> (≤ 10<sup>5</sup>), which are the total numbers of vertices and edges, respectively. Hence the vertices are numbered from 1 to <strong><em>N</em></strong><sub>v</sub> .</p><p>Then <strong><em>N</em></strong><sub>e</sub> lines follow, each describes an edge by giving the indices of the vertices at the two ends, followed by a positive integer weight (≤ <strong>100</strong>) of the edge. It is guaranteed that the given graph is connected.</p><p>Finally the number of queries, <strong>K</strong>, is given as a positive integer no larger than <strong>100</strong>, followed by <strong>K</strong> lines of sequences, each contains a permutationof the <strong><em>N</em></strong>​<sub>v</sub> vertices. It is assumed that the first vertex is the source for each sequence.</p><p>All the inputs in a line are separated by a space.</p><p>Output Specification:<br>For each of the K sequences, print in a line Yes if it is a Dijkstra sequence, or No if not.</p><p><strong>Sample Input:</strong><br>5 7<br>1 2 2<br>1 5 1<br>2 3 1<br>2 4 1<br>2 5 2<br>3 5 1<br>3 4 1<br>4<br>5 1 3 4 2<br>5 3 1 2 4<br>2 3 4 5 1<br>3 2 1 5 4</p><p><strong>Sample Output:</strong><br>Yes<br>Yes<br>Yes<br>No</p></blockquote><p>考试的时候跳过第三题, 看到第四题 named <code>Dijkstra</code> 的时候我非常开心, 因为我对单源最短路径的Dijkstra算法非常非常熟悉, 以往的考过的真题大多都是与最短路径相关的实际应用题, 比如以下几道:</p><ul><li><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376" target="_blank" rel="noopener">A1003 Emergency</a></li><li><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805500414115840" target="_blank" rel="noopener">A1013 Battle Over Cities</a></li><li><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805489282433024" target="_blank" rel="noopener">A1018 Public Bike Management</a></li><li><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805396953219072" target="_blank" rel="noopener">A1072 Gas Station</a></li><li><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805379664297984" target="_blank" rel="noopener">A1087 All Roads Lead to Rome</a></li><li>…</li></ul><p>上面这几道题, 做法都是比较单一的, 通常都是用 <strong>Dijkstra + DFS</strong> 来解题, 即通过Dijkstra算法得到一个最短路径树(形成了树结构, 用vector存储), 既然用树来存放路径, 必定可以用DFS获得每一条路径(从根节点到每个叶子节点即为一条最短路径), 最后得出最优解(通常就是路径的点权值或者边权值).<br>但是, 这个题它并不是个常规题…. 我去</p><ul><li>大致题意: <ol><li>人话描述一下Dijkstra算法, Dijkstra是单源最短路径算法之一, 也就是求一个图中的某一个顶点到所有其他顶点的最短路径的算法. 一般要先给出一个 <code>源点</code>, 这个源点会最先被包含到集合中, 然后从这个点出发, 找到图中离它最近的邻接点(如果是无向图就是与之相邻的顶点, 如果是有向图就是该顶点所指向的顶点), 通常通过边权来判断距离大小, 也就是两顶点之间弧的权值, 然后把找到的最近邻接点加入到集合中, 并标记这个顶点已经被包含进集合, 然后再去寻找下一个离当前顶点最近的邻接点再加入集合, 在此过程中会声明一个 <code>dist</code> 数组用来记录从源点到各个顶点的最短距离并优化, 而在寻找最近邻接点的过程可能会存在多个邻接点与当前顶点距离最近, 这个时候就产生了多个获得最短路径的访问序列, 这个序列就被称之为 <strong>Dijkstra序列</strong>, 而为什么最后得到的最短路径是唯一的, 就是因为无论从哪个邻接点再次出发, 记录最短路径值的 <code>dist</code> 数组都会逐步做出优化. 所以Dijkstra实际上是个贪心算法, 从局部最优得到整体最优.</li><li>题目要求: 最后给出 <code>k</code> 个序列, 需要通过程序判断这是不是一个Dijkstra序列. 并假设第一个顶点是这个序列的源点.</li></ol></li><li>解题思路: (考试的时候没想到呀….), Dijkstra算法实现的第一个核心部分是 <strong>找到当前顶点的最近邻接点</strong> , 这里比较适合先贴出全部代码:<br><img src="/img/first_pat_graph.png" alt="Sample 1: Graph"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7FFFFFFF</span>;</span><br><span class="line"><span class="keyword">int</span> G[maxn][maxn], d[maxn], number[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    fill(vis, vis + maxn, <span class="literal">false</span>);</span><br><span class="line">    fill(d, d + maxn, INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span> || d[u] != d[number[i]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        u = number[i];</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; G[u][v] != INF) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">                    d[v] = d[u] + G[u][v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    fill(G[<span class="number">0</span>], G[<span class="number">0</span>] + maxn * maxn, INF);</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;G[u][v]);</span><br><span class="line">        G[v][u] = G[u][v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; number[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Dijkstra(number[<span class="number">1</span>])) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"No\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>上述的核心代码在 <strong>17-23</strong> 行, <code>vis</code> 数组用来标记某顶点是否被访问过, 实际上就是所述抽象出来的<u>是否被存入集合中</u>, <code>MIN</code> 被定义为一个无穷大的数INF(即infinite, 在C++中用可以用十六进制表示最大整型0x7FFFFFFF), 这代码要找出未被存入集合, 且离当前顶点最近的邻接点, 实际这个点就是题目中对应需要被判定的点. 考试的时候, 虽然可以 <strong>存在多个满足条件的邻接点</strong>,但是上述代码中因为 <code>d[j] &lt; MIN</code>, 实际上只能取得第一个满足条件的邻接点, 当时我没想明白只取到一个邻接点该如何跟多个序列做对比, 这个问题把我给想傻掉了, 实际上可以记录所有的最短路径, 然后与给定的序列依次比较, 但是这种做法显然非常愚蠢. 根据题目给定的极端数据量和序列长度, 这个解法一定会有多个样例超时.</li></ul><p>唉, 其实这个问题非常简单, 上述代码每次得到的邻接点是唯一的, 但是最短距离也是唯一, 判定最近邻接点的根本依据仍旧是边长, 所以通过给定的序列去做匹配, 如果当前顶点到序列中对应的顶点距离与之前得到的最短距离是相同的, 说明序列中的这个顶点也是最近的邻接点, 那么就可以把该点作为下一个出发源点, 如果出现距离不相等立马就可以判定这个序列是不合法的, 随即 <code>return false</code>. 最终今天AC通过的代码, 与考试时候提交的答案只差了两行关键代码.0分与30分只有两行代之差<br><strong>以下是考试时的提交代码:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7FFFFFFF</span>;</span><br><span class="line"><span class="keyword">int</span> G[maxn][maxn], d[maxn], number[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    fill(vis, vis + maxn, <span class="literal">false</span>);</span><br><span class="line">    fill(d, d + maxn, INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解题代码应贴在此处..............</span></span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; G[u][v] != INF) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">                    d[v] = d[u] + G[u][v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    fill(G[<span class="number">0</span>], G[<span class="number">0</span>] + maxn * maxn, INF);</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;G[u][v]);</span><br><span class="line">        G[v][u] = G[u][v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; number[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看自己以如此欢快的口气写完了所有代码的总结, 实际上因为我已经难过了一阵子了, 哈哈. 这次的考试经历, 对自己算是个不小的打击, 总结几点经验:</p><ol><li>考试前一天太过激动(不是紧张), 一晚上没睡着呀, 肾上腺素指数上升.</li><li>心理素质不行呀, 坐上考场, 脑子一片嗡嗡的, 思考问题完成没平时做题淡定.</li><li>终归问题是能力不行, 对”较大”场合适应能力不强, 得多经历一些类似的场合.</li><li>…. 下一回考前必须要有足够的睡眠以保证头脑清晰.</li></ol><p>这次考试结束, 知乎上许多人都是最后三题只花一个小时, 这点真是非常遗憾, 是非常简单的题目, 但是我答的像屎一样, 尤其是第三道送分题, 我还回去了25分. 对于这次认为应该是最简单但却最坑的第一题, 死磕了一个多小时还是没AC, 太死板了, 心态也崩坏了, 阿斌说这题他看了几分钟立马跳到后面的题, 哈哈, 这都是经验呀.<br>最后, 为什么说是一次遗憾的考试, 没考出水平是一方面, 另一方面, 暑假大把时间地通刷真题, 本想是一次开心的检验性考试, 但是走出考场确实很失落, 以致于没等到拿PAT证书就走了, 这真是遗憾啊, 毕竟没有电子证书, 只有一人一章一份的浙大证书.<br>同时, 暑假这段刷题的经历, 不但了解了ACM相关竞赛的知识, 也终于让我体会到了编程的真正乐趣: 写程序不是简单的 <code>if ... else ...</code> 判断, 而且说把一个实际问题抽象建模, 寻找能表示问题的最佳模型(即数据结构), 再找到能够解决问题的方法(即算法), 从解决问题从最慢到最快(改进算法时间复杂度, 回溯法), 从理解局部最优到整体最优等, 这个学习过程真是很难, 但是确实很有乐趣. 考前一天我私信姥姥问她以后PAT出题是否会越来越难, 她说:”不会, 一如既往地简单.”, 同时引用姥姥近期在知乎上关于 <a href="https://www.zhihu.com/question/345369507/answer/819630590?hb_wx_block=1&utm_source=qq&utm_medium=social&utm_oi=913895491333419008" target="_blank" rel="noopener">数据结构到底难在哪里?</a> 的一个回答:<br><img src="/img/first_pat_zhihu.png" alt=""><br>对其他重点高校的学生来说, 在OJ平台上做一道编程题可能就像我写一句 <code>print &quot;Hello World!&quot;</code> 这么简单, 就比如说, 这次的PAT甲级最快AC四道题的时间是1小时15分, 而PAT考试历史最快是45分钟AC四题, 我自己也深有感触, 从最开始刷 <a href="https://pintia.cn/problem-sets/994805342720868352/problems/type/7" target="_blank" rel="noopener">PAT甲级题目</a> 的寸步难行到现在大部分题的解题方法步骤几乎可以不经思考地默写(然后这次考地一塌糊涂), 长期的练习才能孰能生巧, 但是和上面这些大牛还是相差甚远啊. 看到其他学校OJ平台上的C/C++的课后习题就是PAT乙级的难度了, 别人在初学之时就接受了比我难的多的训练. 这点遗憾已经不能回到从前去补救了, 只能后起直追.</p><p>最后:  哈哈哈, 看到这条姥姥发的微博, 我赶紧搜了一下我们学校, 我笑了<br><a href="https://weibo.com/ttarticle/p/show?id=2309404415478327017570" target="_blank" rel="noopener">2019 年 PAT 秋季考试 - 学校加权总成绩排名</a><br><img src="/img/first_pat_rank.png" alt="顶级分数 x 1.5 + 甲级分数 + 乙级分数 / 1.5"><br>我们学校就我一人参加甲级, 37分撑到了第314名, 后面还有一百多个学校, 哈哈, 他们真的是去划水的呀.</p><p><font size="26">再接再厉…</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 编程 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客搭建中的插件安装</title>
      <link href="/2019/07/20/hexo-build/"/>
      <url>/2019/07/20/hexo-build/</url>
      
        <content type="html"><![CDATA[<ul><li><p>maupassant 主题依赖插件</p><ul><li><a href="https://github.com/hexojs/hexo-renderer-jade" target="_blank" rel="noopener">hexo-renderer-jade</a> : 支持Jade/Pug渲染</li><li><a href="https://github.com/knksmith57/hexo-renderer-sass" target="_blank" rel="noopener">hexo-renderer-sass</a> : 支持Sass渲染</li></ul></li><li><p><a href="https://github.com/PaicHyperionDev/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a> : 实现本地搜索</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p><a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a> : Git部署插件</p></li><li><p><a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a> : 生成订阅文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">    <span class="string">hexo-generator-feed</span></span><br><span class="line"><span class="comment">#Feed Atom</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure></li><li><p><a href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" rel="noopener">hexo-generator-sitemap</a> : 生成网站sitemap</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在Linux上安装SSL证书</title>
      <link href="/2019/07/20/linux-ssl-installation/"/>
      <url>/2019/07/20/linux-ssl-installation/</url>
      
        <content type="html"><![CDATA[<p>以下仅演示如果自动申请证书，如果你自己准备了证书，请查阅相关教程</p><h3 id="安装-certbot-以及-certbot-nginx-插件"><a href="#安装-certbot-以及-certbot-nginx-插件" class="headerlink" title="安装 certbot 以及 certbot nginx 插件"></a>安装 certbot 以及 certbot nginx 插件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install certbot python2-certbot-nginx -y</span></span><br></pre></td></tr></table></figure><p>注：如果是 <strong>CentOS 7</strong> 可能出现安装错误, 根据提示进行修复即可</p><a id="more"></a><h3 id="执行配置"><a href="#执行配置" class="headerlink" title="执行配置"></a>执行配置</h3><p>中途会询问邮箱等基本信息，如实填写即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo certbot --nginx</span></span><br></pre></td></tr></table></figure><p>安装成功后, 最末尾会出现以下提示信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IMPORTANT NOTES:</span><br><span class="line"> - Congratulations! Your certificate and chain have been saved at:</span><br><span class="line">   /etc/letsencrypt/live/你的域名/fullchain.pem</span><br><span class="line">   Your key file has been saved at:</span><br><span class="line">   /etc/letsencrypt/live/你的域名/privkey.pem</span><br><span class="line">   Your cert will expire on 2019-09-26. To obtain a new or tweaked</span><br><span class="line">   version of this certificate in the future, simply run certbot again</span><br><span class="line">   with the "certonly" option. To non-interactively renew *all* of</span><br><span class="line">   your certificates, run "certbot renew"</span><br><span class="line"> - If you like Certbot, please consider supporting our work by:</span><br><span class="line"></span><br><span class="line">   Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate</span><br><span class="line">   Donating to EFF:                    https://eff.org/donate-le</span><br></pre></td></tr></table></figure><p>同时可以从以上输出信息中得到证书的 <strong>安装位置</strong> 在 <code>/etc/letsencrypt/live/你的域名/</code> 之下，其中会包含一个 <strong>README</strong> 文件来简述该文件夹下其他文件的含义，可自行查看</p><h3 id="自动续约"><a href="#自动续约" class="headerlink" title="自动续约"></a>自动续约</h3><p>用certbot安装免费SSL证书，其有效期只有6个月的时间，可以用以下命令开启 <strong>自动续约</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo certbot renew --dry-run</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1025 PAT Ranking (25分)</title>
      <link href="/2019/07/10/pat-A1025/"/>
      <url>/2019/07/10/pat-A1025/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805474338127872" target="_blank" rel="noopener">A1025 PAT Ranking (25 分)</a></p><p>Programming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive number <em>N</em> (≤100), the number of test locations. Then <em>N</em> ranklists follow, each starts with a line containing a positive integer <em>K</em> (≤300), the number of testees, and then <em>K</em> lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, first print in one line the total number of testees. Then print the final ranklist in the following format:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">registration_number final_rank location_number local_rank</span></span><br></pre></td></tr></table></figure><p>The locations are numbered from 1 to <em>N</em>. The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br><span class="line">1234567890001 95</span><br><span class="line">1234567890005 100</span><br><span class="line">1234567890003 95</span><br><span class="line">1234567890002 77</span><br><span class="line">1234567890004 85</span><br><span class="line">4</span><br><span class="line">1234567890013 65</span><br><span class="line">1234567890011 25</span><br><span class="line">1234567890014 100</span><br><span class="line">1234567890012 85</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">1234567890005 1 1 1</span><br><span class="line">1234567890014 1 2 1</span><br><span class="line">1234567890001 3 1 2</span><br><span class="line">1234567890003 3 1 2</span><br><span class="line">1234567890004 5 1 4</span><br><span class="line">1234567890012 5 2 2</span><br><span class="line">1234567890002 7 1 5</span><br><span class="line">1234567890013 8 2 3</span><br><span class="line">1234567890011 9 2 4</span><br></pre></td></tr></table></figure><ul><li>题意: PAT有n个考场, 题目给出各个考场考生的准考证号,分数,考场, 要求输出考生的总排名信息, 输出内容包括所有考生的准考证号,排名,考场号以及场内排名</li><li>分析: <ol><li>题目要求对学生的成绩进行排序, 且需要输出学生的相关信息, 因此通过定义 <strong>结构体</strong> 来存放学生信息</li><li>输出结果包括考场序号,学生总排名以及场内排名, 所以需要进行两次排名, 最好的方式是每次读入一场学生成绩后 <strong>立即进行本场成绩的排序</strong> 并存至 <strong>Student 结构体</strong> 中, 故可以得到这样的学生结构体</li><li>输出结果包含总排名, 需要在遍历时计算, 于是在得出总排名后就直接输出而不再存放于结构体中.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">30010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">int</span> location_number;</span><br><span class="line">    <span class="keyword">int</span> rank_number;</span><br><span class="line">&#125;stu[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Student a, Student b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score != b.score) <span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.id,b.id) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k,cnt = <span class="number">0</span>;    <span class="comment">// cnt(count) 标记考场学生的总个数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = cnt; j &lt; cnt + k; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s %d"</span>,stu[j].id,&amp;stu[j].score);</span><br><span class="line">            stu[j].location_number = i;     <span class="comment">// 考场号按照读入的顺序计数</span></span><br><span class="line">        &#125;</span><br><span class="line">        sort(stu + cnt,stu + cnt + k,cmp);</span><br><span class="line">        stu[cnt].rank_number = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stu[cnt + i].score == stu[cnt + i - <span class="number">1</span>].score)</span><br><span class="line">                stu[cnt + i].rank_number = stu[cnt + i - <span class="number">1</span>].rank_number;</span><br><span class="line">            <span class="keyword">else</span> stu[cnt + i].rank_number = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt += k;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(stu,stu + cnt,cmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; stu[i].score != stu[i - <span class="number">1</span>].score) r = i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %d %d %d\n"</span>,stu[i].id,r,stu[i].location_number,stu[i].rank_number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT A1062 Talent and Virtue (25分)</title>
      <link href="/2019/07/10/pat-A1062/"/>
      <url>/2019/07/10/pat-A1062/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805410555346944" target="_blank" rel="noopener">A1062 Talent and Virtue (25 分)</a></p><p>About 900 years ago, a Chinese philosopher Sima Guang wrote a history book in which he talked about people’s talent and virtue. According to his theory, a man being outstanding in both talent and virtue must be a “sage（圣人）”; being less excellent but with one’s virtue outweighs talent can be called a “nobleman（君子）”; being good in neither is a “fool man（愚人）”; yet a fool man is better than a “small man（小人）” who prefers talent than virtue.</p><p>Now given the grades of talent and virtue of a group of people, you are supposed to rank them according to Sima Guang’s theory.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case first gives 3 positive integers in a line: <em>N</em> (≤10<sup>5</sup>), the total number of people to be ranked; <em>L</em> (≥60), the lower bound of the qualified grades – that is, only the ones whose grades of talent and virtue are both not below this line will be ranked; and <em>H</em> (&lt;100), the higher line of qualification – that is, those with both grades not below this line are considered as the “sages”, and will be ranked in non-increasing order according to their total grades. Those with talent grades below <em>H</em> but virtue grades not are cosidered as the “noblemen”, and are also ranked in non-increasing order according to their total grades, but they are listed after the “sages”. Those with both grades below <em>H</em>, but with virtue not lower than talent are considered as the “fool men”. They are ranked in the same way but after the “noblemen”. The rest of people whose grades both pass the <em>L</em> line are ranked after the “fool men”.</p><p>Then <em>N</em> lines follow, each gives the information of a person in the format:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ID_Number Virtue_Grade Talent_Grade</span></span><br></pre></td></tr></table></figure><p>where <code>ID_Number</code> is an 8-digit number, and both grades are integers in [0, 100]. All the numbers are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>The first line of output must give <em>M</em> (≤<em>N</em>), the total number of people that are actually ranked. Then <em>M</em> lines follow, each gives the information of a person in the same format as the input, according to the ranking rules. If there is a tie of the total grade, they must be ranked with respect to their virtue grades in non-increasing order. If there is still a tie, then output in increasing order of their ID’s.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">14 60 80</span><br><span class="line">10000001 64 90</span><br><span class="line">10000002 90 60</span><br><span class="line">10000011 85 80</span><br><span class="line">10000003 85 80</span><br><span class="line">10000004 80 85</span><br><span class="line">10000005 82 77</span><br><span class="line">10000006 83 76</span><br><span class="line">10000007 90 78</span><br><span class="line">10000008 75 79</span><br><span class="line">10000009 59 90</span><br><span class="line">10000010 88 45</span><br><span class="line">10000012 80 100</span><br><span class="line">10000013 90 99</span><br><span class="line">10000014 66 60</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">10000013 90 99</span><br><span class="line">10000012 80 100</span><br><span class="line">10000003 85 80</span><br><span class="line">10000011 85 80</span><br><span class="line">10000004 80 85</span><br><span class="line">10000007 90 78</span><br><span class="line">10000006 83 76</span><br><span class="line">10000005 82 77</span><br><span class="line">10000002 90 60</span><br><span class="line">10000014 66 60</span><br><span class="line">10000008 75 79</span><br><span class="line">10000001 64 90</span><br></pre></td></tr></table></figure><ul><li>题意：题目给考生分了4档，每个人有对应的德分和才分，并且给了录取最低分 <strong>L</strong> 和优先录取线 <strong>H</strong> ，按要求分为以下4类：（首先满足 <strong>德分和才分均不低于L</strong> 的才能被录取）<ol><li>德分和才分均大于 H 为 才德全尽</li><li>德分达到 H 但才分不到为 德胜才</li><li>德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者</li><li>剩下的为最后一类</li></ol></li><li>分析：创建结构体，按照输入的分数，通过<code>type</code>标明档次，序号从1开始。根据题目要求编写<code>cmp</code>函数，<code>type</code>值较小的排在前面，若type相等则按 <strong>总分</strong> 排名，若总分也相等则按 <strong>德分</strong> 排名，若德分仍相等则按照考生 <strong>id</strong> 的字典序排名。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, virtue, talent, sum, type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.type != b.type) <span class="keyword">return</span> a.type &lt; b.type;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.sum != b.sum) <span class="keyword">return</span> a.sum &gt; b.sum;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.virtue != b.virtue) <span class="keyword">return</span> a.virtue &gt; b.virtue;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.id &lt; b.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, l, h, id, virtue, talent, type = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l &gt;&gt; h;</span><br><span class="line">    <span class="built_in">vector</span>&lt;node&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;id, &amp;virtue, &amp;talent);</span><br><span class="line">        <span class="keyword">if</span> (virtue &lt; l || talent &lt; l) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (virtue &gt;= h &amp;&amp; talent &gt;= h) type = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (virtue &gt;= h &amp;&amp; talent &lt; h) type = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (virtue &gt;= talent) type = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> type = <span class="number">4</span>;</span><br><span class="line">        v.push_back(&#123;id, virtue, talent, virtue + talent, type&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sort(v.begin(), v.end(), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, v[i].id, v[i].virtue, v[i].talent);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 简单排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT B1085 PAT单位排行 (25分)</title>
      <link href="/2019/07/10/pat-B1085/"/>
      <url>/2019/07/10/pat-B1085/</url>
      
        <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805260353126400" target="_blank" rel="noopener">B1085 PAT单位排行 (25 分)</a></p><p>After each PAT, the PAT Center will announce the ranking of institutions based on their students’ performances. Now you are asked to generate the ranklist.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤10<sup>5</sup>), which is the number of testees. Then N lines follow, each gives the information of a testee in the following format:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ID Score School</span></span><br></pre></td></tr></table></figure><p>where <code>ID</code> is a string of 6 characters with the first one representing the test level: <code>B</code> stands for the basic level, <code>A</code> the advanced level and <code>T</code> the top level; <code>Score</code> is an integer in [0, 100]; and <code>School</code> is the institution code which is a string of no more than 6 English letters (case insensitive). Note: it is guaranteed that <code>ID</code> is unique for each testee.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, first print in a line the total number of institutions. Then output the ranklist of institutions in nondecreasing order of their ranks in the following format:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Rank School TWS Ns</span></span><br></pre></td></tr></table></figure><p>where <code>Rank</code> is the rank (start from 1) of the institution; <code>School</code> is the institution code (all in lower case); ; <code>TWS</code> is the <strong>total weighted score</strong> which is defined to be the integer part of <code>ScoreB/1.5 + ScoreA + ScoreT*1.5</code>, where <code>ScoreX</code> is the total score of the testees belong to this institution on level <code>X</code>; and <code>Ns</code> is the total number of testees who belong to this institution.</p><p>The institutions are ranked according to their <code>TWS</code>. If there is a tie, the institutions are supposed to have the same rank, and they shall be printed in ascending order of <code>Ns</code>. If there is still a tie, they shall be printed in alphabetical order of their codes.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">A57908 85 Au</span><br><span class="line">B57908 54 LanX</span><br><span class="line">A37487 60 au</span><br><span class="line">T28374 67 CMU</span><br><span class="line">T32486 24 hypu</span><br><span class="line">A66734 92 cmu</span><br><span class="line">B76378 71 AU</span><br><span class="line">A47780 45 lanx</span><br><span class="line">A72809 100 pku</span><br><span class="line">A03274 45 hypu</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 cmu 192 2</span><br><span class="line">1 au 192 3</span><br><span class="line">3 pku 100 1</span><br><span class="line">4 hypu 81 2</span><br><span class="line">4 lanx 81 2</span><br></pre></td></tr></table></figure><ul><li>题意：给出每个学生的id、分数、学校，学校名称不区分大小写，输出学校排名、学校名称、总加权成绩、学校参赛人数。学校名称输出时候以小写方式输出。</li><li>分析：学校名称不区分大小写，所以用一个<code>unordered_map&lt;string, int&gt;</code>给每个学校编号，编号从0开始，逐行输入数据后，先把学校名城转为小写，再判断该学校是否出现过，没出现过就给这个学校编一个号，同时要记录下出现过多少个不同的学校，然后就是把分数加到这个学校对应的结构体中，输入结束后，给学校根据要求编写<code>cmp</code>函数做排名，这里值得注意的是 <strong>排名实际上比较的是各学校加权总分四舍五入之后的总分</strong> ，因此比较时通过<code>int</code>做了强制类型转换。最后输出结果就好了。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> school;</span><br><span class="line">    <span class="keyword">int</span> cntMember = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> score = <span class="number">0.0</span>;</span><br><span class="line">&#125; s[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)a.score != (<span class="keyword">int</span>)b.score) <span class="keyword">return</span> (<span class="keyword">int</span>)a.score &gt; (<span class="keyword">int</span>)b.score;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.cntMember != b.cntMember) <span class="keyword">return</span> a.cntMember &lt; b.cntMember;</span><br><span class="line">    <span class="keyword">return</span> a.school &lt; b.school;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toLower</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isupper</span>(s[i])) s[i] = s[i] + <span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, score, cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> id, school;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; id &gt;&gt; score &gt;&gt; school;</span><br><span class="line">        toLower(school);</span><br><span class="line">        <span class="keyword">int</span> sid = mp[school];</span><br><span class="line">        <span class="keyword">if</span> (sid == <span class="number">0</span>) &#123;</span><br><span class="line">            mp[school] = cnt++;</span><br><span class="line">            sid = mp[school];</span><br><span class="line">            s[sid].school = school;</span><br><span class="line">        &#125;</span><br><span class="line">        s[sid].cntMember++;</span><br><span class="line">        <span class="keyword">if</span> (id[<span class="number">0</span>] == <span class="string">'A'</span>) s[sid].score += score;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (id[<span class="number">0</span>] == <span class="string">'B'</span>) s[sid].score += score / <span class="number">1.5</span>;</span><br><span class="line">        <span class="keyword">else</span> s[sid].score += score * <span class="number">1.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(s + <span class="number">1</span>, s + cnt, cmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> tscore = (<span class="keyword">int</span>)s[<span class="number">1</span>].score, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int</span>)s[i].score != tscore) &#123;</span><br><span class="line">            r = i;</span><br><span class="line">            tscore = s[i].score;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %s %d %d\n"</span>, r, s[i].school.c_str(), (<span class="keyword">int</span>)s[i].score, s[i].cntMember);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 简单排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ 中的 gets 与 fgets 问题</title>
      <link href="/2019/07/10/c-cpp-gets-fgets/"/>
      <url>/2019/07/10/c-cpp-gets-fgets/</url>
      
        <content type="html"><![CDATA[<p>在 <strong>PTA拼题</strong> 提交代码时碰到的一点坑!!<br>在处理 <strong>解析字符串</strong> 类型问题的时候, 经常需要读入包含 <u>空格</u> 的长字符串, 在C语言中, 最初通常使用 <code>gets</code> 函数来读取包含空格的字符串, 但是在 <em>C/C++11</em> 中已被摒弃.</p><a id="more"></a><p><a href="https://en.cppreference.com/w/c/io/gets" target="_blank" rel="noopener">官方参考手册</a> 给出以下解释:</p><blockquote><p>Notes<br>The gets() function does not perform bounds checking, therefore this function is extremely vulnerable to buffer-overflow attacks. It cannot be used safely (unless the program runs in an environment which restricts what can appear on stdin). For this reason, the function has been deprecated in the third corrigendum to the C99 standard and removed altogether in the C11 standard. <code>fgets()</code> and <code>gets_s()</code> are the recommended replacements.</p></blockquote><p>具体会出现怎样的错误呢:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> str[<span class="number">5</span>];</span><br><span class="line">    gets(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果程序输入 <code>1234</code> , 那么得到的输出显然是 <code>1234</code> , 这没问题.<br>现在继续新的输入 <code>12345678</code> , 同样可以得到相同的输出 <code>12345678</code> .<br>但是, 如果输入内容继续加大, 比如 <code>12345678901234567890</code> , 此时会得到这样一个输出:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">warning: this program uses gets(), which is unsafe.</span><br><span class="line"><span class="number">12345678901234567890</span></span><br><span class="line"><span class="number">12345678901234567890</span></span><br><span class="line">[<span class="number">1</span>]    <span class="number">33006</span> segmentation fault  <span class="string">"/Users/char_/test/"</span>a</span><br></pre></td></tr></table></figure><p>可以看到, 输入的字符串还是被原样输出了, 但是同时伴有一条 <strong><em>segmentation fault (段错误)</em></strong> 的信息被输出.</p><blockquote><p>困了, 待续…..</p></blockquote><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">5</span>], b[<span class="number">5</span>];</span><br><span class="line">    gets(a);</span><br><span class="line">    fgets(b, <span class="keyword">sizeof</span>(b), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lenA = <span class="built_in">strlen</span>(a),lenB = <span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"lenA = %d, lenB = %d\n"</span>, lenA, lenB);</span><br><span class="line">    <span class="comment">// print str a,b</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; lenA) <span class="built_in">printf</span>(<span class="string">"%c_"</span>,a[i++]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; lenB) <span class="built_in">printf</span>(<span class="string">"%c_"</span>,b[i++]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// print ascii of str a,b</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; lenA) <span class="built_in">printf</span>(<span class="string">"%d_"</span>,a[i++]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; lenB)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d_"</span>,b[i++]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 编程 </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT -- 字符串处理篇(共3题,持续更新...)</title>
      <link href="/2019/07/10/pat-string-processing-updating/"/>
      <url>/2019/07/10/pat-string-processing-updating/</url>
      
        <content type="html"><![CDATA[<p>题目来源:</p><ul><li><a href="https://pintia.cn/problem-sets/994805342720868352/problems/type/7" target="_blank" rel="noopener">PAT (Advanced Level) Practice</a></li><li><a href="https://pintia.cn/problem-sets/994805260223102976/problems/type/7" target="_blank" rel="noopener">PAT (Basic Level) Practice（中文）</a></li></ul><hr><a id="more"></a><p>本文记录 <strong>PAT</strong> 中关于 <strong>字符串处理</strong> 的相关习题(包括甲乙级)与笔者的解题思路及代码, 由于篇幅较长, 建议读者通过 <strong>侧边目录框或顶部目录按键</strong> 选择想要查看的习题, 且由于习题内容较多, 此处仅贴出题干部分不包含输入输出样例, 具体内容可 <strong>点击标题</strong> 跳转至原题页面进行查看与代码提交. </p><h2 id="A1035-Password-20-分"><a href="#A1035-Password-20-分" class="headerlink" title="A1035 Password (20 分)"></a><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805454989803520" target="_blank" rel="noopener">A1035 Password (20 分)</a></h2><blockquote><p>To prepare for PAT, the judge sometimes has to generate random passwords for the users. The problem is that there are always some confusing passwords since it is hard to distinguish <code>1</code> (one) from <code>l</code> (<code>L</code> in lowercase), or <code>0</code> (zero) from <code>O</code> (<code>o</code> in uppercase). One solution is to replace <code>1</code> (one) by <code>@</code>, <code>0</code> (zero) by <code>%</code>, <code>l</code> by <code>L</code>, and <code>O</code> by <code>o</code>. Now it is your job to write a program to check the accounts generated by the judge, and to help the juge modify the confusing passwords.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>],pwd[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">bool</span> isChanged;</span><br><span class="line">&#125;user[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkPwd</span><span class="params">(node&amp; t, <span class="keyword">int</span>&amp; cnt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(t.pwd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t.pwd[i] == <span class="string">'1'</span>)&#123;</span><br><span class="line">            t.pwd[i] = <span class="string">'@'</span>;</span><br><span class="line">            t.isChanged = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t.pwd[i] == <span class="string">'0'</span>)&#123;</span><br><span class="line">            t.pwd[i] = <span class="string">'%'</span>;</span><br><span class="line">            t.isChanged = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t.pwd[i] == <span class="string">'l'</span>)&#123;</span><br><span class="line">            t.pwd[i] = <span class="string">'L'</span>;</span><br><span class="line">            t.isChanged = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t.pwd[i] == <span class="string">'O'</span>)&#123;</span><br><span class="line">            t.pwd[i] = <span class="string">'o'</span>;</span><br><span class="line">            t.isChanged = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t.isChanged) cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %s"</span>,user[i].name,user[i].pwd);</span><br><span class="line">        checkPwd(user[i],cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"There is 1 account and no account is modified"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"There are %d accounts and no account is modified"</span>,n);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(user[i].isChanged)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s %s\n"</span>,user[i].name,user[i].pwd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="A1077-Kuchiguse-20-分"><a href="#A1077-Kuchiguse-20-分" class="headerlink" title="A1077 Kuchiguse (20 分)"></a><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805390896644096" target="_blank" rel="noopener">A1077 Kuchiguse (20 分)</a></h2><blockquote><p>The Japanese language is notorious for its sentence ending particles. Personal preference of such particles can be considered as a reflection of the speaker’s personality. Such a preference is called “Kuchiguse” and is often exaggerated artistically in Anime and Manga. For example, the artificial sentence ending particle “nyan~” is often used as a stereotype for characters with a cat-like personality:</p></blockquote><ul><li><p>Itai nyan~ (It hurts, nyan~)</p></li><li><p>Ninjin wa iyada nyan~ (I hate carrots, nyan~)</p><blockquote><p>Now given a few lines spoken by the same character, can you find her Kuchiguse?</p></blockquote></li><li><p>题意: 首先, 先对题目中对日语中句子结尾的 <u>particles</u> 用 <strong>臭名昭著</strong> (notorious)来形容表示赞同. 题目大意即求得给出的 <code>N</code> 个字符串中的 <strong>公共后缀</strong>, 如果不存在则输出 <code>nai</code>.</p></li><li><p>思路:   </p><ol><li>对于此等类似的题目 (即从 <strong>字符串末位</strong> 开始比较) 其一贯做法就是对字符串进行 <strong>反转</strong>, 建议的使用 <code>algorithm</code> 头文件下的 <code>reverse</code> 函数通过字符串的首尾指针进行反转</li><li>给出的 <code>N</code> 个字符串, 其公共后缀最大长度不可能超过给出的字符串中最短的字符串长度, 故在存储以上字符串时获取到最短长度 <code>minLen</code></li></ol></li><li><p>参考代码:</p></li></ul><p><strong>注意:</strong> 代码中通过 <code>fgets</code> 函数读入字符串是易错点<br>具体参考我的另一篇文章 <a href="https://charjin.top/2019/07/10/c-gets-fgets" target="_blank" rel="noopener">C 之 gets与fgets</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">int</span> minLen = <span class="number">256</span>;   <span class="comment">// 记录可能的最长公共后缀位数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>][maxn];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        fgets(str[i],<span class="keyword">sizeof</span>(str[i]) + <span class="number">2</span>,<span class="built_in">stdin</span>);</span><br><span class="line">        len = <span class="built_in">strlen</span>(str[i]);</span><br><span class="line">        str[i][--len] = <span class="string">'\0'</span>;</span><br><span class="line">        reverse(str[i],str[i] + len);</span><br><span class="line">        <span class="keyword">if</span>(len &lt; minLen) minLen = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> same = <span class="number">-1</span>,cnt;</span><br><span class="line">    <span class="keyword">char</span> ans[maxn];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minLen; i++)&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> c = str[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == str[j][i])</span><br><span class="line">                cnt++; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt == n - <span class="number">1</span>)&#123;</span><br><span class="line">            same = i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(same &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = same; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,str[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"nai"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="A1082-Read-Number-in-Chinese-25-分"><a href="#A1082-Read-Number-in-Chinese-25-分" class="headerlink" title="A1082 Read Number in Chinese (25 分)"></a><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805385053978624" target="_blank" rel="noopener">A1082 Read Number in Chinese (25 分)</a></h2><blockquote><p>Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output <code>Fu</code> first if it is negative. For example, -123456789 is read as <code>Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu</code>.<br>Note: zero ( <code>ling</code> ) must be handled correctly according to the Chinese tradition. For example, 100800 is <code>yi Shi Wan ling ba Bai</code>.</p></blockquote><ul><li>题意: 给定一个不超过9位数的整数(不包括符号), 用传统中文的方式输出这个数的读法(即 <strong>拼音</strong> ), 如果是负数, 需要先读出 <code>Fu</code></li><li>思路:   <ol><li>用 <strong>字符串数组</strong> 的方式储存读入的整数(惯用方法)</li><li>由于零在这个数中有特定的读法, 因此把该数字拆成三部分分别来读, 每4位为一部分, 用 <code>left,right</code> 标志位标记当前部分的首尾下标</li></ol></li><li>参考代码:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> num[<span class="number">10</span>][<span class="number">5</span>] = &#123;<span class="string">"ling"</span>,<span class="string">"yi"</span>,<span class="string">"er"</span>,<span class="string">"san"</span>,<span class="string">"si"</span>,<span class="string">"wu"</span>,<span class="string">"liu"</span>,<span class="string">"qi"</span>,<span class="string">"ba"</span>,<span class="string">"jiu"</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> wei[<span class="number">5</span>][<span class="number">5</span>] = &#123;<span class="string">"Shi"</span>,<span class="string">"Bai"</span>,<span class="string">"Qian"</span>,<span class="string">"Wan"</span>,<span class="string">"Yi"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">15</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'-'</span>)&#123;</span><br><span class="line">        left++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fu"</span>); <span class="comment">// 如果为负数,输出"Fu"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left + <span class="number">4</span> &lt;= right)&#123;</span><br><span class="line">        right -=<span class="number">4</span>;  <span class="comment">// 将right下标左移4位,直到与left在同一4位数部分中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; len)&#123;  <span class="comment">// 每次循环处理一个部分(每4位为一部分)</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">// 该位前是否包含0.</span></span><br><span class="line">        <span class="keyword">bool</span> isPrint = <span class="literal">false</span>;   <span class="comment">// 表示该位是否被输出</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;   <span class="comment">// 该循环结束表示该部分处理完毕</span></span><br><span class="line">            <span class="keyword">if</span>(left &gt; <span class="number">0</span> &amp;&amp; str[left] == <span class="string">'0'</span>)&#123;   <span class="comment">// 如果当前位为0</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 如果当前位不为0</span></span><br><span class="line">                <span class="keyword">if</span>(flag == <span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" ling"</span>);</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(left &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>,num[str[left] - <span class="string">'0'</span>]);  <span class="comment">// 输出当前数字</span></span><br><span class="line">                isPrint = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(left != right)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" %s"</span>,wei[right - left - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isPrint == <span class="literal">true</span> &amp;&amp; right != len - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %s"</span>,wei[(len - <span class="number">1</span> -right) / <span class="number">4</span> + <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        right += <span class="number">4</span>; <span class="comment">// 右移4位,输出下一部分</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 编程 </tag>
            
            <tag> 字符串处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 日志篇(待更新)</title>
      <link href="/2019/07/09/git-log-updating/"/>
      <url>/2019/07/09/git-log-updating/</url>
      
        <content type="html"><![CDATA[<p>Git的日志工具在版本控制中有很重要的作用, 如:</p><ul><li>在团队协作中, 各成员需要实时了解当前项目的 <strong>开发进度</strong> </li><li>在分支查看及合并上, 通过 <code>--graph</code> 选项查看分支结构来帮助合并<br>而我所说的日志工具, 实则就是通过 <code>git log</code> 命令查看 <strong>提交历史</strong> . </li></ul><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Char Jin &lt;charjindev@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2019 -0800</span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Char Jin &lt;charjindev@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2019 -0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure><p>这是最基本的日志显示形式, 其中包含所有的提交记录（按时间降序）, 且一并列出 <strong>SHA-1校验和、作者姓名、邮箱、提交日期以及提交信息</strong>. 但这些数据并不适应于所有场合的显示, 所以需要定制化地显示 <code>log</code> 信息. </p><ol><li>通过 <code>-p</code> 选项显示每次提交所引入的差异, <code>-2</code> 输出最近的2次提交.   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p -2</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Char Jin &lt;charjindev@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2019 -0800</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line">diff --git a/Rakefile b/Rakefile</span><br><span class="line">index a874b73..8f94139 100644</span><br><span class="line">--- a/Rakefile</span><br><span class="line">+++ b/Rakefile</span><br><span class="line">@@ -5,7 +5,7 @@ require 'rake/gempackagetask'</span><br><span class="line"> spec = Gem::Specification.new do |s|</span><br><span class="line">     s.platform  =   Gem::Platform::RUBY</span><br><span class="line">     s.name      =   "simplegit"</span><br><span class="line">-    s.version   =   "0.1.0"</span><br><span class="line">+    s.version   =   "0.1.1"</span><br><span class="line">     s.author    =   "Char Jin"</span><br><span class="line">     s.email     =   "charjindev@gmail.com"</span><br></pre></td></tr></table></figure></li></ol><p>以上 <code>+ -</code> 号所在行分别表示该文件与上次提交时相比, 增加的新内容与删去的旧内容. 而修改一行实际上就表现为 <strong>删去了该行又添加了新行</strong> </p><ol start="2"><li><code>-stat</code> 选项查看每次提交的统计信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Char Jin &lt;charjindev@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2019 -0800</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line"> Rakefile | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Char Jin &lt;charjindev@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2019 -0800</span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line"> lib/simplegit.rb | 5 -----</span><br><span class="line"> 1 file changed, 5 deletions(-)</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Char Jin &lt;charjindev@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2019 -0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line"> README           |  6 ++++++</span><br><span class="line"> Rakefile         | 23 +++++++++++++++++++++++</span><br><span class="line"> lib/simplegit.rb | 25 +++++++++++++++++++++++++</span><br><span class="line"> 3 files changed, 54 insertions(+)</span><br></pre></td></tr></table></figure></li></ol><p>实际上 <strong>stat</strong> 就是 <strong>statistics</strong> 的缩写, 通过该选项日志会统计每一次提交 <strong>文件改动的数量以及有多少新增行和删除行</strong> , 并且能看到在日志的最后输出了总计信息. </p><ol start="3"><li>以上的两种输出选项是很直观地显示了数据的改动情况, 但是它并不适合所有场景, 很多时候我们只想知道近期有几次新的提交, 是谁提交的, 提交的内容是什么等等. 那实际上我需要的是一个<strong>简明的</strong>提交信息, 此时 <code>--pretty</code> 就非常有用了. 它用来更改日志的默认<strong>输出格式</strong>, 语法如下  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949 changed the version number 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test a11bef06a3f659402fe7563abf99ad00de2209e6 first  commit</span><br></pre></td></tr></table></figure></li></ol><p>以上命令中的 <code>oneline</code> 是Git的预置格式, 其含义如字面所述(即一行), 与之类似的还有 <strong><code>short、full、fuller</code></strong> 等等, 具体的格式效果怎样呈现, 读者可以自行尝试. </p><ol start="4"><li>虽然Git预置的格式选项很好用, 但是其定制化程度还是不高, 所以Git提供了另一种方式让使用者自定义log的输出格式<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=format:<span class="string">"%h - %an, %ar : %s"</span> </span></span><br><span class="line">ca82a6d - Char Jin, 6 years ago : changed the version number</span><br><span class="line">085bb3b - Char Jin, 6 years ago : removed unnecessary test</span><br><span class="line">a11bef0 - Char Jin, 6 years ago : first commit</span><br></pre></td></tr></table></figure>格式选项如下：</li></ol><table><thead><tr><th align="left">Option</th><th align="left">Description</th><th align="left">中文释义</th></tr></thead><tbody><tr><td align="left">%H</td><td align="left">Commit hash</td><td align="left">提交对象的散列值</td></tr><tr><td align="left">%h</td><td align="left">Abbreviated commit hash</td><td align="left">提交对象的简短散列值</td></tr><tr><td align="left">%T</td><td align="left">Tree hash</td><td align="left">树对象的散列值</td></tr><tr><td align="left">%t</td><td align="left">Abbreviated tree hash</td><td align="left">树对象的简短散列值</td></tr><tr><td align="left">%P</td><td align="left">Parent hashes</td><td align="left">父对象的散列值</td></tr><tr><td align="left">%p</td><td align="left">Abbreviated parent hashes</td><td align="left">父对象的简短散列值</td></tr><tr><td align="left">%an</td><td align="left">Author name</td><td align="left">作者的名字</td></tr><tr><td align="left">%ae</td><td align="left">Author email</td><td align="left">作者的电子邮件地址</td></tr><tr><td align="left">%ad</td><td align="left">Author date (format respects the –date=option)</td><td align="left">创作日期（可以用 –date= 选项定制格式）</td></tr><tr><td align="left">%ar</td><td align="left">Author date, relative</td><td align="left">相对于当前日期的创作日期</td></tr><tr><td align="left">%cn</td><td align="left">Committer name</td><td align="left">提交者的名字</td></tr><tr><td align="left">%ce</td><td align="left">Committer email</td><td align="left">提交者的电子邮件地址</td></tr><tr><td align="left">%cd</td><td align="left">Committer date</td><td align="left">提交日期</td></tr><tr><td align="left">%cr</td><td align="left">Committer date, relative</td><td align="left">相对于当前日期的提交日期</td></tr><tr><td align="left">%s</td><td align="left">Subject</td><td align="left">提交信息的主题</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 软技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博文</title>
      <link href="/2019/07/01/essay-the-first-blog-article/"/>
      <url>/2019/07/01/essay-the-first-blog-article/</url>
      
        <content type="html"><![CDATA[<p><strong>Char‘s Blog</strong></p><ul><li>主站地址 <a href="https://www.charjin.top" target="_blank" rel="noopener">https://www.charjin.top</a></li><li>博客地址 <a href="https://blog.charjin.top">https://blog.charjin.top</a></li></ul><blockquote><p>注: 以上域名或有更改, 若无法访问, 可转至我的github.io博客页面<a href="https://charjindev.github.io" target="_blank" rel="noopener">https://charjindev.github.io</a>, 此博客地址不做更改, 但缺点在于GitHub服务器访问速度较慢, 故优先使用前者.</p></blockquote><hr><a id="more"></a><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><strong>Jin Zhichao</strong> 同学的第一篇博文, 使用 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 作为博客开发框架. 具体的博客搭建过程将在之后的文章中逐步给出. </p><blockquote><p><code>Writing Tools:</code> Markdown</p></blockquote><ul><li>使用简单，书写流畅，无须关注排版格式</li><li>markdown 双栏模式，实时预览编写结果，书写错误易即时发现</li><li>导出简单，markdown 源文本拷贝至任意使用 markdown 的平台均有效 <blockquote><p>相关教程参考该网站 <a href="https://www.markdown.cn" target="_blank" rel="noopener">https://www.markdown.cn</a><br>或在线编辑平台 <a href="https://www.mdeditor.com" target="_blank" rel="noopener">https://www.mdeditor.com</a> <strong>(推荐)</strong></p></blockquote></li></ul><h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>一切源于 <strong>未知</strong><br>前日, 看到一位博主分享求职经历, 谈之个人博客其重要性, 在离校将求职之际, 也曾思考过大学CS科班出身的我可曾收获何物, 难以言说, 于是便想通过<del>天生沉默寡言的</del>程序员最适合的方式记录下此后的求知生活. 一切或也仅是遐想罢了! </p><h1 id="是时候展现真正的技术了"><a href="#是时候展现真正的技术了" class="headerlink" title="是时候展现真正的技术了"></a>是时候展现真正的技术了</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 精通多种语言的 “Hello World!” 输出. (^_^)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.print(<span class="string">"Hello World!"</span>);   <span class="comment">// Java</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello World!"</span>);             <span class="comment">// C</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span>;             <span class="comment">// C++</span></span><br><span class="line">echo <span class="string">"Hello World!"</span>;                <span class="comment">// PHP</span></span><br><span class="line">print(<span class="string">"Hello World!"</span>)               <span class="comment">// Kotlin</span></span><br><span class="line">print <span class="string">"Hello World!"</span>                <span class="comment">// Python</span></span><br><span class="line">...</span><br><span class="line">..</span><br><span class="line">.</span><br></pre></td></tr></table></figure><h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boy = &#123;</span><br><span class="line">    name: <span class="string">"Jin Zhichao"</span>,</span><br><span class="line">    sex: <span class="string">"male"</span>,</span><br><span class="line">    age: <span class="number">22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
