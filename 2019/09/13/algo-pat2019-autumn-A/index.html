<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>PAT甲级2019秋季 - 初考总结篇 | Zhichao's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-158590818-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'c1bb31022c448b72f7350c6d43905276';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
  </script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
  })();</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">PAT甲级2019秋季 - 初考总结篇</h1><a id="logo" href="/.">Zhichao's Blog</a><p class="description">Zhichao Jin</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">PAT甲级2019秋季 - 初考总结篇</h1><div class="post-meta">Sep 13, 2019<span> | </span><span class="category"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 8.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 38</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" href="/2019/09/13/algo-pat2019-autumn-A/#vcomment"><span class="valine-comment-count" data-xid="/2019/09/13/algo-pat2019-autumn-A/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#7-1-Forever-20-分"><span class="toc-number">1.</span> <span class="toc-text">7-1 Forever (20 分)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-2-Merging-Linked-Lists-25-分"><span class="toc-number">2.</span> <span class="toc-text">7-2 Merging Linked Lists (25 分)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-3-Postfix-Expression-25-分"><span class="toc-number">3.</span> <span class="toc-text">7-3 Postfix Expression (25 分)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-4-Dijkstra-Sequence-30-分"><span class="toc-number">4.</span> <span class="toc-text">7-4 Dijkstra Sequence (30 分)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="post-content"><p>上周末, 2019年9月8日, 终于结束了我 <a href="https://patest.cn" target="_blank" rel="noopener">PAT</a> 甲级的首次考试, 成绩 <strong>37/100, 1246/3943 (分数,排名)</strong>, 伤心之余, 记录并总结这次难得的经历与经验, 他日回首,方可对自己臭骂一句: <code>弱爆了</code>.</p>
<p>贴出 <a href="https://pintia.cn/market/item/1170913054376931328" target="_blank" rel="noopener">教育超市</a> 线上模拟后重新AC后的代码 <a href="/img/pat.html"><u>导出分析</u></a></p>
<h1 id="7-1-Forever-20-分"><a href="#7-1-Forever-20-分" class="headerlink" title="7-1 Forever (20 分)"></a>7-1 Forever (20 分)</h1><p>作者: 陈越, 单位: 浙江大学, 时间限制: 3000 ms, 内存限制: 64 MB</p>
<blockquote>
<p>“Forever number” is a positive integer <strong>A</strong> with <strong>K</strong> digits, satisfying the following constrains:</p>
<ul>
<li>the sum of all the digits of <strong>A</strong> is <em>m</em></li>
<li>the sum of all the digits of <strong>A+1</strong> is <em>n</em>; and</li>
<li>the greatest common divisor of m and n is a prime number which is greater than 2.</li>
</ul>
<p>Now you are supposed to find these forever numbers.</p>
<a id="more"></a>

<p><strong>Input Specification:</strong><br>Each input file contains one test case. For each test case, the first line contains a positive integer <strong>N</strong> (≤ <strong>5</strong>). Then N lines follow, each gives a pair of <strong>K</strong> (<strong>3</strong> &lt; <strong>K</strong> &lt; <strong>10</strong>) and m (<strong>1</strong> &lt; <strong>m</strong> &lt; <strong>90</strong>), of which the meanings are given in the problem description.</p>
<p><strong>Output Specification:</strong><br>For each pair of <strong>K</strong> and <em>m</em>, first print in a line <code>Case X</code>, where <code>X</code> is the case index (starts from 1). Then print n and <strong>A</strong> in the following line. The numbers must be separated by a space. If the solution is not unique, output in the ascending order of <em>n</em>. If still not unique, output in the ascending order of <strong>A</strong>. If there is no solution, output <code>No Solution</code>.</p>
<p><strong>Sample Input:</strong><br>2<br>6 45<br>7 80</p>
<p><strong>Sample Output:</strong><br>Case 1<br>10 189999<br>10 279999<br>10 369999<br>10 459999<br>10 549999<br>10 639999<br>10 729999<br>10 819999<br>10 909999<br>Case 2<br>No Solution</p>
</blockquote>
<p>这次的第一题坑了很多人, 以往的真题通常第一题都是十几分钟就能搞定的, 但是这次这个题的通过率是最低的. =_=!!</p>
<ul>
<li>大致题意: 定义一个”永远数”, 满足以下条件: 一个正整数 <strong>A</strong> 有<em>k</em> 位, 其每一位相加和为 <strong>m</strong>, 而 <strong>A+1</strong> 的每一位相加和为 <strong>n</strong>, 并且 <strong>m</strong> 和 <strong>n</strong> 的 <strong>最大公约数</strong> (这里把我坑惨了)是一个 <strong>大于2</strong> 的素数</li>
<li>答题过程: 开考后, 花一分钟读完第一题, 立马瞟了一眼时间限制, 给了3秒的时间, 那么长, 绝对是暴力法搞定. 立马把判定素数的函数先写出来<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
然后开始暴力枚举, 最初想的是k位, 假如是4位, 那么范围就是[1000, 9999], 用<code>pow</code>函数很轻松就得到<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minValue = <span class="built_in">pow</span>(<span class="number">10</span>, k - <span class="number">1</span>);</span><br><span class="line">maxValue = <span class="built_in">pow</span>(<span class="number">10</span>, k) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
然后依次获得每个数的各位之和 <strong>m</strong> 和 <strong>n</strong>, 再之后看一眼第三个定义条件, 抠脚操作就在这里开始了, <code>divisor</code>, divide是除的意思 好的, <code>divisor</code> 是除数. 然后用 <em>m</em> 和 <em>n</em> 中较大的除以较小的, 尝试提交样例测试代码,,,什么卵都没有, 错了, 哪错了, 从头到尾检查一遍代码, 难道不是 <strong>除数?</strong>, 余数是 remainder 啊, 不管了, 试试吧, 用大的数对小的数取余, 测试一次样例, 我去还是什么卵都没有, 难道是两数只差, 不可能, 但是也试试吧, 果不其然还是错. 放弃吧, 第一题用一个小时还没搞定我也是醉了. 然后第二题, 链表题, 噼里啪啦..对了, 终于AC了一道题, 心态好了些, 回到第一题, 再仔细读一遍题吧, 以前做真题因为没仔细读题错了好多次, <code>public common divisor</code> 最大公共除数不就是最大公约数吗, 换个叫法就不知道了我去. 这下恍然大悟, 但是又蒙了, 求最大公约数的代码好久没写过了, 怎么求? 突然脑子里想到大一学C语言的一个场景–”老冯说, 辗转相除法”, 我去就是这个, 但是怎么辗转呢 哈哈, 一顿噼里啪啦推导了几分钟, 搞定了, 开心地提交代码. 只过了两个样例, 12分, 啊, 暴力法时间复杂度 <strong>O(n<sup>10</sup>·k)</strong> 相对时间限制太高了. 绝望了, 第一题死活搞不定吗. 计时器只剩下70+分钟, 最后两题都没做, 先做后面的题吧…</li>
</ul>
<p><strong>当时提交的代码:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; a) swap(a, b);</span><br><span class="line">    <span class="keyword">int</span> c = b % a;</span><br><span class="line">    <span class="keyword">while</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        b = a;</span><br><span class="line">        a = c;</span><br><span class="line">        c = b % a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        sum += x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d\n"</span>, i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;k, &amp;m);</span><br><span class="line">        <span class="keyword">int</span> minValue = <span class="built_in">pow</span>(<span class="number">10</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="built_in">pow</span>(<span class="number">10</span>, k) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = minValue; j &lt;= maxValue; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> dm = getSum(j), dn = getSum(j + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (dm == m) &#123;</span><br><span class="line">                <span class="keyword">int</span> div = gcd(dm, dn);</span><br><span class="line">                <span class="keyword">if</span> (isPrime(div) &amp;&amp; div &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, dn, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No Solution\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后回来的第三天, 知乎上开始出现讨论 <strong>参加2019年9月8日秋季PAT测试是怎样的一种体验?</strong> 的话题, PAT的创始人兼主出题人 <a href="https://weibo.com/chenyuell?refer_flag=1005055013_" target="_blank" rel="noopener">陈越姥姥</a> 在里面回答各种问题, 大多都是吐槽最后二十分钟服务器崩掉不能提交和看题以及吐槽第一题暴力难AC的, 都被第一题难倒啦, 哈哈, 各种解法层出不穷: 暴力法, 打表, 排序, DFS… 但是姥姥说这题她的时间限制就是按照暴力解法定的,  今天我耐心的打表找一下规律, 每个满足条件的”Forever number”最后两位一定是 <strong>99</strong>, 考试的时候真的太蠢了, 如果不是99, 那么m和n差值为1, 最大公约数只能是1, 怎么可能大于2. 改进了局部代码试了一下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> minValue = <span class="built_in">pow</span>(<span class="number">10</span>, k - <span class="number">1</span> - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> maxValue = <span class="built_in">pow</span>(<span class="number">10</span>, k - <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = minValue; j &lt;= maxValue; j++) &#123;</span><br><span class="line">    <span class="keyword">int</span> dm = getSum(j) + <span class="number">18</span>, dn = getSum(j * <span class="number">100</span> + <span class="number">99</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (dm == m) &#123;</span><br><span class="line">        <span class="keyword">int</span> div = gcd(dm, dn);</span><br><span class="line">        <span class="keyword">if</span> (isPrime(div) &amp;&amp; div &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, dn, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然最后两位一定是99, 那么一个 <strong>k</strong> 位数, 我只需要枚举 <strong>k-2</strong> 位数, 然后*100+99得到实际数值即可, 改进之后, 在 <a href="https://pintia.cn/market/item/1170913054376931328" target="_blank" rel="noopener">PTA拼题教育超市</a> 重新购买考试卷模拟考试之后, 重新提交代码, 有进步, 最后一个测试样例不超时了, 但是第三个样例显示错误, <del>这个问题到现在还没想明白, 也没看到哪个网友用暴力法最终解决了这个问题, 若有读者看到此处麻烦指点一二.</del>  就在刚刚(2019/09/15 18:38)想明白了, 题目最后说了这么一段话:  <code>If the solution is not unique, output in the ascending order of n. If still not unique, output in the ascending order of A. If there is no solution, output No Solution.</code> 题目最后说按照 <code>n</code> 升序输出, 如果答案不唯一按照 <code>A</code> 升序输出, 马上告诉我朋友谷雨斌, 哈哈他和我一起破口大骂: <strong>卧槽!!!</strong>, 因为他只差这一个测试点就能拿到满分, 这尼玛已经不是第一次做题栽在看题上了, 我的印象里只有按照 <code>A</code> 升序, 读文章只看首和尾, 卧槽.</p>
<blockquote>
<p> 试试方式二: DFS </p>
</blockquote>
<p>考试结束我朋友说这题他用DFS做了两个小时, 虽然最后因为读题导致第三个测试点没通过, 但是这题用DFS的思路真的不会去想, 哪有第一题就用深度优先搜索的, 疯了, 静下来冷静思考, 确实DFS最容易解题啊, 然后 <strong>剪枝(用DFS的关键所在)</strong> 减少搜索深度.</p>
<ul>
<li>思路: <strong>k</strong> 位数, 考虑枚举分别以[1-9]开头的所有数(排除以0开头的情况, 否则就会出现 <strong>k - 1</strong> 位数的情况), 因为要记录 <strong>当前数值, 位数, 各位数之和</strong>, 所以在DFS函数中加入 <code>number, numDigit, sumD</code> 作为参数, 得到以下代码: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> number, <span class="keyword">int</span> numDigit, <span class="keyword">int</span> sumD)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sumD &gt; m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sumD + <span class="number">9</span> * (k - numDigit) &lt; m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (numDigit == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sumD != m) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> n = getDigitSum(number + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> x = gcd(m, n);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">2</span> &amp;&amp; isPrime(x)) &#123;</span><br><span class="line">            ans.push_back(&#123;n,number&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        dfs(number * <span class="number">10</span> + i, numDigit + <span class="number">1</span>, sumD + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这段递归函数中有两个 <strong><em>死胡同</em></strong> :</li>
</ul>
<ol>
<li>如果当前数值的各位之和已经大于m, 那么就没必要继续往下递归, 需要返回, 于是得到 <code>if (sumD != m) return;</code></li>
<li>假设当前记录的位数已有5位, 那么剩余位数就为 <code>k - 5</code> 位, 如果这 <code>k - 5</code> 位数都取9, 且此时的各位之和加上 <code>9 * (k - 5)</code> 都不能达到m的话, 说明后面的情况均不能得到结果, 需要及时返回 (也就是所谓的回溯), 于是得到 <code>if (sumD + 9 * (k - numDigit) &lt; m) return;</code>, 如果不做 <strong>剪枝</strong> 样例4仍然是超时的. </li>
</ol>
<p>最后将符合的结果 <code>push</code> 进vector中, 因为排序有两个条件, 所以定义一个 <code>node</code> 结构体来表示一个正确结果, 最后sort函数排序即可. 今天刚AC的代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n, k, m;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.n != b.n) <span class="keyword">return</span> a.n &lt; b.n;</span><br><span class="line">    <span class="keyword">return</span> a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sumD = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        sumD += x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sumD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> number, <span class="keyword">int</span> numDigit, <span class="keyword">int</span> sumD)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sumD &gt; m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sumD + <span class="number">9</span> * (k - numDigit) &lt; m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (numDigit == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sumD != m) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> n = getDigitSum(number + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> x = gcd(m, n);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">2</span> &amp;&amp; isPrime(x)) &#123;</span><br><span class="line">            ans.push_back(&#123;n,number&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        dfs(number * <span class="number">10</span> + i, numDigit + <span class="number">1</span>, sumD + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d\n"</span>, i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;k, &amp;m);</span><br><span class="line">        ans.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">            dfs(j, <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No Solution\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sort(ans.begin(), ans.end(), cmp);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it : ans) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, it.n, it.v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是最快的方法的解法, 最耗时的样例也只用了 <code>3ms</code>, 最后, 有始有终, 把最初使用的暴力法也给AC了, 不过同样要优化枚举次数 (即限定最后两个数为 <strong>99</strong>), 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.n != b.n) <span class="keyword">return</span> a.n &lt; b.n;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sumD = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        sumD += x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sumD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d\n"</span>, i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;k, &amp;m);</span><br><span class="line">        <span class="keyword">int</span> minValue = <span class="built_in">pow</span>(<span class="number">10</span>, k - <span class="number">1</span> - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="built_in">pow</span>(<span class="number">10</span>, k - <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">        ans.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = minValue; j &lt;= maxValue; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> dm = getDigitSum(j) + <span class="number">18</span>, dn = getDigitSum(j * <span class="number">100</span> + <span class="number">99</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (dm == m) &#123;</span><br><span class="line">                <span class="keyword">int</span> div = gcd(dm, dn);</span><br><span class="line">                <span class="keyword">if</span> (isPrime(div) &amp;&amp; div &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                    ans.push_back(&#123;dn, j * <span class="number">100</span> + <span class="number">99</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No Solution\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sort(ans.begin(), ans.end(), cmp);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it : ans) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, it.n, it.v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="7-2-Merging-Linked-Lists-25-分"><a href="#7-2-Merging-Linked-Lists-25-分" class="headerlink" title="7-2 Merging Linked Lists (25 分)"></a>7-2 Merging Linked Lists (25 分)</h1><p>作者: 陈越, 单位: 浙江大学, 时间限制: 400 ms, 内存限制: 64 MB</p>
<blockquote>
<p>Given two singly linked lists <strong><em>L<sub>1</sub> = a<sub>1</sub>→a<sub>2</sub>→⋯→a​<sub>n−1</sub>→a​<sub>n</sub></em></strong> and <strong><em>L​<sub>2​</sub> = b​<sub>1</sub>→b​<sub>2</sub>→⋯→b​<sub>m−1</sub>→b​m<sub>​</sub></em></strong> . If <strong><em>n</em></strong> ≥ <strong><em>2m</em></strong>, you are supposed to reverse and merge the shorter one into the longer one to obtain a list like <strong><em>a<sub>1</sub>→a<sub>2</sub>→b​<sub>m</sub>​→a<sub>3</sub>→a<sub>4</sub>→b​<sub>m−1</sub>⋯</em></strong>. For example, given one list being 6→7 and the other one 1→2→3→4→5, you must output 1→2→7→3→4→6→5.</p>
<p><strong>Input Specification:</strong><br>Each input file contains one test case. For each case, the first line contains the two addresses of the first nodes of <strong><em>L​<sub>1</sub></em></strong>​ and <strong><em>L​<sub>2</sub></em></strong>​​ , plus a positive <strong><em>N</em></strong> (≤ <strong><em>10​<sup>5</sup></em></strong>) which is the total number of nodes given. The address of a node is a 5-digit nonnegative integer, and NULL is represented by <code>-1</code>.</p>
<p>Then <strong><em>N</em></strong> lines follow, each describes a node in the format:</p>
<p><code>Address Data Next</code></p>
<p>where <code>Address</code> is the position of the node, <code>Data</code> is a positive integer no more than <strong><em>10<sup>5</sup>​</em></strong>​ , and <code>Next</code> is the position of the next node. It is guaranteed that no list is empty, and the longer list is at least twice as long as the shorter one.</p>
<p><strong>Output Specification:</strong><br>For each case, output in order the resulting linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<p><strong>Sample Input:</strong><br>00100 01000 7<br>2233 2 34891<br>0100 6 00001<br>4891 3 10086<br>1000 1 02233<br>0033 5 -1<br>0086 4 00033<br>0001 7 -1</p>
<p><strong>Sample Output:</strong><br>1000 1 02233<br>2233 2 00001<br>0001 7 34891<br>4891 3 10086<br>0086 4 00100<br>0100 6 00033<br>0033 5 -1</p>
</blockquote>
<p>这道最常规的题成为这四道题里我唯一AC的题（┬＿┬）. 前面第一题因为<u>最大公约数</u>的原因, 我直接跳到了第二题, 看到这样的题, 就会莫名有亲切感, 链表, 最容易了, 哈哈.</p>
<ul>
<li>大致题意: 有L1,L2两个链表, 如果L1的长度 &gt;= 2倍的L2长度, 则把L2中的元素逆序插入L1中, 插入规则: <strong>从L1的首结点开始, 每碰到两个结点就从L2的末尾取一个结点插入L1的当前位置之后</strong>.</li>
<li>思路: 这种题如果按照链表的做法思路就很清晰了, 因为<code>PAT</code>的链表题都是给定结点地址和后继结点地址的, 显然这不是内存地址, 所以一定是用静态链表来表示链表结构.</li>
<li>解题步骤:<ol>
<li>逆置链表L2, 因为所给的链表都没有头结点, 为了逆置链表, 必须自行添加一个头结点, 为了避免使用已有结点的地址, 所以头结点的指针(即数组中的索引)需要从 <code>maxn - 1</code> 往前取, 然后其后继指针指向链表的第一个元素.</li>
<li>然后遍历设 <code>p</code> 指针, 遍历长链表, 遍历过程中通过 <code>cnt</code> 计数, 达到2, 则插入短链表的第一个结点, 然后重置 <code>cnt</code> 为 0.</li>
</ol>
</li>
</ul>
<p><strong>当时提交的代码:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data, address, next;</span><br><span class="line">&#125; Node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverseList</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = maxn - <span class="number">1</span>;</span><br><span class="line">    Node[head].next = start;</span><br><span class="line">    <span class="keyword">int</span> last = Node[head].next, p = Node[last].next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">        Node[last].next = Node[p].next;</span><br><span class="line">        Node[p].next = Node[head].next;</span><br><span class="line">        Node[head].next = p;</span><br><span class="line">        p = Node[last].next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Node[head].next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">int</span> head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d "</span>, Node[p].address, Node[p].data);</span><br><span class="line">        <span class="keyword">if</span> (Node[p].next == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%05d\n"</span>, Node[p].next);</span><br><span class="line">        p = Node[p].next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLen</span><span class="params">(<span class="keyword">int</span> head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = head, len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">        p = Node[p].next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head1, head2, n, address;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;head1, &amp;head2, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;address);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;Node[address].data, &amp;Node[address].next);</span><br><span class="line">        Node[address].address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len1 = getLen(head1), len2 = getLen(head2);</span><br><span class="line">    <span class="keyword">if</span> (len1 == <span class="number">0</span>) printList(head2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (len2 == <span class="number">0</span>) printList(head1);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q, p;</span><br><span class="line">        <span class="keyword">if</span> (len1 &gt;= len2 * <span class="number">2</span>) &#123;</span><br><span class="line">            p = head1;</span><br><span class="line">            q = reverseList(head2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len2 &gt;= <span class="number">2</span> * len1) &#123;</span><br><span class="line">            p = head2;</span><br><span class="line">            q = reverseList(head1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="number">-1</span> &amp;&amp; q != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++cnt == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = Node[q].next;</span><br><span class="line">                Node[q].next = Node[p].next;</span><br><span class="line">                Node[p].next = q;</span><br><span class="line">                p = Node[p].next;</span><br><span class="line">                q = temp;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = Node[p].next;</span><br><span class="line">        &#125;</span><br><span class="line">        printList(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后来思考中间有一部分逻辑判断是无用, 但是考试的时候一看AC了也就没管了.</p>
<p>然而这就开心了吗, 哎, 做过<code>PAT</code>的所有真题, 链表题通常都不是用链表的方法做的, 考试的时候没想这么多, 虽然AC了, 但是这题做了四十多分钟, 今天教育超市重新模拟, 换了另一种 <del>常规</del> 解法: 因为, 提交代码后的测试样例只检验输出结果是否正确, 并不分析源码, 所以只需要所得一个结果而不是真的去改变链表的结构.</p>
<ul>
<li>思路: 遍历L1, L2把结点分别 <code>push</code> 进vector中 (定义<code>vecotr&lt;node&gt; l1, l2</code>), 另外声明一个同样类型的变量 <code>ans</code>(解题的常规操作), 遍历较长的链表把其结点依次 <code>push</code> 进 <code>ans</code> 中, 每插入两个结点就从l2结尾取一个结点插入 <code>ans</code>.</li>
</ul>
<p><strong>代码如下:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> adr, data, next;</span><br><span class="line">&#125; Node[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; l1, l2, ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateList</span><span class="params">(<span class="built_in">vector</span>&lt;node&gt; &amp;L, <span class="keyword">int</span> head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">        L.push_back(Node[p]);</span><br><span class="line">        p = Node[p].next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="built_in">vector</span>&lt;node&gt; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>, L[i].adr, L[i].data, L[i + <span class="number">1</span>].adr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%05d %d -1\n"</span>, L[L.size() - <span class="number">1</span>].adr, L[L.size() - <span class="number">1</span>].data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h1, h2, n, adr;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; h1 &gt;&gt; h2 &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; adr;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; Node[adr].data &gt;&gt; Node[adr].next;</span><br><span class="line">        Node[adr].adr = adr;</span><br><span class="line">    &#125;</span><br><span class="line">    generateList(l1, h1);</span><br><span class="line">    generateList(l2, h2);</span><br><span class="line">    <span class="keyword">if</span> (l1.size() &lt; l2.size()) &#123;</span><br><span class="line">        swap(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1.size() &gt;= l2.size() * <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, pos = l2.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : l1) &#123;</span><br><span class="line">            ans.push_back(it);</span><br><span class="line">            <span class="keyword">if</span> (++cnt % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; pos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ans.push_back(l2[pos--]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printList(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意点: <code>generateList</code> 函数中的第一个参数 <code>L</code> 必须用引用类型.</p>
</blockquote>
<p>用 <code>vector</code> 来解决链表问题是最常用的手段, 也能极大缩短编码时间. 这道题虽然AC了, 但是一开始用了蠢办法浪费了太多考试时间.</p>
<hr>
<h1 id="7-3-Postfix-Expression-25-分"><a href="#7-3-Postfix-Expression-25-分" class="headerlink" title="7-3 Postfix Expression (25 分)"></a>7-3 Postfix Expression (25 分)</h1><p>作者: 陈越, 单位: 浙江大学, 时间限制: 400 ms, 内存限制: 64 MB</p>
<blockquote>
<p>Given a syntax tree (binary), you are supposed to output the corresponding postfix expression, with parentheses reflecting the precedences of the operators.</p>
<p><strong>Input Specification:</strong><br>Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 20) which is the total number of nodes in the syntax tree. Then N lines follow, each gives the information of a node (the <strong><em>i</em></strong> -th line corresponds to the <strong><em>i</em></strong> -th node) in the format:</p>
<p><code>data left_child right_child</code></p>
<p>where <code>data</code> is a string of no more than 10 characters, <code>left_child</code> and <code>right_child</code> are the indices of this node’s left and right children, respectively. The nodes are indexed from 1 to N. The NULL link is represented by −1. The figures 1 and 2 correspond to the samples 1 and 2, respectively.</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="/img/first_pat_p1.JPG" alt="Figure 1"></td>
<td align="center"><img src="/img/first_pat_p2.JPG" alt="Figure 2"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong>Output Specification:</strong><br>For each case, print in a line the postfix expression, with parentheses reflecting the precedences of the operators.There must be no space between any symbols.</p>
<p><strong>Sample Input 1:</strong><br>8<br>* 8 7<br>a -1 -1<br>* 4 1<br>+ 2 5<br>b -1 -1<br>d -1 -1<br>- -1 6<br>c -1 -1</p>
<p><strong>Sample Output 1:</strong><br>(((a)(b)+)((c)(-(d))*)*)</p>
<p><strong>Sample Input 2:</strong><br>8<br>2.35 -1 -1<br>* 6 1<br>- -1 4<br>% 7 8<br>+ 2 3<br>a -1 -1<br>str -1 -1<br>871 -1 -1</p>
<p><strong>Sample Output 2:</strong><br>(((a)(2.35)*)(-((str)(871)%))+)</p>
</blockquote>
<p>这道题目初次瞄到这两张Figure的时候, 看了一眼输入输出样例, 与我当初看过的一道计算器算法题尤为相似, 非递归求解非常复杂, 当时没细看, 心想: 我去, 怕什么来什么吗. 所以直接跳到了下题. 直到今天重新做题, 我太抓狂了, 这道题非常非常的简单, 十几分钟就能写完的题目, 我考试的时候连提交都没有提交啊.</p>
<ul>
<li>题意: 后缀表达式, 通过输出括弧表示操作符的优先级.</li>
<li>思路: 给出的结构是二叉树(静态二叉树表示), 如果只是后缀表达的话, 就非常简单, 只用 <code>递归的后序遍历</code> 即可, 像这样:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    postOrder(Node[root].lchild);</span><br><span class="line">    postOrder(Node[root].rchild);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Node[root].data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
用 <code>Figure1</code> 举例, 在后序遍历输出第一个数 <code>a</code> 的时候, 前面需要输出3个左括弧, 这实际上对应了 <code>a</code> 所在的层数(也就对应了递归调用 <code>postOrder</code> 的深度), 所以需要在当前结点向左孩子递归之前就输出这个 <code>(</code> , 同时, 输出一个操作数之后需要立马输出一个 <code>)</code> , 所以最后会得到这样的代码:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span>;</span><br><span class="line">    postOrder(Node[root].lc);</span><br><span class="line">    postOrder(Node[root].rc);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Node[root].v;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
先运行一下代码测试第一个样例, 得到这样的输出:    <figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(((<span class="name">a</span>)(<span class="name">b</span>)+)((<span class="name">c</span>)((<span class="name">d</span>)-)*)*)</span><br></pre></td></tr></table></figure>
看着感觉像回事了, 但是发现 <code>d</code> 的后面的负号实际上不是<code>空字符-d</code>, 而是表示 <code>d</code> 是个负数, 所以如果某一个操作符如果 <strong>左子树为空, 右子树不为空</strong>, 就说明这个符号是用来表示正负号的, 不应该放到这个操作数的后面. 所以思路就变得清晰了: <strong>操作符比操作数先输出, 对应到二叉树的结构中就是根节点先输出再输出孩子结点</strong>, 也就是 <strong>先序或中序遍历</strong>, 但是这里一定是从二叉树的最左侧结点开始输出, 所以不可能再是先序遍历了, 于是很容易就得到以下代码:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOperator</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str == <span class="string">"-"</span> || str == <span class="string">"/"</span> || str == <span class="string">"*"</span> || str == <span class="string">"+"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span>;</span><br><span class="line">    postOrder(Node[root].lc);</span><br><span class="line">    <span class="keyword">if</span> (isOperator(Node[root].v) &amp;&amp; Node[root].lc == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Node[root].v;</span><br><span class="line">        postOrder(Node[root].rc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        postOrder(Node[root].rc);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Node[root].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>全部代码如下:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> v;</span><br><span class="line">    <span class="keyword">int</span> lc, rc;</span><br><span class="line">&#125; Node[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span>;</span><br><span class="line">    postOrder(Node[root].lc);</span><br><span class="line">    <span class="keyword">if</span> (Node[root].v == <span class="string">"-"</span> &amp;&amp; Node[root].lc == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Node[root].v;</span><br><span class="line">        postOrder(Node[root].rc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        postOrder(Node[root].rc);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Node[root].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; Node[i].v &gt;&gt; Node[i].lc &gt;&gt; Node[i].rc;</span><br><span class="line">        <span class="keyword">if</span> (Node[i].lc != <span class="number">-1</span>) vis[Node[i].lc] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (Node[i].rc != <span class="number">-1</span>) vis[Node[i].rc] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> R;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            R = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(R);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题从读题到完成AC只用了十几分钟, 但是考试的时候我没提交… 25分随之飘走.</p>
<hr>
<h1 id="7-4-Dijkstra-Sequence-30-分"><a href="#7-4-Dijkstra-Sequence-30-分" class="headerlink" title="7-4 Dijkstra Sequence (30 分)"></a>7-4 Dijkstra Sequence (30 分)</h1><p>作者: 陈越, 单位: 浙江大学, 时间限制: 1500 ms, 内存限制: 64 MB</p>
<blockquote>
<p>Dijkstra’s algorithm is one of the very famous greedy algorithms. It is used for solving the single source shortest path problem which gives the shortest paths from one particular source vertex to all the other vertices of the given graph. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.</p>
<p>In this algorithm, a set contains vertices included in shortest path tree is maintained. During each step, we find one vertex which is not yet included and has a minimum distance from the source, and collect it into the set. Hence step by step an ordered sequence of vertices, let’s call it <strong>Dijkstra sequence</strong>, is generated by Dijkstra’s algorithm.</p>
<p>On the other hand, for a given graph, there could be more than one Dijkstra sequence. For example, both { 5, 1, 3, 4, 2 } and { 5, 3, 1, 2, 4 } are Dijkstra sequences for the graph, where 5 is the source. Your job is to check whether a given sequence is Dijkstra sequence or not.</p>
<p><strong>Input Specification:</strong><br>Each input file contains one test case. For each case, the first line contains two positive integers <strong><em>N</em></strong><sub>v</sub> (≤ 10<sup>3</sup>) and <strong><em>N</em></strong><sub>e</sub> (≤ 10<sup>5</sup>), which are the total numbers of vertices and edges, respectively. Hence the vertices are numbered from 1 to <strong><em>N</em></strong><sub>v</sub> .</p>
<p>Then <strong><em>N</em></strong><sub>e</sub> lines follow, each describes an edge by giving the indices of the vertices at the two ends, followed by a positive integer weight (≤ <strong>100</strong>) of the edge. It is guaranteed that the given graph is connected.</p>
<p>Finally the number of queries, <strong>K</strong>, is given as a positive integer no larger than <strong>100</strong>, followed by <strong>K</strong> lines of sequences, each contains a permutationof the <strong><em>N</em></strong>​<sub>v</sub> vertices. It is assumed that the first vertex is the source for each sequence.</p>
<p>All the inputs in a line are separated by a space.</p>
<p>Output Specification:<br>For each of the K sequences, print in a line Yes if it is a Dijkstra sequence, or No if not.</p>
<p><strong>Sample Input:</strong><br>5 7<br>1 2 2<br>1 5 1<br>2 3 1<br>2 4 1<br>2 5 2<br>3 5 1<br>3 4 1<br>4<br>5 1 3 4 2<br>5 3 1 2 4<br>2 3 4 5 1<br>3 2 1 5 4</p>
<p><strong>Sample Output:</strong><br>Yes<br>Yes<br>Yes<br>No</p>
</blockquote>
<p>考试的时候跳过第三题, 看到第四题 named <code>Dijkstra</code> 的时候我非常开心, 因为我对单源最短路径的Dijkstra算法非常非常熟悉, 以往的考过的真题大多都是与最短路径相关的实际应用题, 比如以下几道:</p>
<ul>
<li><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376" target="_blank" rel="noopener">A1003 Emergency</a></li>
<li><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805500414115840" target="_blank" rel="noopener">A1013 Battle Over Cities</a></li>
<li><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805489282433024" target="_blank" rel="noopener">A1018 Public Bike Management</a></li>
<li><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805396953219072" target="_blank" rel="noopener">A1072 Gas Station</a></li>
<li><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805379664297984" target="_blank" rel="noopener">A1087 All Roads Lead to Rome</a></li>
<li>…</li>
</ul>
<p>上面这几道题, 做法都是比较单一的, 通常都是用 <strong>Dijkstra + DFS</strong> 来解题, 即通过Dijkstra算法得到一个最短路径树(形成了树结构, 用vector存储), 既然用树来存放路径, 必定可以用DFS获得每一条路径(从根节点到每个叶子节点即为一条最短路径), 最后得出最优解(通常就是路径的点权值或者边权值).<br>但是, 这个题它并不是个常规题…. 我去</p>
<ul>
<li>大致题意: <ol>
<li>人话描述一下Dijkstra算法, Dijkstra是单源最短路径算法之一, 也就是求一个图中的某一个顶点到所有其他顶点的最短路径的算法. 一般要先给出一个 <code>源点</code>, 这个源点会最先被包含到集合中, 然后从这个点出发, 找到图中离它最近的邻接点(如果是无向图就是与之相邻的顶点, 如果是有向图就是该顶点所指向的顶点), 通常通过边权来判断距离大小, 也就是两顶点之间弧的权值, 然后把找到的最近邻接点加入到集合中, 并标记这个顶点已经被包含进集合, 然后再去寻找下一个离当前顶点最近的邻接点再加入集合, 在此过程中会声明一个 <code>dist</code> 数组用来记录从源点到各个顶点的最短距离并优化, 而在寻找最近邻接点的过程可能会存在多个邻接点与当前顶点距离最近, 这个时候就产生了多个获得最短路径的访问序列, 这个序列就被称之为 <strong>Dijkstra序列</strong>, 而为什么最后得到的最短路径是唯一的, 就是因为无论从哪个邻接点再次出发, 记录最短路径值的 <code>dist</code> 数组都会逐步做出优化. 所以Dijkstra实际上是个贪心算法, 从局部最优得到整体最优.</li>
<li>题目要求: 最后给出 <code>k</code> 个序列, 需要通过程序判断这是不是一个Dijkstra序列. 并假设第一个顶点是这个序列的源点.</li>
</ol>
</li>
<li>解题思路: (考试的时候没想到呀….), Dijkstra算法实现的第一个核心部分是 <strong>找到当前顶点的最近邻接点</strong> , 这里比较适合先贴出全部代码:<br><img src="/img/first_pat_graph.png" alt="Sample 1: Graph"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7FFFFFFF</span>;</span><br><span class="line"><span class="keyword">int</span> G[maxn][maxn], d[maxn], number[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    fill(vis, vis + maxn, <span class="literal">false</span>);</span><br><span class="line">    fill(d, d + maxn, INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span> || d[u] != d[number[i]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        u = number[i];</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; G[u][v] != INF) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">                    d[v] = d[u] + G[u][v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    fill(G[<span class="number">0</span>], G[<span class="number">0</span>] + maxn * maxn, INF);</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;G[u][v]);</span><br><span class="line">        G[v][u] = G[u][v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; number[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Dijkstra(number[<span class="number">1</span>])) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"No\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上述的核心代码在 <strong>17-23</strong> 行, <code>vis</code> 数组用来标记某顶点是否被访问过, 实际上就是所述抽象出来的<u>是否被存入集合中</u>, <code>MIN</code> 被定义为一个无穷大的数INF(即infinite, 在C++中用可以用十六进制表示最大整型0x7FFFFFFF), 这代码要找出未被存入集合, 且离当前顶点最近的邻接点, 实际这个点就是题目中对应需要被判定的点. 考试的时候, 虽然可以 <strong>存在多个满足条件的邻接点</strong>,但是上述代码中因为 <code>d[j] &lt; MIN</code>, 实际上只能取得第一个满足条件的邻接点, 当时我没想明白只取到一个邻接点该如何跟多个序列做对比, 这个问题把我给想傻掉了, 实际上可以记录所有的最短路径, 然后与给定的序列依次比较, 但是这种做法显然非常愚蠢. 根据题目给定的极端数据量和序列长度, 这个解法一定会有多个样例超时.</li>
</ul>
<p>唉, 其实这个问题非常简单, 上述代码每次得到的邻接点是唯一的, 但是最短距离也是唯一, 判定最近邻接点的根本依据仍旧是边长, 所以通过给定的序列去做匹配, 如果当前顶点到序列中对应的顶点距离与之前得到的最短距离是相同的, 说明序列中的这个顶点也是最近的邻接点, 那么就可以把该点作为下一个出发源点, 如果出现距离不相等立马就可以判定这个序列是不合法的, 随即 <code>return false</code>. 最终今天AC通过的代码, 与考试时候提交的答案只差了两行关键代码.0分与30分只有两行代之差<br><strong>以下是考试时的提交代码:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7FFFFFFF</span>;</span><br><span class="line"><span class="keyword">int</span> G[maxn][maxn], d[maxn], number[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    fill(vis, vis + maxn, <span class="literal">false</span>);</span><br><span class="line">    fill(d, d + maxn, INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解题代码应贴在此处..............</span></span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; G[u][v] != INF) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">                    d[v] = d[u] + G[u][v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    fill(G[<span class="number">0</span>], G[<span class="number">0</span>] + maxn * maxn, INF);</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;G[u][v]);</span><br><span class="line">        G[v][u] = G[u][v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; number[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看自己以如此欢快的口气写完了所有代码的总结, 实际上因为我已经难过了一阵子了, 哈哈. 这次的考试经历, 对自己算是个不小的打击, 总结几点经验:</p>
<ol>
<li>考试前一天太过激动(不是紧张), 一晚上没睡着呀, 肾上腺素指数上升.</li>
<li>心理素质不行呀, 坐上考场, 脑子一片嗡嗡的, 思考问题完成没平时做题淡定.</li>
<li>终归问题是能力不行, 对”较大”场合适应能力不强, 得多经历一些类似的场合.</li>
<li>…. 下一回考前必须要有足够的睡眠以保证头脑清晰.</li>
</ol>
<p>这次考试结束, 知乎上许多人都是最后三题只花一个小时, 这点真是非常遗憾, 是非常简单的题目, 但是我答的像屎一样, 尤其是第三道送分题, 我还回去了25分. 对于这次认为应该是最简单但却最坑的第一题, 死磕了一个多小时还是没AC, 太死板了, 心态也崩坏了, 阿斌说这题他看了几分钟立马跳到后面的题, 哈哈, 这都是经验呀.<br>最后, 为什么说是一次遗憾的考试, 没考出水平是一方面, 另一方面, 暑假大把时间地通刷真题, 本想是一次开心的检验性考试, 但是走出考场确实很失落, 以致于没等到拿PAT证书就走了, 这真是遗憾啊, 毕竟没有电子证书, 只有一人一章一份的浙大证书.<br>同时, 暑假这段刷题的经历, 不但了解了ACM相关竞赛的知识, 也终于让我体会到了编程的真正乐趣: 写程序不是简单的 <code>if ... else ...</code> 判断, 而且说把一个实际问题抽象建模, 寻找能表示问题的最佳模型(即数据结构), 再找到能够解决问题的方法(即算法), 从解决问题从最慢到最快(改进算法时间复杂度, 回溯法), 从理解局部最优到整体最优等, 这个学习过程真是很难, 但是确实很有乐趣. 考前一天我私信姥姥问她以后PAT出题是否会越来越难, 她说:”不会, 一如既往地简单.”, 同时引用姥姥近期在知乎上关于 <a href="https://www.zhihu.com/question/345369507/answer/819630590?hb_wx_block=1&utm_source=qq&utm_medium=social&utm_oi=913895491333419008" target="_blank" rel="noopener">数据结构到底难在哪里?</a> 的一个回答:<br><img src="/img/first_pat_zhihu.png" alt=""><br>对其他重点高校的学生来说, 在OJ平台上做一道编程题可能就像我写一句 <code>print &quot;Hello World!&quot;</code> 这么简单, 就比如说, 这次的PAT甲级最快AC四道题的时间是1小时15分, 而PAT考试历史最快是45分钟AC四题, 我自己也深有感触, 从最开始刷 <a href="https://pintia.cn/problem-sets/994805342720868352/problems/type/7" target="_blank" rel="noopener">PAT甲级题目</a> 的寸步难行到现在大部分题的解题方法步骤几乎可以不经思考地默写(然后这次考地一塌糊涂), 长期的练习才能孰能生巧, 但是和上面这些大牛还是相差甚远啊. 看到其他学校OJ平台上的C/C++的课后习题就是PAT乙级的难度了, 别人在初学之时就接受了比我难的多的训练. 这点遗憾已经不能回到从前去补救了, 只能后起直追.</p>
<p>最后:  哈哈哈, 看到这条姥姥发的微博, 我赶紧搜了一下我们学校, 我笑了<br><a href="https://weibo.com/ttarticle/p/show?id=2309404415478327017570" target="_blank" rel="noopener">2019 年 PAT 秋季考试 - 学校加权总成绩排名</a><br><img src="/img/first_pat_rank.png" alt="顶级分数 x 1.5 + 甲级分数 + 乙级分数 / 1.5"><br>我们学校就我一人参加甲级, 37分撑到了第314名, 后面还有一百多个学校, 哈哈, 他们真的是去划水的呀.</p>
<p><font size="26">再接再厉…</font></p>
</div><iframe src="/donate/?AliPayQR=/img/alipay_me.png&amp;WeChatQR=/img/wechat_me.png&amp;GitHub=https://github.com/charjindev/donate-page&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Char Jin</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/09/13/algo-pat2019-autumn-A/">https://blog.charjin.top/2019/09/13/algo-pat2019-autumn-A/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://blog.charjin.top/2019/09/13/algo-pat2019-autumn-A/" data-id="clhhn3hro000ctbrl0shka3r4" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACJElEQVR42u3aMW7DMAwF0Nz/0inQqUMjf5JuAUtPU9A6jp4GghT5esXr/b3Wf/n5909r/eb1kzcsDAyMxzKSH04+J1tZH8en340OBQMD4wBGHgrX1MkR9J7BwMDAqCaCeSq5PggMDAyMScBdA5IN9YI1BgYGxiTt6yHzwH1zLY6BgfFARrUx8J+f/7C/gYGB8RDGu7h6b1g/ecOuMDAwtmbMBynuHbCYXMBhYGDszaiWl0lpWmX0jhUDA+McRj4kkWx90myoVqwYGBjnMHoRrBp8JyNfIzwGBsbDGXm5mL+6+oabp0UwMDC2Y1QBvRCcbLF3oL+EXQwMjE0Zky9PhrR6G71oPGBgYGzH6KVr+X+T8+u1EDAwMDDyUa15w7J60YaBgXEmo1pA5sF0QioMXmBgYGzNyAvRd3FVxzXyPVw0MjEwMLZjJAVqXoJO2gNJcXtxU4iBgbEpI8+vJtdk1bDeSzoxMDBOY0yGvapbz4NsoQDGwMDYiJGkfdUr+3xIIk/+Lo4DAwPjAEZ18Cu/MqsObSSHFdXiGBgYGzGq1/fz9mQzY03KWgwMjE0Zk8ZkLx2slr5RSoqBgbE1o3fT3rsy6zUVqkkqBgbGrozegFd15OKugPvxIDAwMA5gVO+vRldjg1D+8VsYGBgYrRZCnjJWAzQGBgbGZNiiyqhe5F20BzAwMLZmzAe2es/P2wwYGBgnMOaNgd4o2CRBbGIwMDCex/gCRzs39ew7Sm0AAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/PAT/">PAT</a><a href="/tags/%E7%BC%96%E7%A8%8B/">编程</a><a href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div><div class="post-nav"><a class="pre" href="/2020/01/05/pat-a1101-b1045/">2019的简短总结与Quick Sort之动态规划</a><a class="next" href="/2019/07/20/hexo-build/">Hexo 博客搭建中的插件安装</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' ? true : false;
var verify = 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'t4DnKL6Wzc2cJnKlPvgi1mFm-gzGzoHsz',
  appKey:'wRCuQw2SaMNzhBbLJClaYxn4',
  placeholder:'Just leave your comment, Haha...',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">39</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/">开发框架</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">编程笔记</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AF%E6%8A%80%E8%83%BD/">软技能</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" style="font-size: 15px;">树状数组</a> <a href="/tags/%E6%9F%A5%E6%89%BE/" style="font-size: 15px;">查找</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" style="font-size: 15px;">二分查找</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 15px;">二叉树</a> <a href="/tags/%E9%80%92%E5%BD%92%E6%B1%82%E8%A7%A3/" style="font-size: 15px;">递归求解</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" style="font-size: 15px;">二叉搜索树</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 15px;">动态规划</a> <a href="/tags/%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97/" style="font-size: 15px;">最长不下降子序列</a> <a href="/tags/PAT/" style="font-size: 15px;">PAT</a> <a href="/tags/%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">编程</a> <a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 15px;">生活</a> <a href="/tags/%E6%A0%91/" style="font-size: 15px;">树</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 15px;">并查集</a> <a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/OJ/" style="font-size: 15px;">OJ</a> <a href="/tags/%E6%A0%88/" style="font-size: 15px;">栈</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 15px;">队列</a> <a href="/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/" style="font-size: 15px;">堆排序</a> <a href="/tags/%E5%A0%86/" style="font-size: 15px;">堆</a> <a href="/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/" style="font-size: 15px;">版本控制</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 15px;">博客</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/%E7%AB%99%E7%82%B9url%E8%87%AA%E5%8A%A8%E6%8E%A8%E9%80%81/" style="font-size: 15px;">站点url自动推送</a> <a href="/tags/Kotlin/" style="font-size: 15px;">Kotlin</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">编程语言</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD/" style="font-size: 15px;">素数判断</a> <a href="/tags/%E6%A8%A1%E6%8B%9F/" style="font-size: 15px;">模拟</a> <a href="/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/" style="font-size: 15px;">进制转换</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 15px;">排序算法</a> <a href="/tags/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/" style="font-size: 15px;">简单排序</a> <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/" style="font-size: 15px;">最短路径算法</a> <a href="/tags/Dijkstra%E7%AE%97%E6%B3%95/" style="font-size: 15px;">Dijkstra算法</a> <a href="/tags/%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/" style="font-size: 15px;">有序序列的中位数</a> <a href="/tags/Dijkstra%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/" style="font-size: 15px;">Dijkstra最短路径算法</a> <a href="/tags/DFS/" style="font-size: 15px;">DFS</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" style="font-size: 15px;">深度优先搜索</a> <a href="/tags/%E5%89%AA%E6%9E%9D/" style="font-size: 15px;">剪枝</a> <a href="/tags/BFS/" style="font-size: 15px;">BFS</a> <a href="/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" style="font-size: 15px;">广度优先搜索</a> <a href="/tags/%E6%A8%A1%E6%8B%9F%E9%97%AE%E9%A2%98/" style="font-size: 15px;">模拟问题</a> <a href="/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 15px;">平衡二叉树</a> <a href="/tags/AVL/" style="font-size: 15px;">AVL</a> <a href="/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 15px;">完全二叉树</a> <a href="/tags/%E5%AE%8C%E5%85%A8%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 15px;">完全平衡二叉树</a> <a href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%88%A4%E5%88%AB/" style="font-size: 15px;">红黑树的判别</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" style="font-size: 15px;">二叉树最低公共祖先</a> <a href="/tags/LCA/" style="font-size: 15px;">LCA</a> <a href="/tags/%E5%A0%86%E7%9A%84%E5%88%A4%E5%AE%9A/" style="font-size: 15px;">堆的判定</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/" style="font-size: 15px;">字符串处理</a> <a href="/tags/PTA/" style="font-size: 15px;">PTA</a> <a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91Prime%E7%AE%97%E6%B3%95/" style="font-size: 15px;">最小生成树Prime算法</a> <a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91Kruskal%E7%AE%97%E6%B3%95/" style="font-size: 15px;">最小生成树Kruskal算法</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" style="font-size: 15px;">贪心算法</a> <a href="/tags/%E5%9B%A2%E4%BD%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A9%E6%A2%AF%E8%B5%9B/" style="font-size: 15px;">团体程序设计天梯赛</a> <a href="/tags/map/" style="font-size: 15px;">map</a> <a href="/tags/%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 15px;">前缀表达式</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90/" style="font-size: 15px;">字符串解析</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/openpyxl/" style="font-size: 15px;">openpyxl</a> <a href="/tags/tkinter/" style="font-size: 15px;">tkinter</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/JUnit/" style="font-size: 15px;">JUnit</a> <a href="/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" style="font-size: 15px;">单元测试</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/05/06/linux/screen/">Screen 命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/22/linux/docker-installation/">Docker 安装与配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/18/linux/terminal-proxy/">Linux 终端开启代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/31/linux/apt-errors/">Ubuntu 中的 apt 错误</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/28/linux/switch-intel-nvidia-graphics-card/">How To Switch Between Intel and Nvidia Graphics Card on Ubuntu</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/05/linux/ssh-disconnect-solution/">SSH 自动断连问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/27/linux/create-systemd-service/">Linux 中创建系统服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/28/linux/linux-firewall/">Linux 设置防火墙</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/17/linux/ssh-jump/">SSH 跳板服务器连接</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/12/01/linux/oh-my-zsh/">Linux终端配置 - ohmyzsh</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://pintia.cn" title="拼题A" target="_blank">拼题A</a><ul></ul><a href="https://kotlinlang.org" title="Kotlin" target="_blank">Kotlin</a><ul></ul><a href="https://www.patest.cn" title="PAT" target="_blank">PAT</a><ul></ul><a href="https://en.cppreference.com" title="C++ Reference" target="_blank">C++ Reference</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">Zhichao's Blog | </a><a href="http://beian.miit.gov.cn/" target="_blank" rel="noopener">浙ICP备18033074号-1</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/viz.js/1.7.1/viz.js"></script><script>String.prototype.replaceAll = function(search, replacement) {
  var target = this;
  return target.split(search).join(replacement);
};

let vizObjects = document.querySelectorAll('.graphviz')

for (let item of vizObjects) {
  let svg = undefined
  try {
    svg = Viz(item.textContent.replaceAll('–', '--'), 'svg')
  } catch(e) {
    svg = `<pre class="error">${e}</pre>`
  }
  item.outerHTML = svg
}</script></div></body></html>