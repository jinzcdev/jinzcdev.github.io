<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>2019的简短总结与Quick Sort之动态规划 | Zhichao's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-158590818-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'c1bb31022c448b72f7350c6d43905276';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
  </script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
  })();</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">2019的简短总结与Quick Sort之动态规划</h1><a id="logo" href="/.">Zhichao's Blog</a><p class="description">Zhichao Jin</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">2019的简短总结与Quick Sort之动态规划</h1><div class="post-meta">Jan 5, 2020<span> | </span><span class="category"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 10</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" href="/2020/01/05/pat-a1101-b1045/#vcomment"><span class="valine-comment-count" data-xid="/2020/01/05/pat-a1101-b1045/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#A1101-Quick-Sort-B1045-快速排序"><span class="toc-number">1.</span> <span class="toc-text">A1101 Quick SortB1045 快速排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">2.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="post-content"><p>离上一篇<a href="https://blog.charjin.top/2019/09/13/the-first-pat-advanced"> PAT甲级2019秋季 - 初考总结篇 </a>的文章已经过去接近4个月的时间，大四上学年这最后几个月，亦有忙碌亦有清闲之时，有收获却感觉失去的更多，最大的遗憾或是没参加2020的研究生考试，是所谓对的决定还是逃避的表现，心里的答案已经给了后者。最早决定考研的人没有走上考场，而在21号清晨7点一刻看涌向学校的考生和比平时繁多的接送车，心里默默给他们和在绍兴的雨斌加油，思考来年自己是不是也和他们一个样子。今天收拾完行李，把没翻过几次的两大箱书寄回家，想到去年离家至今已快满一年，这接近一年的时间除了在脑子里装进了几个梦和被岁月在我头顶夺走几缕秀发外，没什么别的变化。后天走上归程，期待儿子回家的老妈肯定还是认为这是那个优秀的大儿子，(感叹) 早就想回温州吃10碗瘦肉丸和老妈做的饭了。</p>
<a id="more"></a>

<p>现在，整顿过后杂乱的房间，终于有点要离开的样子了，没有室友的房间并没什么与室友告别的伤感，待到下次回来，这里也只是个留宿之地了。</p>
<p>搭建这个博客起初的目的也想记录生活，但写下的完整的博文也是寥寥无几。唯一还有的好习惯便是每天至少做几道编程题了。安静下来，假期后的周边也不再喧闹，写道题回去继续开始。</p>
<hr>
<p>题目来源:</p>
<ul>
<li><a href="https://pintia.cn/problem-sets/994805342720868352/problems/type/7" target="_blank" rel="noopener">PAT (Advanced Level) Practice</a></li>
<li><a href="https://pintia.cn/problem-sets/994805260223102976/problems/type/7" target="_blank" rel="noopener">PAT (Basic Level) Practice（中文）</a></li>
</ul>
<hr>
<h1 id="A1101-Quick-Sort-B1045-快速排序"><a href="#A1101-Quick-Sort-B1045-快速排序" class="headerlink" title="A1101 Quick Sort | B1045 快速排序"></a><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805366343188480" target="_blank" rel="noopener">A1101 Quick Sort</a><a href=""> | </a><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805278589960192">B1045 快速排序</a></h1><p>作者: CAO Peng, 单位: Google, 时间限制: 200 ms, 内存限制: 64 MB</p>
<blockquote>
<p>There is a classical process named <strong>partition</strong> in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given <strong>N</strong> distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition?</p>
<p>For example, given <strong>N</strong> = <strong>5</strong> and the numbers 1, 3, 2, 4, and 5. We have:</p>
<ul>
<li>1 could be the pivot since there is no element to its left and all the elements to its right are larger than it;</li>
<li>3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well;</li>
<li>2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well;</li>
<li>and for the similar reason, 4 and 5 could also be the pivot.<br>Hence in total there are 3 pivot candidates.</li>
</ul>
<p><strong>Input Specification:</strong><br>Each input file contains one test case. For each case, the first line gives a positive integer <strong><em>N</em></strong> (≤ <strong>10</strong><sup>5</sup>). Then the next line contains <strong><em>N</em></strong> distinct positive integers no larger than <strong>10</strong><sup>9</sup>. The numbers in a line are separated by spaces.</p>
<p><strong>Output Specification:</strong><br>For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line.</p>
<p><strong>Sample Input:</strong><br>5<br>1 3 2 4 5</p>
<p><strong>Sample Output:</strong><br>3<br>1 4 5</p>
</blockquote>
<ul>
<li>题意：简单地描述快速排序的过程，即每趟排序均选择一个主元，将序列中所有小于主元的数排在其左侧，反之，将大于该主元的数排在其右侧，再将该主元两侧的序列递归地通过此方式排序，最终可使该序列整体有序。题目要求在给定的序列中找出可能是主元的数，并升序输出。具体描述可参考本题的乙级中文版 <a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805278589960192" target="_blank" rel="noopener">1045 快速排序 (25分)</a></li>
<li>思路：题目中已经给出例子，实际上只需要遍历该序列，并判断当前元素是否比所有其左侧元素都大且比所有其右侧元素均小即可。</li>
</ul>
<p>哈哈…当然没这么简单啦。</p>
<p>这类题读完的第一反应是暴力解决，直接嵌套两个for循环，把符合条件的结果保存到 <code>vector</code> 中即能得到答案，第二反应是看时间限制，<code>200ms</code> ，题目中 <strong>N</strong> 的最大规模是 <strong>10<sup>5</sup></strong>，暴力法的时间复杂度 <code>O(n</code><sup><code>2</code></sup><code>)</code>，那么实际上问题规模就变成了 <strong>10<sup>10</sup></strong>，这个执行次数在最坏情况下所用的时间已经远远超过 <code>100s</code> 了，所以暴力法一定会存在超时的测试点。于是我立马想到了可以稍作优化的解决方案：在遍历过程中，如果已经判定当前元素可以作为主元，那么至少我能保证在这个元素之后的所有元素均是大于该数的，因此在对下一个元素进行判定的时候就不需要再将当前元素与所有前面的元素进行大小比较了，而是直接从上一个满足条件的主元开始，于是设置一个 <code>left</code> 变量来记录左侧判断时循环开始的位置。但是这种做法，时间复杂度的数量级还是 <code>O(n</code><sup><code>2</code></sup><code>)</code>，所以当n很大的时候这种优化并没有多少意义，但是执念还是让我把代码写出来了，哈哈。</p>
<p>提交代码如下，核心代码 <strong>9-28</strong> 行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; v(n), ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i]);</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;                 <span class="comment">// 设置标志位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt; i; j++) &#123;  <span class="comment">// 从left开始</span></span><br><span class="line">            <span class="keyword">if</span> (v[j] &gt; v[i]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 及时退出, 下同</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果左侧判断均通过则还需判定右侧, 因此循环条件中先加入flag</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; flag &amp;&amp; j &lt; v.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[j] &lt; v[i]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;  <span class="comment">// 符合条件, 添加进vector</span></span><br><span class="line">            ans.push_back(v[i]);</span><br><span class="line">            left = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.begin(), ans.end());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans.size());</span><br><span class="line">    <span class="keyword">if</span> (ans.size() == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果不出所料的，有两个样例没通过，拿到 <strong>20/25分</strong> (这题目考察点就在算法的时间复杂度上)</p>
<p><img src="/img/pat-a1101(1).png" alt="暴力法提交结果"><br>所以，这题暴力法行不通（但考试的时候如果能在10分钟内把25分题拿到20分那也不错了，可以先直接换到下一题，哈哈）。于是更换思路，像这种类型的题，还能想到的方法是动态规划。设立 <code>dp</code> 数组，<code>dp[i]</code> 存放 <code>v[0~i]</code> 中最大的值，那么，对于满足条件的元素 <code>dp[i]</code> 必定是等于 <code>v[i]</code> 的，因此根据dp的定义，可以得到这样的式子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(dp[i - <span class="number">1</span>], v[i]);</span><br></pre></td></tr></table></figure>
<p>实际上，在动态规划中，把 <code>dp[i]</code> 称为问题的状态，上面的式子称作状态转移方程。那么对于判断当前元素是否是大于所有左侧元素就变成了判断 <code>v[i]</code> 是否与 <code>dp[i]</code> 相等。</p>
<p>再次提交代码，核心代码 <strong>8-22</strong> 行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; v(n), dp(n), ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i]);</span><br><span class="line">    dp[<span class="number">0</span>] = v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>], v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] != v[i]) flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; flag &amp;&amp; j &lt; v.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[j] &lt; v[i]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) ans.push_back(v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.begin(), ans.end());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans.size());</span><br><span class="line">    <span class="keyword">if</span> (ans.size() == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果较暴力法又多对了一个样例 ^_^!!</p>
<p><img src="/img/pat-a1101(2).png" alt="动态规划提交结果"><br>在上面这个解法中，动态规划的思想只使用于判断左侧元素是否均小于当前元素，实际上时间复杂度还是 <code>O(n</code><sup><code>2</code></sup><code>)</code>。所以，对于右侧元素还是同理，再另设dpMin数组，<code>dpMin[i]</code> 存放 <code>v[i~(n-1)]</code> 中最小的值，状态转移方程为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpMin[n - i - <span class="number">1</span>] = min(dpMin[n - i], v[n - i - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>再次提交代码如下，核心代码 <strong>8-16</strong> 行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    vector&lt;int&gt; v(n), dpMax(n), dpMin(n), ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i]);</span><br><span class="line">    dpMax[<span class="number">0</span>] = v[<span class="number">0</span>];</span><br><span class="line">    dpMin[n - <span class="number">1</span>] = v[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dpMax[i] = max(dpMax[i - <span class="number">1</span>], v[i]);</span><br><span class="line">        dpMin[n - i - <span class="number">1</span>] = min(dpMin[n - i], v[n - i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dpMax[i] == v[i] &amp;&amp; dpMin[i] == v[i]) ans.push_back(v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.begin(), ans.end());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans.size());</span><br><span class="line">    <span class="keyword">if</span> (ans.size() == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果预料之内，本题终于 <code>AC</code> 了，惊呼amazing，哈哈</p>
<p><img src="/img/pat-a1101(3).png" alt="动态规划提交结果"><br>其中最耗时的样例（也许是最大规模的极端数据）只用了 44ms，而这一次的时间复杂度变成了 <code>O(n)</code>，在大规模的问题中，时间复杂度从 <strong>O(n<sup>2</sup>)</strong> 到 <strong>O(n)</strong> 是很大的优化。至此本题也结束。</p>
<p>这道题从 <u>暴力法</u> 到 <u>动态规划</u> 直至 AC，写代码的过程并没花多少时间，但是这个思路的快速转变也是自己很大的进步，虽然是最基础的动态规划思想的使用，但是也完全体现出了动态规划的魅力，也使代码变得简短直观。</p>
<blockquote>
<p>Ps: 提交完AC的代码，也查看了其他网友的解法，似乎没人用DP，也许是大材小用吧，哈哈。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>距离上次，去年9月8号参加PAT甲级秋季考试已经过去4个月，上次的考试经历可谓糟糕且是一塌糊涂，从那到现在一直不变的始终是每天做题的习惯。今年3月，春季的甲级考试希望能拿到100分。</p>
</div><iframe src="/donate/?AliPayQR=/img/alipay_me.png&amp;WeChatQR=/img/wechat_me.png&amp;GitHub=https://github.com/charjindev/donate-page&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Char Jin</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2020/01/05/pat-a1101-b1045/">https://blog.charjin.top/2020/01/05/pat-a1101-b1045/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://blog.charjin.top/2020/01/05/pat-a1101-b1045/" data-id="clhhn3hsm004ktbrl95mic8fi" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACJklEQVR42u3azWrDQAxFYb//S6fQVSDYnCvFpZbOrEJJxvPNQtWPjwOv1+96//y+Pr9DfnW2w+c+X1syZMh4LKP2gOu/cOT1N8nZZMiQsYdxR5AlYZQwrs8mQ4YMGWnax3cmR5chQ4aMPoOndAQjQ4YMGdeMfgmaFsC16/hCLS5DhowHMmqDgb/5fPt8Q4YMGf+e8QpXJwjWmnroVDJkyBjNSJv+tYKWjwfS6HqkE1EZMmQ8nJGGvH6ByocH6FJkyJCxhsEfzweZnbBOElMZMmRsY/DxQG30yF+8iEtlGTJkjGakw4C7w2s6BZAhQ8ZsBi8UebMsKDsbSacMGTI2M2rHTRtwtbzudDcZMmQsYHTK2jRxrL2QgVJDGTJkjGbwUrNTH3NA3NSTIUPGaEbaOEsbZLzdz1PP06uRIUPGUEaaApIg2AmmteuQIUPGBkb6okMnNKdlMBqIypAhYzSj0+TimFo6GAd3GTJkjGaQo/MBQHroNKGMSTJkyHg4gz+SJ45petdp8MmQIWMbozaSJMfir1+kSBkyZGxg9AvaNJkjiWALIEOGjHGMV7h4+cpL3NoY4PT/hgwZMsYxOgGxkxryYN1/rgwZMmYwSJDlZW2t6c8DrgwZMjYzOseqXUctyYtbbDJkyFjG4C9ABAPIUrBuBVwZMmQsYNRabGkrLb1WGTJkbGCkKR0JmiTsEioaV8iQIWM0Iy0dWxvh/b9V9MqQIePhjB/zvDzim6E+kQAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><a href="/tags/PAT/">PAT</a><a href="/tags/%E7%BC%96%E7%A8%8B/">编程</a><a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a></div><div class="post-nav"><a class="pre" href="/2020/01/17/spring-junit5/">Spring Boot 中JUnit单元测试问题</a><a class="next" href="/2019/09/13/algo-pat2019-autumn-A/">PAT甲级2019秋季 - 初考总结篇</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' ? true : false;
var verify = 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'t4DnKL6Wzc2cJnKlPvgi1mFm-gzGzoHsz',
  appKey:'wRCuQw2SaMNzhBbLJClaYxn4',
  placeholder:'Just leave your comment, Haha...',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">39</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/">开发框架</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">编程笔记</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AF%E6%8A%80%E8%83%BD/">软技能</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" style="font-size: 15px;">树状数组</a> <a href="/tags/%E6%9F%A5%E6%89%BE/" style="font-size: 15px;">查找</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" style="font-size: 15px;">二分查找</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 15px;">二叉树</a> <a href="/tags/%E9%80%92%E5%BD%92%E6%B1%82%E8%A7%A3/" style="font-size: 15px;">递归求解</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" style="font-size: 15px;">二叉搜索树</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 15px;">动态规划</a> <a href="/tags/%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97/" style="font-size: 15px;">最长不下降子序列</a> <a href="/tags/PAT/" style="font-size: 15px;">PAT</a> <a href="/tags/%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">编程</a> <a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 15px;">生活</a> <a href="/tags/%E6%A0%91/" style="font-size: 15px;">树</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 15px;">并查集</a> <a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/OJ/" style="font-size: 15px;">OJ</a> <a href="/tags/%E6%A0%88/" style="font-size: 15px;">栈</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 15px;">队列</a> <a href="/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/" style="font-size: 15px;">堆排序</a> <a href="/tags/%E5%A0%86/" style="font-size: 15px;">堆</a> <a href="/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/" style="font-size: 15px;">版本控制</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 15px;">博客</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/%E7%AB%99%E7%82%B9url%E8%87%AA%E5%8A%A8%E6%8E%A8%E9%80%81/" style="font-size: 15px;">站点url自动推送</a> <a href="/tags/Kotlin/" style="font-size: 15px;">Kotlin</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">编程语言</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD/" style="font-size: 15px;">素数判断</a> <a href="/tags/%E6%A8%A1%E6%8B%9F/" style="font-size: 15px;">模拟</a> <a href="/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/" style="font-size: 15px;">进制转换</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 15px;">排序算法</a> <a href="/tags/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/" style="font-size: 15px;">简单排序</a> <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/" style="font-size: 15px;">最短路径算法</a> <a href="/tags/Dijkstra%E7%AE%97%E6%B3%95/" style="font-size: 15px;">Dijkstra算法</a> <a href="/tags/%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/" style="font-size: 15px;">有序序列的中位数</a> <a href="/tags/Dijkstra%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/" style="font-size: 15px;">Dijkstra最短路径算法</a> <a href="/tags/DFS/" style="font-size: 15px;">DFS</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" style="font-size: 15px;">深度优先搜索</a> <a href="/tags/%E5%89%AA%E6%9E%9D/" style="font-size: 15px;">剪枝</a> <a href="/tags/BFS/" style="font-size: 15px;">BFS</a> <a href="/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" style="font-size: 15px;">广度优先搜索</a> <a href="/tags/%E6%A8%A1%E6%8B%9F%E9%97%AE%E9%A2%98/" style="font-size: 15px;">模拟问题</a> <a href="/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 15px;">平衡二叉树</a> <a href="/tags/AVL/" style="font-size: 15px;">AVL</a> <a href="/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 15px;">完全二叉树</a> <a href="/tags/%E5%AE%8C%E5%85%A8%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 15px;">完全平衡二叉树</a> <a href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%88%A4%E5%88%AB/" style="font-size: 15px;">红黑树的判别</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" style="font-size: 15px;">二叉树最低公共祖先</a> <a href="/tags/LCA/" style="font-size: 15px;">LCA</a> <a href="/tags/%E5%A0%86%E7%9A%84%E5%88%A4%E5%AE%9A/" style="font-size: 15px;">堆的判定</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/" style="font-size: 15px;">字符串处理</a> <a href="/tags/PTA/" style="font-size: 15px;">PTA</a> <a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91Prime%E7%AE%97%E6%B3%95/" style="font-size: 15px;">最小生成树Prime算法</a> <a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91Kruskal%E7%AE%97%E6%B3%95/" style="font-size: 15px;">最小生成树Kruskal算法</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" style="font-size: 15px;">贪心算法</a> <a href="/tags/%E5%9B%A2%E4%BD%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A9%E6%A2%AF%E8%B5%9B/" style="font-size: 15px;">团体程序设计天梯赛</a> <a href="/tags/map/" style="font-size: 15px;">map</a> <a href="/tags/%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 15px;">前缀表达式</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90/" style="font-size: 15px;">字符串解析</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/openpyxl/" style="font-size: 15px;">openpyxl</a> <a href="/tags/tkinter/" style="font-size: 15px;">tkinter</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/JUnit/" style="font-size: 15px;">JUnit</a> <a href="/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" style="font-size: 15px;">单元测试</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/05/06/linux/screen/">Screen 命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/22/linux/docker-installation/">Docker 安装与配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/18/linux/terminal-proxy/">Linux 终端开启代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/31/linux/apt-errors/">Ubuntu 中的 apt 错误</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/28/linux/switch-intel-nvidia-graphics-card/">How To Switch Between Intel and Nvidia Graphics Card on Ubuntu</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/05/linux/ssh-disconnect-solution/">SSH 自动断连问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/27/linux/create-systemd-service/">Linux 中创建系统服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/28/linux/linux-firewall/">Linux 设置防火墙</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/17/linux/ssh-jump/">SSH 跳板服务器连接</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/12/01/linux/oh-my-zsh/">Linux终端配置 - ohmyzsh</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://pintia.cn" title="拼题A" target="_blank">拼题A</a><ul></ul><a href="https://kotlinlang.org" title="Kotlin" target="_blank">Kotlin</a><ul></ul><a href="https://www.patest.cn" title="PAT" target="_blank">PAT</a><ul></ul><a href="https://en.cppreference.com" title="C++ Reference" target="_blank">C++ Reference</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">Zhichao's Blog | </a><a href="http://beian.miit.gov.cn/" target="_blank" rel="noopener">浙ICP备18033074号-1</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/viz.js/1.7.1/viz.js"></script><script>String.prototype.replaceAll = function(search, replacement) {
  var target = this;
  return target.split(search).join(replacement);
};

let vizObjects = document.querySelectorAll('.graphviz')

for (let item of vizObjects) {
  let svg = undefined
  try {
    svg = Viz(item.textContent.replaceAll('–', '--'), 'svg')
  } catch(e) {
    svg = `<pre class="error">${e}</pre>`
  }
  item.outerHTML = svg
}</script></div></body></html>